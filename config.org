#+TITLE: Francis Murillo's Emacs configuration
#+AUTHOR: Francis Murillo
#+OPTIONS: toc:4 h:4
* Introduction
** If I Forget
   No words can describe my awe with Emacs and continue to do so. A text editor with a lisp interpreter, it's concept is so simple and sublime. What joy.

   I remember starting Emacs seriously at around August of 2015. Before then, I picked it up lightly and thought(not use) about it; but what really drove me to use it is.
   - Growth :: I was using an IDE before and somebody told me that GUIs change but the shell remains the same. I found myself over time exploring keyboard shortcuts, better terminals and Emacs(or maybe vi).
   - Lightweight :: I had a crappy laptop that always needed to be plugged, had a lot dead pixels, and closes when it overheats; I needed something that would work with what I had.
   - Linux :: Moving from Windows to Linux forced me to reevaluate the software I used. Adopting a new philosophy and OS pushed me in the right direction

   Whatever the reason might have been. I just want to say I'm a happy Emacs user and I find comfort and joy in hearing other people talk and share about it.
** About My Configuration
   I use org-babel as my configuration file once I heard you can do so. Splitting the configuration to multiple files was the plan but the way it weaves nicely to documentation immediately drew me in.

   You can load this with =(org-babel-load-file "/path/to/file")= if you need to reload any changes.

   This is my =init.el= to allow org-babel to read from it. My only problem is having the static org-mode in the elisp folder, you have to copy the elisp folder as well to make the configuration work as is.

   #+BEGIN_SRC emacs-lisp :tangle no
     (unless (>= emacs-major-version 24)
       (message "This config works only for Emacs version 24 and higher")
       (kill-emacs))

     ;; Helper functions
     (defun string/ends-with (s ending)
       "Return non-nil if string S ends with ENDING."
       (cond ((>= (length s) (length ending))
              (let ((elength (length ending)))
                (string= (substring s (- 0 elength)) ending)))
             (t nil)))

     (require 'cl)
     (setq load-path
           (remove-if
            (lambda (text) (string/ends-with text "org"))
            load-path))

     ;; customize loading the packages
     (package-initialize t)

     ;; Modify the hard dependencies
     ;; org-mode used to be here

     ;; Load the rest of the packages
     (package-initialize nil)

     ;; Configuration bootstrapping
     ;; use-package is fundamental to this configuration
     (unless (package-installed-p 'use-package)
       (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
       (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
       (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
       (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))

       (package-refresh-contents)
       (package-install 'use-package)
       (require 'use-package)

       (use-package org
         :ensure t)
       (use-package org-plus-contrib
         :ensure t)

       ;; Weird dependency
       (use-package dash
         :ensure t)
       (kill-emacs))

     ;; This part assumes ony org-babel-load-file is available
     (setq package-enable-at-startup nil)
     (org-babel-load-file
      (expand-file-name "config.org" user-emacs-directory))
   #+END_SRC

   Or with an function instead

   #+BEGIN_SRC emacs-lisp
     (defun fn/reload-config ()
     (interactive)
     (org-babel-load-file
      (expand-file-name "config.org" user-emacs-directory)))
   #+END_SRC

   Also the code formatting needs to be uniform within the code blocks

   #+BEGIN_SRC emacs-lisp
     (setq org-src-tab-acts-natively t)
   #+END_SRC
* Bootstrap
** Package Sources
   Add package sources if not present and reload, this should have been added in the =init.el= but checked here again for completion.

   #+BEGIN_SRC emacs-lisp
     ;; TODO: Make them work with https, apparently it is too slow over the wire
     (unless (assoc-default "melpa" package-archives)
       (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
       (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
       (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
       (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/")))
   #+END_SRC

** Package Manager
   The package manager of this whole configuration

   #+BEGIN_SRC emacs-lisp
     (require 'use-package)
     (setq use-package-verbose t)
   #+END_SRC

* Basic Setup
  Basic configurations anyone can do for vanilla Emacs

** Personal Information
   Just some things that relate to me

   #+BEGIN_SRC emacs-lisp
     (setq
      user-full-name "Francis Murillo"
      user-mail-address "francisavmurillo@gmail.com")
   #+END_SRC

** Customization
   Basis for configuration

   #+BEGIN_SRC emacs-lisp
     (defgroup fn nil
       "My namespace for customizing my configuration")

   #+END_SRC

** Startup
   Everything related to the startup state

    #+BEGIN_SRC emacs-lisp
      (setq gc-cons-threshold (* 128 1024 1024)) ;; High memory for Emacs

      (setq inhibit-startup-screen t ;; No need for the awesome startup screen.
            initial-scratch-message nil)
   #+END_SRC

** Environment
    Some environment configuration.

    #+BEGIN_SRC emacs-lisp
      (set-language-environment "UTF-8") ;; UTF-8 should be the enivorment

      (setq visible-bell t) ;; Visual bell for me since audio is a bit more distractive

      (fset 'yes-or-no-p 'y-or-n-p) ;; Y or N
    #+END_SRC

** Backups
    Backups are good, just annoying when things are good

   #+BEGIN_SRC emacs-lisp
     (setq backup-by-copying t
           kept-new-versions 10
           kept-old-versions 50

           delete-old-versions t
           version-conrol t
           vc-make-backup-files t
           backup-directory-alist (list (cons "." (expand-file-name "backups" user-emacs-directory)))
           auto-save-file-name-transforms (list (list ".*" (expand-file-name "auto-save-list/" user-emacs-directory) t)))
   #+END_SRC

** History
    Save minibuffer history

    #+BEGIN_SRC emacs-lisp
      (setq savehist-file (expand-file-name "savehist" user-emacs-directory))
      (setq history-length t)
      (setq history-delete-duplicates t)
      (setq savehist-save-minibuffer-history 1)
      (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))

      (savehist-mode 1)
    #+END_SRC

** Variables
    Some preset variables

    #+BEGIN_SRC emacs-lisp
      (setq whitespace-line-column 10000)
    #+END_SRC

** Buffer
    Some buffer configurations

    #+BEGIN_SRC emacs-lisp
      (let ((display-table (or standard-display-table (make-display-table))))
        (set-display-table-slot display-table
                                'vertical-border (make-glyph-code ?â”ƒ))
        (setq standard-display-table display-table))
    #+END_SRC

** Coding
    Some programming configuration that make sense

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "RET") 'newline-and-indent)

      (setq-default indent-tabs-mode nil)

      (make-variable-buffer-local
       (defvar fn/enable-whitespace-cleanup-before-save t
         "When non-nil, delete trailing whitespace on save"))

      (add-to-list 'safe-local-variable-values '(fn/enable-whitespace-cleanup-before-save))

      (defun fn/delete-trailing-whitespace-before-save ()
        (when fn/enable-whitespace-cleanup-before-save
          (with-current-buffer (current-buffer)
            (delete-trailing-whitespace (point-min) (point-max)))))

      (add-hook 'before-save-hook #'fn/delete-trailing-whitespace-before-save)


      (setq search-whitespace-regexp ".*?")

      (mouse-avoidance-mode 'cat-and-mouse)
      (temp-buffer-resize-mode 1)

      (setq auto-save-timeout 15
            require-final-newline t
            search-highlight t
            compilation-window-height 10
            compilation-scroll-output      'first-error
            compilation-ask-about-save nil)
    #+END_SRC

** Commands
    Unlock some commands I need

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-region 'disabled nil)
      (put 'downcase-region 'disabled nil)
      (put 'upcase-region 'disabled nil)
    #+END_SRC

* Dependencies
  Everything needed to support this more complex configurations

** async
    Not really builtin but should be

    #+BEGIN_SRC emacs-lisp
      (use-package async
        :ensure t)
    #+END_SRC

** s
   A string library, everyone needs that

   #+BEGIN_SRC emacs-lisp
     (use-package s
       :ensure t)
   #+END_SRC
** unicode-fonts
   Unicode is an required aesthetic

    #+BEGIN_SRC emacs-lisp
      (use-package unicode-fonts
        :ensure t
        :config
        (unicode-fonts-setup))
    #+END_SRC


** execute-shell
   Some external commands might be required, so gotta check them if they
   exist or install them if you have the time

   #+BEGIN_SRC emacs-lisp
     (defun fn/run-command (command &rest args)
       ;; Calls the process *command* and gets it's output, nil if there is an error"
       (condition-case ex
           (with-temp-buffer
             (apply 'call-process (append
                                   (list command nil t nil)
                                   args))
             (string-trim (buffer-string)))
         ('error nil)))

     (defun fn/check-command (command)
       ;; Another alias to *fn/run-command* but this time logs an output if the command does not exist
       (if (fn/run-command command)
           t
         (progn
           (message "Command *%s* is not available" command)
           nil)))
   #+END_SRC

** htmlize
   For exporting purposes

   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :load-path "elisp/htmlize-custom/"
       :after ox-reveal)
   #+END_SRC

* Terminator
  Shell related aspect

** exec-path-from-shell
    Command line integration

    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :ensure t
        :config
        (exec-path-from-shell-initialize))
    #+END_SRC

** term
    An enhancement for =term=

    #+BEGIN_SRC emacs-lisp
      (use-package term
        :bind (("C-c n t" . ansi-term))
        :config
        (defadvice term-sentinel (around ansi-term-kill-buffer (proc msg))
          (if (memq (process-status proc) '(signal exit))
              (let ((buffer (process-buffer proc)))
                ad-do-it
                (kill-buffer buffer))
            ad-do-it))
        (ad-activate 'term-sentinel)
        (defadvice ansi-term (before ansi-term-force-shell)
          (interactive (list (getenv "SHELL"))))
        (ad-activate 'ansi-term)
        (add-hook 'term-mode-hook 'goto-address-mode)
        (add-hook 'term-exec-hook
                  '(lambda ()
                     (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
    #+END_SRC

** eshell
    Another enhancement for the shell

    #+BEGIN_SRC emacs-lisp
      (use-package eshell
        :bind (("C-c n e" . eshell))
        :config
        (defun fn/eshell-rename-buffer-before-command ()
          (let* ((last-input
                  (buffer-substring eshell-last-input-start eshell-last-input-end)))
            (rename-buffer
             (format "*eshell[%s]$ %s...*" default-directory last-input) t)))
        (defun fn/eshell-rename-buffer-after-command ()
          (rename-buffer
           (format "*eshell[%s]$ %s*" default-directory
                   (eshell-previous-input-string 0)) t))
        (add-hook 'eshell-pre-command-hook
                  'fn/eshell-rename-buffer-before-command)
        (add-hook 'eshell-post-command-hook
                  'fn/eshell-rename-buffer-after-command)
        (use-package em-smart)
        (setq eshell-where-to-jump 'begin
              eshell-review-quick-commands nil
              eshell-smart-space-goes-to-end t)
        (add-hook 'eshell-mode-hook
                  (lambda ()
                    (eshell-smart-initialize))))
    #+END_SRC
** prodigy
    Living in the shell requires some genius

    #+BEGIN_SRC emacs-lisp
      (use-package prodigy
        :ensure t
        :defer t
        :bind (("C-c n q" . prodigy)))
    #+END_SRC
** emamux
   Work better with tmux

   #+BEGIN_SRC emacs-lisp
     (use-package emamux
       :ensure t
       :defer t)
   #+END_SRC

* Editor
  Anything to do with editing in Emacs

** Environment
*** guru
   Remember the Emacs's way to do things

    #+BEGIN_SRC emacs-lisp
      (use-package guru-mode
        :ensure t
        :diminish guru-mode
        :config
        (guru-global-mode t))
    #+END_SRC

*** visual-line
    Visual lines make more sense than the hard lines, what you see is
    what you get. Besides, I use syntax motions

    #+BEGIN_SRC emacs-lisp
      (use-package visual-line
        :init
        (global-visual-line-mode t)
        (diminish 'visual-line-mode))
    #+END_SRC

*** auto-fill
   Useful mode when writing, keeps things under 80 characters.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-fill
       :init
       (add-hook 'text-mode-hook 'turn-on-auto-fill)
       (diminish 'auto-fill-function)
       (setq-default fill-column 72))
   #+END_SRC

*** auto-revert
    The more generic revert

    #+BEGIN_SRC emacs-lisp
      (use-package auto-revert
        :diminish auto-revert-mode
        :init
        (global-auto-revert-mode t)
        (setq global-auto-revert-non-file-buffers t
              auto-revert-verbose nil))
    #+END_SRC

*** autorevert
    Enhancement for log reading

    #+BEGIN_SRC emacs-lisp
      (use-package autorevert
        :diminish auto-revert-mode
        :mode (("\\.log\\'" . auto-revert-tail-mode)));
    #+END_SRC

** Editing
*** hungry-delete
   Very useful default delete functionality

    #+BEGIN_SRC emacs-lisp
      (use-package hungry-delete
        :diminish hungry-delete-mode
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'hungry-delete-mode)
        (add-hook 'org-mode-hook 'hungry-delete-mode))
    #+END_SRC

*** aggressive-indent
    Maintaining indentation is awesome

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :ensure t
        :diminish aggressive-indent-mode
        :init
        (add-hook 'prog-mode-hook 'aggressive-indent-mode))
    #+END_SRC

*** expand-region
    Another great feature for marking

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :bind (("C-=" . er/expand-region)))
    #+END_SRC

*** multiple-cursors
    This functions does not get too much attention

    #+BEGIN_SRC emacs-lisp
      (use-package multiple-cursors
        :ensure t
        :bind (("C-S-c C-S-c" . mc/edit-lines)
               ("C->" . mc/mark-next-like-this)
               ("C-<" . mc/mark-previous-like-this)
               ("C-c C-<" . mc/mark-all-like-this)))
    #+END_SRC
*** undo-tree
    Visualizing undo like vi

    #+BEGIN_SRC emacs-lisp
      (use-package undo-tree
        :diminish undo-tree-mode
        :ensure t
        :config
        (global-undo-tree-mode 1))
    #+END_SRC

** Completion
*** hippie-exp
    Hippie expand rocks

    #+BEGIN_SRC emacs-lisp
      (use-package hippie-exp
        :config
        (global-set-key (kbd "M-/") 'hippie-expand)
        (setq hippie-expand-try-functions-list
              '(
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-complete-file-name-partially
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol)))
    #+END_SRC

*** company
    A replacement for =autocomplete=.

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :init
        (add-hook 'prog-mode-hook 'company-mode)
        :config
        (setq company-tooltip-limit 20
              company-tooltip-align-annotations t

              company-idle-delay 0.1

              company-show-numbers t
              company-minimum-prefix-length 2

              company-begin-commands '(self-insert-command))

        (setq company-backends '(company-elisp company-dabbrev-code))

        (defun fn/combine-backends (backend new-backend)
          (if (and (listp backend) (member new-backend backend))
              backend
            (let* ((list-backend (if (consp backend)
                                     backend
                                   (list backend)))
                   (with-backend (if (member ':with list-backend)
                                     list-backend
                                   (append list-backend '(:with)))))
              (append with-backend (list new-backend)))))

        (defun fn/append-to-backends (new-backend)
          (setq company-backends
                (mapcar
                 (lambda (backend)
                   (fn/combine-backends backend new-backend))
                 company-backends)))

        (setq fn/company-prog-backends '(company-dabbrev-code company-keywords))

        (defun fn/backend-with-prog ()
          (fn/append-to-backends 'company-keywords)
          (fn/append-to-backends 'company-dabbrev-code))

        (add-hook 'after-init-hook 'fn/backend-with-prog))
    #+END_SRC

*** yasnippet
    Snippet system along with autocomplete is awesome

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :ensure t
        :after company
        :defer t
        :diminish yas-minor-mode
        :bind (("C-c n y" . yas-new-snippet))
        :config
        (setq yas-verbosity 3)

        (push 'yas-hippie-try-expand hippie-expand-try-functions-list)

        (yas-reload-all)

        (add-hook 'prog-mode-hook 'yas/minor-mode-on)

        (defun fn/add-company-yasnippet ()
          (fn/append-to-backends 'company-yasnippet))

        (add-hook 'after-init-hook 'fn/add-company-yasnippet))
    #+END_SRC

* Ergonomic
  Things to assist in managing Emacs

** Windows
   Anything related to window management

*** workgroups
    Saving window state is very helpful specially when you move a lots

    #+BEGIN_SRC emacs-lisp
      (use-package workgroups2
        :ensure t
        :bind (("C-c n w" . workgroups-mode))
        :init
        (setq wg-prefix-key (kbd "C-c w")
              wg-session-file (expand-file-name ".emacs_workgroups" user-emacs-directory))

        (setq wg-morph-on nil)

        (setq wg-emacs-exit-save-behavior           'save
              wg-workgroups-mode-exit-save-behavior 'save)

        (setq wg-flag-modified nil)

        (setq wg-mode-line-display-on t
              wg-mode-line-decor-left-brace "["
              wg-mode-line-decor-right-brace "]"
              wg-mode-line-decor-divider ":"))
   #+END_SRC

*** winner
    You got to have those window configuration

    #+BEGIN_SRC emacs-lisp
      (use-package winner
        :ensure t
        :config
        (winner-mode t))
    #+END_SRC

*** window-numbering
    A must to navigate through windows with numbers.

    #+BEGIN_SRC emacs-lisp
      (use-package window-numbering
        :ensure t
        :config
        (window-numbering-mode t)

        (defun fn/tweak-window-numbering-faces ()
          (custom-set-faces
           '(window-numbering-face ((t (:foreground "tomato" :weight extra-bold))) t)))

        (fn/tweak-window-numbering-faces)

        (add-hook 'smart-mode-line-hook 'fn/tweak-window-numbering-faces))
    #+END_SRC

*** golden-ratio
    Makes windows large enough to see.

    #+BEGIN_SRC emacs-lisp
      (use-package golden-ratio
        :ensure t
        :after window-numbering
        :diminish golden-ratio-mode
        :bind (("C-c q" . golden-ratio))
        :config
        (golden-ratio-mode t)

        (setq split-width-threshold nil
              golden-ratio-adjust-factor 1.0)

        ;; If there are workgroups, make sure the currently focused buffer is rationed
        (add-hook 'wg-after-switch-to-workgroup-hook 'golden-ratio)

        (defun select-rationed-window-1 ()
          (interactive)
          (select-window-1)
          (golden-ratio))
        (defun select-rationed-window-2 ()
          (interactive)
          (select-window-2)
          (golden-ratio))
        (defun select-rationed-window-3 ()
          (interactive)
          (select-window-3)
          (golden-ratio))
        (defun select-rationed-window-4 ()
          (interactive)
          (select-window-4)
          (golden-ratio))
        (defun select-rationed-window-5 ()
          (interactive)
          (select-window-5)
          (golden-ratio))
        (defun select-rationed-window-6 ()
          (interactive)
          (select-window-6)
          (golden-ratio))
        (defun select-rationed-window-7 ()
          (interactive)
          (select-window-7)
          (golden-ratio))
        (defun select-rationed-window-8 ()
          (interactive)
          (select-window-8)
          (golden-ratio))
        (defun select-rationed-window-9 ()
          (interactive)
          (select-window-9)
          (golden-ratio))

        (define-key window-numbering-keymap (kbd "M-1") 'select-rationed-window-1)
        (define-key window-numbering-keymap (kbd "M-2") 'select-rationed-window-2)
        (define-key window-numbering-keymap (kbd "M-3") 'select-rationed-window-3)
        (define-key window-numbering-keymap (kbd "M-4") 'select-rationed-window-4)
        (define-key window-numbering-keymap (kbd "M-5") 'select-rationed-window-5)
        (define-key window-numbering-keymap (kbd "M-6") 'select-rationed-window-6)
        (define-key window-numbering-keymap (kbd "M-7") 'select-rationed-window-7)
        (define-key window-numbering-keymap (kbd "M-8") 'select-rationed-window-8)
        (define-key window-numbering-keymap (kbd "M-9") 'select-rationed-window-9)
        (define-key window-numbering-keymap (kbd "M-0") 'select-rationed-window-0))
    #+END_SRC

*** uniquify
    Nicer naming convention

    #+BEGIN_SRC emacs-lisp
      (use-package uniquify
        :if (version<= emacs-version "24.3.1")
        :config
        (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
    #+END_SRC

** Buffers
   Anything related to buffers

*** recentf
    Accessing the files recently

    #+BEGIN_SRC emacs-lisp
      (use-package recentf
        :defer t
        :config
        (recentf-mode 1)
        (setq recentf-max-menu-items 100)
        (global-set-key "\C-x\ \C-r" 'recentf-open-files)
        (setq recentf-exclude '("TAGS" ".*-autoloads\\.el\\'")))
    #+END_SRC
*** projectile
    Must have a project finder when using a project.

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :diminish projectile-mode
        :config

        (defconst fn/project-file ".project.el"
          "Project configuration file")

        (defconst fn/project-local-file ".project-local.el"
          "Project local setting file")

        (defun fn/load-project-file ()
          ;; When the project is switched, run a custom initialization file.
          ;; Be careful though with side effects, make the init file fast and pure/side-effect free
          (interactive)
          (when (projectile-project-p)
            (let* ((current-project-root (projectile-project-root))
                   (project-init-file (expand-file-name fn/project-file current-project-root)))
              (when (file-exists-p project-init-file)
                (message (concat  "Loading project init file for " current-project-root))
                (load project-init-file t)))))

        (defun fn/load-project-local-file ()
          (interactive)
          (when (projectile-project-p)
            (let* ((current-project-root (projectile-project-root))
                   (project-local-init-file (expand-file-name fn/project-local-file current-project-root)))
              (when (file-exists-p project-local-init-file)
                (message (concat  "Loading project local file for " current-project-root))
                (load project-local-init-file t)))))

        (let* ((project-memoized (lambda ()
                                   (lexical-let ((initialized-projects (list ".")))
                                     #'(lambda ()
                                         (when (projectile-project-p)
                                           (lexical-let ((current-project (projectile-project-root)))
                                             (if (not (member current-project initialized-projects))
                                                 (progn
                                                   (add-to-list 'initialized-projects current-project)
                                                   (fn/load-project-file))
                                               (message "%s is already loaded." current-project)
                                               )))))))
               (load-project-hook (funcall project-memoized)))
          (add-hook 'projectile-after-switch-project-hook load-project-hook))

        (add-hook 'find-file-hook 'fn/load-project-file)
        (add-hook 'find-dired-hook 'fn/load-project-file)

        (projectile-global-mode t)
        (setq projectile-indexing-method 'native)

        (add-to-list 'projectile-project-root-files "config.xml"))
    #+END_SRC

*** helm
    The revolutionary package to find

    #+BEGIN_SRC emacs-lisp
      (use-package helm
        :ensure t
        :diminish helm-mode
        :defer 2
        :bind (("M-x" . helm-M-x)
               ("C-c f" . helm-recentf)
               ("C-h a" . helm-apropos)
               ("C-h r" . helm-info-emacs)
               ("C-x b" . helm-mini)
               ("C-x C-b" . helm-buffers-list)
               ("C-x C-f" . helm-find-files)
               ("M-s o" . helm-occur))
        :config
        (require 'helm-config)
        (setq helm-mode-fuzzy-match t)
        (setq helm-completion-in-region-fuzzy-match t)

        (setq helm-split-window-in-side-p t
              helm-yank-symbol-first t
              helm-buffers-fuzzy-matching t
              helm-apropos-fuzzy-match t
              helm-recentf-fuzzy-match t
              helm-semantic-fuzzy-match t
              helm-locate-fuzzy-match t
              helm-ff-file-name-history-use-recentf t
              helm-su-or-sudo "su"
              helm-ff-auto-update-initial-value t)

        (helm-mode t)

        (helm-adaptive-mode t)

        (helm-autoresize-mode t)


        (add-hook 'eshell-mode-hook
                  (lambda ()
                    (define-key eshell-mode-map
                      [remap eshell-pcomplete]
                      'helm-esh-pcomplete)
                    (define-key eshell-mode-map
                      (kbd "M-p")
                      'helm-eshell-history)))

        (ido-mode -1))


      (use-package helm-projectile
        :ensure t
        :after (projectile helm)
        :bind (("C-c p h" . helm-projectile)
               ("C-c p p" . helm-projectile-switch-project))
        :config
        (setq projectile-completion-system 'helm)
        (helm-projectile-on))

      (use-package helm-swoop
        :ensure t
        :after helm
        :bind (("M-i" . helm-swoop)
               ("C-c M-i" . helm-multi-swoop))
        :config
        (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
        (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line))

      (use-package wgrep-helm
        :ensure t
        :after helm
        :config
        (setq wgrep-auto-save-buffer t))
    #+END_SRC

** Help
   Helper functions ere

*** command-log
    A command log when needed

    #+BEGIN_SRC emacs-lisp
      (use-package command-log-mode
        :ensure t
        :diminish command-log-mode
        :config
        (global-command-log-mode t))
    #+END_SRC

*** keyfreq
    Nice to know what key's I press the most

    #+BEGIN_SRC emacs-lisp
      (use-package keyfreq
        :ensure t
        :bind (("C-c n K" . keyfreq-show))
        :config
        (keyfreq-mode t)
        (keyfreq-autosave-mode t)
        (setq keyfreq-file (expand-file-name ".keyfreq" user-emacs-directory)
              keyfreq-file-lock (expand-file-name ".keyfreq.lock" user-emacs-directory)))
    #+END_SRC

*** which-key
    A mnemionic for key bindings

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :ensure t
        :diminish which-key-mode
        :config
        (which-key-mode t))
    #+END_SRC

*** which-function
    Likewise with key and funcitons

    #+BEGIN_SRC emacs-lisp
      (use-package which-function
        :init
        (which-function-mode t))
    #+END_SRC

*** eldoc
    Nice to have the documentation at any time in the buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :diminish eldoc-mode
        :init
        (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

        (add-hook 'org-mode-hook 'turn-on-eldoc-mode))
    #+END_SRC

*** helm-descbinds
    Another way to check bindings

    #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :ensure t
        :after helm
        :bind (("C-h b" . helm-descbinds)))
    #+END_SRC

*** helm-describe-modes
    A nice way to describe the current modes

    #+BEGIN_SRC emacs-lisp
      (use-package helm-describe-modes
        :ensure t
        :after helm
        :config
        (global-set-key [remap describe-mode] #'helm-describe-modes))
    #+END_SRC
** Packages
   Anything to manage packages

*** paradox
    The package management improvement

    #+BEGIN_SRC emacs-lisp
      (use-package paradox
        :ensure t
        :bind (("C-c n p" . paradox-list-packages))
        :config
        (setq paradox-github-token t))
    #+END_SRC

* Artist
  Visual aesthetics is also a functional thing as well

** Font
    I like fixed font specially DejaVu Mono

    #+BEGIN_SRC emacs-lisp
      (set-frame-font "DejaVu Sans Mono-8" t t )
    #+END_SRC

** Screen
    I prefer no clutter in my screen so I disable majority of the niceties.

    #+BEGIN_SRC emacs-lisp
      (defun fn/optimize-visual-space ()
        (let ((try-set-mode (lambda (mode value)
                              (when (fboundp 'mode)
                                (mode value)))))
          (funcall try-set-mode 'tooltip-mode -1)
          (funcall try-set-mode 'tool-bar-mode -1)
          (funcall try-set-mode 'menu-bar-mode -1)
          (funcall try-set-mode 'fringe-mode 0)))

      (fn/optimize-visual-space)

      (add-hook 'after-init-hook 'toggle-frame-fullscreen)
    #+END_SRC

** Theme
   I like dark themes, my eyes respond better to it

   My chosen themes

    #+BEGIN_SRC emacs-lisp
      (use-package apropospriate-theme
        :ensure t
        :defer t)

      (use-package base16-theme
        :ensure t
        :defer t)
    #+END_SRC

    Load the theme if it is a terminal or desktop.

    #+BEGIN_SRC emacs-lisp
      (when (window-system)
        (load-theme 'apropospriate-dark t))

      (unless (window-system)
        (load-theme 'base16-solarized-dark t))
    #+END_SRC

** Aesthetic
   Somewhat more aesthetic than functional

*** whitespace
    Got to love that whitespace display

    #+BEGIN_SRC emacs-lisp
      (use-package whitespace-mode
        :init
        (global-whitespace-mode t)
        (diminish 'global-whitespace-mode))
    #+END_SRC

*** diff-hl
    Diffing tool

    #+BEGIN_SRC emacs-lisp
      (use-package diff-hl
        :ensure t
        :config
        (global-diff-hl-mode)
        (setq diff-hl-side 'left)
        (diff-hl-margin-mode)
        (eval-after-load "magit"
          '(add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
    #+END_SRC
*** hl-line
    Highlight the current line

    #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :diminish hl-line-mode
        :init
        (global-hl-line-mode t))
    #+END_SRC

*** smart-mode-line
    It is a nice feature

    #+BEGIN_SRC emacs-lisp
      (use-package smart-mode-line-powerline-theme
        :ensure t)

      (use-package smart-mode-line
        :ensure t
        :config
        (setq sml/no-confirm-load-theme t
              sml/shorten-directory t
              sml/shorten-modes t
              sml/theme 'powerline)

        (sml/setup))
    #+END_SRC

** Screensaver
   When idle time hits

*** nyan
    Love them kitty down there. Also this keeps things in perspective to have fun.

    #+BEGIN_SRC emacs-lisp
      (use-package nyan-mode
        :ensure t
        :config
        (nyan-mode t))
    #+END_SRC

*** fireplace
    Warm and cozy feeling

    #+BEGIN_SRC emacs-lisp
      (use-package fireplace
        :bind (("C-c n f" . fireplace))
        :ensure t)
    #+END_SRC

*** zone
    I love to zone out from time to time.

    #+BEGIN_SRC emacs-lisp
      (use-package zone
        :ensure t
        :config
        (zone-when-idle 300) ;; 5 minutes is a good enough time
        (setq zone-programs (list))

        (setq
         zone-animation-directory (expand-file-name "elisp/custom-zone" user-emacs-directory)
         end-of-buffer-animation (expand-file-name "end-of-buffer.el" zone-animation-directory)
         waves-animation (expand-file-name "waves.el" zone-animation-directory)
         )

        (load-file end-of-buffer-animation)
        (load-file waves-animation)

        (add-to-list 'zone-programs 'zone-end-of-buffer)
        (add-to-list 'zone-programs 'zone-waves))

      (use-package zone-nyan
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-nyan))

      (use-package zone-rainbow
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-rainbow))

      (use-package zone-sl
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-sl))
    #+END_SRC

** Coding
   Whatever pertains to coding

*** font-lock
    Syntax highlighting is a requirement

    #+BEGIN_SRC emacs-lisp
      (global-font-lock-mode t)

      (setq font-lock-support-mode 'jit-lock-mode)
      (setq font-lock-maximum-decoration t)
    #+END_SRC
*** prettify-symbols
    Make things more algebraic

    #+BEGIN_SRC emacs-lisp
      (setq fn/enable-prettify-symbols nil)

      (use-package prettify-symbols-mode
        :if (version<= "24.4.4" emacs-version)
        :init
        (setq fn/enable-prettify-symbols t))
    #+END_SRC

*** rainbow-delimeter
    Visual aid helps with very nested code

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
        :config
        (custom-set-faces
         ;; Thanks to https://ericscrivner.me/2015/06/better-emacs-rainbow-delimiters-color-scheme/
         '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
         '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
         '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
         '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
         '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
         '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
         '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
         '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))))

    #+END_SRC

*** color-identifiers-mode
    Make things easier to see

    #+BEGIN_SRC emacs-lisp
      (use-package color-identifiers-mode
        :ensure t
        :defer t
        :diminish color-identifiers-mode
        :init
        (add-hook 'prog-mode-hook 'color-identifiers-mode))
    #+END_SRC
*** show-paren
    Also a vital thing to keeping things highlighted

    #+BEGIN_SRC emacs-lisp
      (show-paren-mode t)

      (setq show-paren-style 'expression)
    #+END_SRC

* Organizer
  Things to organize life in general

** epa
    Encryption is a must

    Credits to [[http://conornash.com/2014/03/transparently-encrypt-org-files-in-emacs/][Conor Nash]] for this

    #+BEGIN_SRC emacs-lisp
      (require 'epa-file)
      (epa-file-enable)

      (defun fn/backup-each-save-filter (filename)
        (let ((ignored-filenames
               '("\\.gpg$"))
              (matched-ignored-filename nil))
          (mapc
           (lambda (x)
             (when (string-match x filename)
               (setq matched-ignored-filename t)))
           ignored-filenames)
          (not matched-ignored-filename)))

      (setq backup-each-save-filter-function 'fn/backup-each-save-filter)

      (setq enable-local-variables :safe)

      (add-to-list 'safe-local-variable-values '(auto-save-default))
      (add-to-list 'safe-local-variable-values  '(backup-inhibited . t))
      (add-to-list 'safe-local-variable-values '(epa-file-encrypt-to))
    #+END_SRC
** org
    org-mode my buddy. This is filed under external modes since I download a new copy of org mode to be updated.

    Some basic setup which I use =org-drill= and =org-journal=

    Here is a reference to the  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Time-Parsing.html][date time format]].

    #+BEGIN_SRC emacs-lisp
      (use-package org
        :bind (("C-c l" . org-store-link)
               ("C-c a" . org-agenda)
               ("C-c h" . helm-org-in-buffer-headings))
        :config
        ;; Config
        (setq org-log-done 'time)

        ;; Setup
        (add-to-list 'org-modules 'org-drill)

        ;; Todo
        (setq org-todo-keywords
              '((sequence "INVESTIGATE(i)" "TODO(t)" "PENDING(p)" "|" "DONE(d)" "CANCELLED(c)")))

        ;; Capture
        (setq org-directory
              (expand-file-name "~/Fakespace/nobody-library"))
        (setq org-default-notes-file (concat org-directory "/capture.org")) ;; Personal org library

        (setq org-main-file (expand-file-name "main.org" org-directory))
        (setq org-review-file (expand-file-name "learning.org" org-directory))
        (setq org-todo-file (expand-file-name "todo.org" org-directory))
        (setq org-blog-file (expand-file-name "fnlog.org" org-directory))

        (define-key global-map "\C-cc" 'org-capture)  ;; Use suggested key binding
        (setq org-capture-templates
              (list
               (list "t" "Todo" 'entry
                     (list 'file+headline org-todo-file "Todo")
                     "* INVESTIGATE %?\n   %i\n  %a")
               (list "r" "Review/Remember" 'entry
                     (list 'file+headline org-review-file "Learning Notes" "Review")
                     "* %? :drill:\n  CREATED_ON: %T")))

        ;; Agenda
        (setq org-agenda-span 14) ;; Fortnight

        (setq org-planning-files
              (list
               org-main-file
               org-blog-file
               ))

        (setq org-task-files
              (list
               org-todo-file
               org-review-file))

        (setq org-agenda-files
              (append
               org-planning-files
               org-task-files))

        (setq org-refile-targets nil) ;; TODO: Make refile tagets

        ;; org-drill
        (require 'org-drill)
        (setq org-drill-scope
              (list org-review-file))



        (require 'org-mobile)
        (setq org-mobile-directory
              (expand-file-name "mobile" org-directory))
        (setq org-mobile-inbox-for-pull
              (expand-file-name "mobile-pull" org-directory))
        (setq org-mobile-files
              (list org-review-file)))
    #+END_SRC

    I prefer to see my main org file on boot

    #+BEGIN_SRC emacs-lisp
      (defun fn/find-main-org-file ()
        (interactive)
        (find-file org-main-file))

      (setq initial-buffer-choice org-main-file)

    #+END_SRC

*** org-journal
    Having a journal is good

    #+BEGIN_SRC emacs-lisp
      (use-package org-journal
        :ensure t
        :after org
        :bind (("C-c n j" . org-journal-new-entry)) ;; C-c j conflicts with normal org-mode
        :config
        (setq org-journal-dir
              (expand-file-name "diary" org-directory))

        (setq org-journal-date-format "%Y-%b-%d %a" ;; YYYY-MMM-DD DAY
              org-journal-time-format "%T ") ;; HH:MM:SS and the space is required

        (setq org-journal-file-format "%Y-%m-%d.journal.org.gpg") ;; Encryption via epa

        (setq org-journal-find-file 'find-file)

        (defun fn/insert-private-file-headers ()
          (interactive)
          (add-file-local-variable-prop-line 'backup-inhibited t)
          (add-file-local-variable-prop-line 'auto-save-default nil))

        (defun fn/insert-org-gpg-headers ()
          (interactive)
          (add-file-local-variable-prop-line
           'epa-file-encrypt-to (list "fnmurillo@yandex.com"))
          (fn/insert-private-file-headers))

        (defun fn/insert-org-journal-headers ()
          (interactive)
          (fn/insert-org-gpg-headers)

          (end-of-visual-line)
          (newline-and-indent)

          (when (string-match "\\(20[0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)"
                              (buffer-name))
            (let ((year  (string-to-number (match-string 1 (buffer-name))))
                  (month (string-to-number (match-string 2 (buffer-name))))
                  (day (string-to-number (match-string 3 (buffer-name))))
                  (datim nil))
              (setq datim (encode-time 0 0 0 day month year))

              (insert "#+STARTUP: content\n")
              (insert (format-time-string
                       "#+TITLE: Journal Entry - %Y-%b-%d %a\n" datim))
              (insert (format-time-string
                       "* %Y-%b-%d %a" datim)))))

        (auto-insert-mode t)
        (setq auto-insert-query t) ;; Don't ask, just put it in there
        (add-hook 'find-file-hook 'auto-insert)

        (add-to-list 'auto-insert-alist '(".*\.org\.gpg$" . fn/insert-org-gpg-headers))
        (add-to-list 'auto-insert-alist '(".*\.private.org" . fn/insert-private-file-headers))
        (add-to-list 'auto-insert-alist '(".*\.journal.org.gpg" . fn/insert-org-journal-headers)))
    #+END_SRC

*** org-reveal
     A nice presentation framework

     #+BEGIN_SRC emacs-lisp
       (use-package ox-reveal
         :ensure t
         :after org
         :config
         (setq org-reveal-root "file:////home/fnmurillo/Fakespace/reveal-js")


         (define-minor-mode fn-reveal-editing
           "Some editing enhancement when editing org-reveal files"
           :lighter " FnRevealer"
           :init-value nil
           :global nil
           (make-variable-buffer-local
            (defvar fnr/enable-auto-export-on-save t
              "When non-nil. auto exports org-reveal files on save"))

           (let ((export-reveal (lambda ()
                                  (when fnr/enable-auto-export-on-save
                                    (org-reveal-export-to-html t)))))
             (add-hook 'after-save-hook export-reveal t t))))
     #+END_SRC

*** org-present
    A presentation tool with =org=

    #+BEGIN_SRC emacs-lisp
      (use-package org-present
        :ensure t
        :after org
        :config
        (add-hook 'org-present-mode-hook
                  (lambda ()
                    (org-present-big)
                    (org-display-inline-images)
                    (org-present-hide-cursor)
                    (org-present-read-only)))

        (add-hook 'org-present-mode-quit-hook
                  (lambda ()
                    (org-present-small)
                    (org-remove-inline-images)
                    (org-present-show-cursor)
                    (org-present-read-write)))

        (define-key org-mode-map (kbd "C-c n p") 'org-present))
    #+END_SRC

*** org-tree-slide
    Another =org= presentation tool

    #+BEGIN_SRC emacs-lisp
      (use-package org-tree-slide
        :ensure t
        :after org)
    #+END_SRC

** flyspell
    Having a good spell checker is a must. I use =flyspell= although I have read issues about it

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell
        :ensure t
        :defer t
        :diminish flyspell-mode
        :init
         (add-hook 'org-mode-hook 'flyspell-mode t))
    #+END_SRC

** dired
    Directory management for Emacs

    #+BEGIN_SRC emacs-lisp
      (require 'dired-x) ;; Allows multi open marked files

      (setq dired-recursive-copies 'always  ;; Don't ask because I did it
            dired-recursive-deletes 'always)

      (setq dired-dwim-target t) ;; Split pane copying, be careful though with this

      (setq dired-listing-switches "-alh") ;; Want to see the size with better details

      (dired-async-mode t)

      (add-hook 'dired-mode-hook 'dired-hide-details-mode)
    #+END_SRC

*** tmtxt
    Experimental =dired= with =rsync= all thanks to [[https://github.com/tmtxt][tmtxt]]

    #+BEGIN_SRC emacs-lisp
      (use-package tmtxt-async-tasks
        :load-path "elisp/tmtxt/"
        :config
        (setq-default tat/window-close-delay "10"
                      tat/window-height 5))

      (use-package tmtxt-dired-async
        :after tmtxt-async-tasks
        :config
        (when (fn/check-command "rsync")
          (setq-default tda/rsync-arguments "-avzh --progress")

          (define-key dired-mode-map (kbd "C-c C-r") 'tda/rsync)
          (define-key dired-mode-map (kbd "C-c C-t") 'tda/rsync-delete)

          (define-key dired-mode-map (kbd "C-c C-a") 'tda/rsync-multiple-mark-file)
          (define-key dired-mode-map (kbd "C-c C-e") 'tda/rsync-multiple-empty-list)
          (define-key dired-mode-map (kbd "C-c C-d") 'tda/rsync-multiple-remove-item)
          (define-key dired-mode-map (kbd "C-c C-v") 'tda/rsync-multiple))

        (define-key dired-mode-map (kbd "C-c C-z") 'tda/zip)
        (define-key dired-mode-map (kbd "C-c C-u") 'tda/unzip)

        (define-key dired-mode-map (kbd "C-c C-s") 'tda/get-files-size)

        (define-key dired-mode-map (kbd "C-c C-q") 'tda/download-to-current-dir)
        (define-key dired-mode-map (kbd "C-c C-l") 'tda/download-clipboard-link-to-current-dir))
    #+END_SRC

* Code Monkey
  Modes for my programming experiences

** Support

*** type-break-mode
    I definitely need to chill out from time to time

    #+BEGIN_SRC emacs-lisp
      (use-package type-break
        :init
        (type-break-mode t)
        (type-break-query-mode t)
        :config
        (setq type-break-interval (* 60 25)
              type-break-good-rest-interva (* 60 5)))
    #+END_SRC
*** auto-compile
    A good mode when editing lisp files

    #+BEGIN_SRC emacs-lisp
      (use-package auto-compile
        :ensure t
        :defer t
        :init
        (add-hook 'emacs-lisp-mode-hook 'auto-compile-mode)
        :config
        (setq load-prefer-newer t)
        (auto-compile-on-load-mode)
        (auto-compile-on-save-mode))
    #+END_SRC
*** smartparens
    This is as handy as =paredit=

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :diminish smartparens-mode
        :ensure t
        :config
        (use-package smartparens-config)
        (smartparens-global-mode 1))
    #+END_SRC

*** flycheck
    Syntax checking is very important

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer  t
        :diminish flycheck-mode
        :init
        (add-hook 'js2-mode-hook 'flycheck-mode)
        (add-hook 'web-mode 'flycheck-mode)
        (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
        (add-hook 'python-mode 'flycheck-mode)
        :config
        (setq flycheck-highlighting-mode 'sexps)

        (defun fn/tweak-flycheck-python ()
          ;; TODO:When python get slow in flycheck, highlighting mode should be set to lines instead
          )

        (add-hook 'python-mode-hook 'fn/tweak-flycheck-python))

      (use-package flycheck-pos-tip
        :ensure t
        :after flycheck
        :config
        (flycheck-pos-tip-mode t))
    #+END_SRC

*** magit
    Enough said, [[https://github.com/magit/magit][magit]] is the best git client you can get anywhere.

    There is a sad version requirement for 24.4 to use the latest code.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :if (version<= "24.4.4" emacs-version)
        :bind (("C-c g" . magit-status)
               ("M-g b" . magit-blame))
        :init
        (setq magit-push-always-verify t))

      (use-package git-timemachine
        :ensure t
        :bind (("M-g t" . git-timemachine)))

      (use-package git-gutter
        :ensure t
        :diminish git-gutter-mode
        :config
        (global-git-gutter-mode t))
    #+END_SRC

*** gist
    GitHub integration with gists

    #+BEGIN_SRC emacs-lisp
      (use-package gist
        :ensure t
        :defer t
        )
    #+END_SRC
** Elisp
*** Motion
    Makes you a good lisp developer and quite addictive to have

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t
        :defer t
        :diminish paredit-mode
        :init
        (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
        (add-hook 'ielm-mode-hook 'paredit-mode)
        (add-hook 'lisp-mode-hook 'paredit-mode)
        (add-hook 'lisp-interaction-mode-hook 'paredit-mode)
        :config
        (require 'eldoc)
        (eldoc-add-command
         'paredit-backward-delete
         'paredit-close-round))


    #+END_SRC
*** Refactor
    Emacs Lisp refactor mode

    #+BEGIN_SRC emacs-lisp
      (use-package emr
        :ensure t
        :defer t
        :init
        (define-key prog-mode-map (kbd "M-RET") 'emr-show-refactor-menu)
        (add-hook 'prog-mode-hook 'emr-initialize))
    #+END_SRC
** Web
*** Mode
    The defacto mode for web development

    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :ensure t
        :mode (("\\.tt\\'" . web-mode)
               ("\\.erb\\'" . web-mode)
               ("\\.html\\.ep\\'" . web-mode)
               ("\\.blade\\.php\\'" . web-mode)
               ("\\.hbs\\'" . web-mode))
        :init
        (dolist (hook '(emmet-mode))
          (add-hook 'web-mode-hook hook))
        :config
        (setq web-mode-enable-auto-pairing t
              web-mode-enable-auto-closing t
              web-mode-enable-current-element-highlight t
              web-mode-enable-current-column-highlight t))

      (use-package company-web
        :ensure t
        :after web)
    #+END_SRC

*** Editing
    I do a lot of HTML editing, YASnippet can do but emmet is better

    #+BEGIN_SRC emacs-lisp
      (use-package emmet-mode
        :ensure t
        :defer t
        :init
        (dolist (hook '(sgml-mode-hook css-mode-hook kolon-mode-hook))
          (add-hook hook 'emmet-mode)))
    #+END_SRC

*** CSS
    I use [[http://sass-lang.com/][sass]] for my jekyll blog

    #+BEGIN_SRC emacs-lisp
      (use-package sass-mode
        :ensure t
        :defer t
        :config
        ((add-to-list 'auto-mode-alist '("\\.sass\\'" . sass-mode))))
    #+END_SRC
** JavaScript
*** Mode
    The ultimate JS mode

    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :ensure t
        :interpreter (("node" . js2-mode))
        :mode (("\\.\\(js\\|json\\)$" . js2-mode))
        :defer t
        :config
        (add-hook 'js-mode-hook 'js2-minor-mode)
        (setq js2-highlight-level 3
              js2-mode-show-parse-errors nil
              js2-mode-show-strict-warnings nil))

      (use-package js-doc
        :ensure t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook
                  #'(lambda ()
                      (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                      (define-key js2-mode-map "@" 'js-doc-insert-tag)))


        (setq js-doc-mail-address user-mail-address
              js-doc-author (format "I am <%s>" js-doc-mail-address)
              js-doc-url "francismurillo.github.io"
              js-doc-license "GPL"))
    #+END_SRC

*** Refactor

    #+BEGIN_SRC emacs-lisp
      (use-package js2-refactor
        :diminish js2-refactor-mode
        :ensure t
        :defer t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook #'js2-refactor-mode)
        :config
        (js2r-add-keybindings-with-prefix "C-c C-m"))
    #+END_SRC

*** Autocomplete
    A must have for Javascript development

    #+BEGIN_SRC emacs-lisp
      (use-package tern
        :ensure t
        :defer t
        :diminish tern-mode
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook 'tern-mode))

      (use-package company-tern
        :ensure t
        :after (tern company)
        :config
        (add-to-list 'company-backends 'company-tern))
    #+END_SRC

*** Formatter
    Formatter for js

    #+BEGIN_SRC emacs-lisp
      (use-package web-beautify
        :ensure t
        :after js2-mode
        :bind (("C-c C-b" . web-beautify-js)))

    #+END_SRC

*** Snippets
    Snippet support

    #+BEGIN_SRC emacs-lisp
      (use-package react-snippets
        :ensure t
        :after (js2 yasnippet))
    #+END_SRC
*** REPL
    Got to have those REPLs

    #+BEGIN_SRC emacs-lisp
      (use-package nodejs-repl
        :ensure t
        :bind (("C-c C-n C-c" . nodejs-repl-send-buffer)
               ("C-c C-n C-r" . nodejs-repl-send-region)
               ("C-c C-n C-e" . nodejs-repl-send-last-sexp))
        :after js2-mode)

      (use-package skewer-mode
        :defer t
        :diminish skewer-mode
        :bind (("C-c K" . run-skewer))
        :ensure t
        :init
        (add-hook 'js2-mode-hook 'skewer-mode)
        (add-hook 'css-mode-hook 'skewer-css-mode)
        (add-hook 'html-mode-hook 'skewer-html-mode))
    #+END_SRC

*** Prettify
    My symbols for JS

    #+BEGIN_SRC emacs-lisp
      (when fn/enable-prettify-symbols
        (add-hook 'js2-mode-hook
                  (lambda ()
                    (push '("function" . ?Î») prettify-symbols-alist)
                    (push '("arguments" . ?Ï‰) prettify-symbols-alist)
                    (push '("var" . ?Î½) prettify-symbols-alist)
                    (push '("return" . ?Ï) prettify-symbols-alist)
                    (push '("this" . ?Î¹) prettify-symbols-alist)

                    (push '("for" . ?âˆ«) prettify-symbols-alist)
                    (push '("in" . ?âŠ‚ ) prettify-symbols-alist)

                    (push '("Object" . ?Î˜) prettify-symbols-alist)

                    (push '("if" . ?Î±) prettify-symbols-alist)
                    (push '("else if" . ?Î²) prettify-symbols-alist)
                    (push '("else" . ?Î³) prettify-symbols-alist)

                    (push '("->" . ?â†’) prettify-symbols-alist)
                    (push '("&&" . ?âˆ§) prettify-symbols-alist)
                    (push '("||" . ?âˆ¨) prettify-symbols-alist)

                    (push '("!" . ?Â¬) prettify-symbols-alist)
                    (push '("!!" . ?âŒ) prettify-symbols-alist)

                    (push '("=" . ?âŸµ) prettify-symbols-alist)
                    (push '(":" . ?âŸµ) prettify-symbols-alist)

                    (push '("===" . ?â‰¡) prettify-symbols-alist)
                    (push '("!==" . ?â‰¢) prettify-symbols-alist)

                    (push '(">=" . ?â‰§) prettify-symbols-alist)
                    (push '("<=" . ?â‰¦) prettify-symbols-alist)

                    (push '("true" . ?âŠ¤) prettify-symbols-alist)
                    (push '("false" . ?âŠ¥) prettify-symbols-alist)

                    (push '("null" . ?âˆ…) prettify-symbols-alist)
                    (push '("undefined" . ?â†‘) prettify-symbols-alist)

                    (push '(", ". ?âŸ¼) prettify-symbols-alist)
                    (push '("{". ?âŸ¹) prettify-symbols-alist)
                    (push '("},". ?âŸº) prettify-symbols-alist)
                    (push '("}". ?âŸ¸) prettify-symbols-alist)
                    (push '("};". ?âŸ½) prettify-symbols-alist)

                    (push '("(". ?âŸ–) prettify-symbols-alist)
                    (push '(")". ?âŸ•) prettify-symbols-alist)
                    (push '(");". ?âŸ•) prettify-symbols-alist)
                    (push '("),". ?âŸ—) prettify-symbols-alist)
                    (push '(").". ?âŸ—) prettify-symbols-alist)

                    (push '("[". ?âŠ) prettify-symbols-alist)
                    (push '("]". ?âŠ) prettify-symbols-alist)
                    (push '("],". ?âŠ¡) prettify-symbols-alist)
                    (push '("].". ?âŠ¡) prettify-symbols-alist)
                    (push '("];". ?âŠ) prettify-symbols-alist)

                    (push '(";". ?âŸ) prettify-symbols-alist)

                    (prettify-symbols-mode t))))
    #+END_SRC
*** JSON
    JSON support

    #+BEGIN_SRC emacs-lisp
      (use-package json-snatcher
        :ensure t
        :after js2-mode
        :bind (("C-c C-g" . jsons-print-path)))
    #+END_SRC

** Python
*** python
    My favorite programming language, unassuming like Marcy from Peanuts

    #+BEGIN_SRC emacs-lisp
      (use-package python
        :defer t
        :ensure t)
    #+END_SRC

    Some basic python requirements

    #+BEGIN_SRC emacs-lisp
      (use-package py-autopep8
        :ensure t
        :defer t)

      (use-package ein
        :ensure t
        :defer t
        :config
        (setq ein:use-auto-complete t)
        (setq ein:use-smartrep t))
    #+END_SRC

*** elpy
    Making Python an IDE

    #+BEGIN_SRC emacs-lisp
      (use-package elpy
        :ensure t
        :defer t
        :init
        (add-hook 'python-mode-hook 'elpy-enable)

        (add-hook 'elpy-mode-hook 'flycheck-mode)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
        :config
        (setq elpy-python-command "python3")
        (setq elpy-rpc-python-command "python3")
        (setq elpy-rpc-backend "jedi")
        (setq elpy-interactive-python-command "ipython")
        (elpy-use-ipython)

        (setq elpy-modules (delq 'elpy-module-flycheck elpy-modules))

        (require 'py-autopep8)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
    #+END_SRC

*** jedi
    The newer Python IDE, [[https://github.com/davidhalter/jedi][Jedi]], much easier to grok.

    This requires [[https://pypi.python.org/pypi/pip/][pip]] and the packages  [[https://pypi.python.org/pypi/virtualenv][virtualenv]]. The snippet below is for the hard dependency. Let =jedi:install-server= do the work

    #+BEGIN_SRC sh
      curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

      python get-pip.py

      pip install virtualenv
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package jedi
        :ensure t
        :defer t
        :init
        (add-hook 'python-mode-hook 'jedi:setup)
        (add-hook 'python-mode-hook 'jedi:ac-setup)
        :config
        (jedi:install-server)

        (define-key jedi-mode-map (kbd "M-.") 'jedi:goto-definition)
        (define-key jedi-mode-map (kbd "M-,") 'jedi:goto-definition-pop-marker)
        (define-key jedi-mode-map (kbd "C-M-?") 'jedi:show-doc)
        (define-key jedi-mode-map (kbd "C-M-/") 'jedi:get-in-function-call)

        (setq elpy-rpc-backend "jedi")
        (add-to-list 'ac-sources 'ac-source-jedi-direct)
        (setq jedi:complete-on-dot t))
    #+END_SRC

** Haskell
*** Mode
    The defacto for Haskell development

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :ensure t
        :defer t
        :init
        (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
        (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
        (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
        :config
        (require 'haskell-interactive-mode)
        (require 'haskell-process)
        ;; Reset mapping as it does more damage than good
        (setq haskell-cabal-mode-map (make-keymap)
              interactive-haskell-mode-map (make-keymap))

        (define-key haskell-mode-map (kbd "<f8>") 'haskell-navigate-imports)

        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile)
        (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile)

        ;; Haskell bindings
        (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
        (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
        (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
        (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Cabal bindings
        ;; (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Interactive Haskell
        (define-key interactive-haskell-mode-map (kbd "C-c M-.") 'haskell-mode-goto-loc)
        (define-key interactive-haskell-mode-map (kbd "C-c M-t") 'haskell-mode-show-type-at)

        (setq haskell-stylish-on-save t)

        (setq interactive-haskell-mode t)

        (setq haskell-process-suggest-remove-import-lines t
              haskell-process-auto-import-loaded-modules t
              haskell-process-log t
              haskell-process-suggest-hoogle-imports t
              haskell-interactive-mode-eval-mode 'haskell-mode))
    #+END_SRC

*** Motion
    The paredit for haskell

    #+BEGIN_SRC emacs-lisp
      (use-package shm
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook 'structured-haskell-mode)
        :config
        ;; (define-key shm-map  "\C-j" 'shm/newline-indent)
        (define-key shm-map  "\M-a" 'shm/goto-parent)
        (define-key shm-map  "\M-e" 'shm/goto-parent-end)
        ;; (define-key shm-map  "\C-+" 'shm/add-operand)
        (define-key shm-map  "\M-r" 'shm/raise)
        (define-key shm-map  "\M-^" 'shm/delete-indentation)
        (define-key shm-map  "\M-k" 'shm/kill)
        (define-key shm-map  "\C-y" 'shm/yank)
        (define-key shm-map  "\M-k" 'shm/kill-line)
        (define-key shm-map (kbd "C-c C-s") 'shm/case-split))
    #+END_SRC

*** Autocomplete
    Company for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package company-ghc
        :ensure t
        :after (company haskell-mode)
        :config
        (add-to-list 'company-backends 'company-ghc))

      (use-package company-ghci
        :ensure t
        :after (company haskell-mode)
        :config
        (add-to-list 'company-backends 'company-ghci))

    #+END_SRC
*** Formatter
    Formatter for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package hindent
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook #'hindent-mode)
        :config
        (setq hindent-style "johan-tibell"))
    #+END_SRC

*** Linter
    Syntax checker for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-haskell
        :ensure t
        :after (flycheck haskell-mode)
        :init
        (add-hook 'haskell-mode-hook 'flycheck-mode)
        :config
        (flycheck-haskell-setup))
    #+END_SRC

***

*** Prettify
    My symbols for Haskell

    #+BEGIN_SRC emacs-lisp
      (when fn/enable-prettify-symbols
        (add-hook 'haskell-mode-hook
                  (lambda ()
                    (push '("->" . ?â†’) prettify-symbols-alist)
                    (push '("let" . ?Î½) prettify-symbols-alist)
                    (push '("if" . ?Î±) prettify-symbols-alist)
                    (push '("in" . ?Îµ) prettify-symbols-alist)
                    (push '("then" . ?Ïƒ) prettify-symbols-alist)
                    (push '("else" . ?Ï„) prettify-symbols-alist)
                    (push '("where" . ?Î´) prettify-symbols-alist)
                    (push '("module" . ?Î¸) prettify-symbols-alist)
                    (push '("data" . ?Î¤) prettify-symbols-alist)
                    (push '("deriving" . ?Î”) prettify-symbols-alist)
                    (prettify-symbols-mode t))))

    #+END_SRC
*** Build Tools
    Maybe stack or hack?
** dotNet
*** omnisharp
    For C# development

    #+BEGIN_SRC emacs-lisp
      (use-package omnisharp
        :ensure t
        :defer t
        :init
        (add-hook 'csharp-mode-hook 'omnisharp-mode)
        :config
        (setq omnisharp-root-dir
              (expand-file-name "~/Fakespace/omnisharp-server"))
        (setq omnisharp-server-executable-path
              (expand-file-name "OmniSharp/bin/Debug/" omnisharp-root-dir)))
    #+END_SRC

** LaTeX
   LaTeX editing for my files


   #+BEGIN_SRC emacs-lisp
     (use-package auctex
       :ensure t
       :defer t
       :init
       (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
       (add-hook 'latex-mode-hook 'turn-on-reftex)
       (setq reftex-plug-into-AUCTex t))

     (use-package company-auctex
       :ensure t
       :after auctex
       :config
       (company-auctex-init))

     (use-package auctex-latexmk
       :ensure t
       :after auctex)
   #+END_SRC

*** haskell-snippets
    Easy snippets for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-snippets
        :ensure t
        :after (yasnippet haskell-mode)
        :config
        (require 'haskell-snippets))
    #+END_SRC
* Random Was Alone
  Anything that just does something useful

** twittering
    Integrating with emacs is very fun via [[https://github.com/hayamiz/twittering-mode][twittering]]

    #+BEGIN_SRC emacs-lisp
      (use-package twittering-mode
        :ensure t
        :defer t
        :init
        (setq twittering-auth-method 'oauth)
        (setq twittering-use-master-password t)
        :config
        (twittering-icon-mode t)
        (setq twittering-convert-fix-size 24))
    #+END_SRC

** engine
    Instant search with Emacs, sign me up.

    #+BEGIN_SRC emacs-lisp
      (use-package engine-mode
        :ensure t
        :config
        (engine-mode t)

        (engine/set-keymap-prefix (kbd "C-c s"))
        (setq engine/browser-function 'browse-url-firefox)

        (defengine amazon
          "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")

        (defengine duckduckgo
          "https://duckduckgo.com/?q=%s"
          :keybinding "d")

        (defengine emacsgo
          "https://duckduckgo.com/?q=emacs+%s"
          :keybinding "e")

        (defengine github
          "https://github.com/search?ref=simplesearch&q=%s"
          :keybinding "g")

        (defengine project-gutenberg
          "http://www.gutenberg.org/ebooks/search/?query=%s")

        (defengine rfcs
          "http://pretty-rfc.herokuapp.com/search?q=%s")

        (defengine stack-overflow
          "https://stackoverflow.com/search?q=%s"
          :keybinding "t")

        (defengine twitter
          "https://twitter.com/search?q=%s")

        (defengine wikipedia
          "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
          :keybinding "w"
          :docstring "Searchin' the wikis.")

        (defengine wiktionary
          "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

        (defengine wolfram-alpha
          "http://www.wolframalpha.com/input/?i=%s")

        (defengine youtube
          "http://www.youtube.com/results?aq=f&oq=&search_query=%s"))
    #+END_SRC

** bbdb
    People organization

    #+BEGIN_SRC emacs-lisp
      (use-package bbdb
        :ensure t
        :defer t
        :config
        (bbdb-initialize)
        (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))
    #+END_SRC

** emms
   This controls the music player.

   #+BEGIN_SRC emacs-lisp
     (use-package emms
       :ensure t
       :defer t
       :config
       (emms-standard)
       (emms-default-players)

       (setq emms-source-file-default-directory "~/Music/")

       (setq emms-info-asynchronously nil
             emms-playlist-buffer-name "*Music*")

       (setq emms-playlist-default-major-mode 'emms-playlist-mode)

       ;; emms-mark
       (require 'emms-mark)

       ;; emms-history
       (require 'emms-history)
       (emms-history-load)

       ;; emms-mode-line
       (require 'emms-mode-line)
       (emms-mode-line 1)

       (require 'emms-playing-time)
       (emms-playing-time 1)

       ;; emms-browser
       (require 'emms-browser)

       ;; emms-volume
       (emms-volume-minor-mode t)

       (setq emms-volume-mode-timeout 1)

       (define-key emms-volume-minor-mode-map (kbd "C-c -") 'emms-volume-minus)
       (define-key emms-volume-minor-mode-map (kbd "C-c +") 'emms-volume-plus))
   #+END_SRC

* Scripts
** Custom Emacs
   Bootstrap different configurations of Emacs for reviewing expert
   configurations and trying different modes

*** Configurable
    Let's bootstrap from different configurations dynamically

    #+BEGIN_SRC emacs-lisp
      (defun fn/bootstrap-from-dir ()
        (interactive)
        (setq new-home (read-directory-name "What Emacs config would you like to boot?" "~"))
        (fn/bootstrap-new-emacs new-home))
    #+END_SRC

*** Itself
    Load another copy of this configuration for vanity sake I suppose?

    #+BEGIN_SRC emacs-lisp
      (defun fn/bootstrap-itself ()
        (interactive)
        (fn/bootstrap-new-emacs nil))
    #+END_SRC

*** Experimental
    Just a random build for myself

    #+BEGIN_SRC emacs-lisp
      (setq fn/experimental-home "~/.fmacs.d/")

      (defun fn/bootstrap-experimental ()
        (interactive)
        (fn/bootstrap-new-emacs fn/experimental-home))
    #+END_SRC

*** Spacemacs
    The love child of Emacs and Vim, what does it hold?

    #+BEGIN_SRC emacs-lisp
      (setq fn/spacemacs-home "~/.spacemacs.d/")

      (defun fn/bootstrap-spacemacs ()
        (interactive)
        (fn/bootstrap-new-emacs fn/spacemacs-home))
    #+END_SRC

*** Zak Elep
    First known master and friend

    #+BEGIN_SRC emacs-lisp
      (setq fn/zak-elep-home "~/Fakespace/zakame.d/")

      (defun fn/bootstrap-zak-elep ()
        (interactive)
        (fn/bootstrap-new-emacs fn/zak-elep-home))
    #+END_SRC

*** Sacha Chua
    Inspiration for the configuration

    #+BEGIN_SRC emacs-lisp
      (setq fn/sacha-chua-home "~/Fakespace/sacha.d/")

      (defun fn/bootstrap-sacha-chua  ()
        (interactive)
        (fn/bootstrap-new-emacs fn/sacha-chua-home))
    #+END_SRC

*** Steve Purcell
    One of the known masters

    #+BEGIN_SRC emacs-lisp
      (setq fn/steve-purcell-home "~/Fakespace/purcell.d/")

      (defun fn/bootstrap-steve-purcell ()
        (interactive)
        (fn/bootstrap-new-emacs fn/steve-purcell-home))
    #+END_SRC

*** John Wiegley
    A master and maintainer of Emacs

    #+BEGIN_SRC emacs-lisp
      (setq fn/john-wiegley-home "~/Fakespace/wiegley.d/")

      (defun fn/bootstrap-john-wiegley ()
        (interactive)
        (fn/bootstrap-new-emacs fn/john-wiegley-home))
    #+END_SRC

** starup and shutdown hook
   Small script to update my org files

   #+BEGIN_SRC emacs-lisp
     (defun fn/startup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library && git pull origin master"))

     (defun fn/cleanup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library\
      && git add diary/*\
      && git commit -a -m \"Home Update\"\
      && git push origin master"))

     (define-key global-map "\C-cms" 'fn/startup)
     (define-key global-map "\C-cmc"'fn/cleanup)
   #+END_SRC

** projectile-init script
   This script runs .projectile-hook.el in each project root to ease development

   #+BEGIN_SRC emacs-lisp
     (defun fn/load-projectile-hook ()
       (interactive)
       (mapcar (lambda (project)
        (setq fn/current-project (expand-file-name project))
        (load
         (expand-file-name ".projectile-hook" fn/current-project)
         t))
 projectile-known-projects))
   #+END_SRC

** Create media diary
   A personal script to bundle my journal, recordings and images into one org file. Not to be consumed by anyone else

   #+BEGIN_SRC emacs-lisp
     (defun fn/compile-media-diary ()
       (interactive)
       (setq md-root "/media/veracrypt1/media-diary"
             md-file "media-diary.org"
             md-prefix (read-input "Input year-month[yyyy-mm]:" "2016-04")

             md-journal-dir-name "journal"
             md-audio-dir-name "audio"
             md-photo-dir-name "photo"

             md-journal-dir (expand-file-name md-journal-dir-name md-root)
             md-audio-dir (expand-file-name md-audio-dir-name md-root)
             md-photo-dir (expand-file-name md-photo-dir-name md-root)

             md-title "Media Diary"
             md-note-title "Notes"
             md-journal-title "Journal"
             md-media-title "Media"

             md-note-text "Something profound happened to me but I forgot"

             md-journal-time-format "%b. %d, %Y"
             md-audio-time-format "%b. %d, %Y %T - Recording"
             md-photo-time-format "%b. %d, %Y %T - Photograph")

       (defun replace-in-string (what with in)
         (replace-regexp-in-string (regexp-quote what) with in nil 'literal))

       (defun directory-files-by-extension (directory extension) ;; NOTE: md-prefix tangled here
         (directory-files directory nil
                          (format-message "%s-.*\\.%s$" md-prefix extension)))

       (defun parse-date-from-filename (file)
         (setq filename
               (file-name-sans-extension (file-name-nondirectory file)))
         (apply 'encode-time
                (parse-time-string (concat filename " " "00:00:00"))))


       (defun parse-time-from-filename (file)
         (setq filename
               (file-name-sans-extension (file-name-nondirectory file))
               date-time (split-string filename "_")
               date-text (car date-time)
               time-text (replace-in-string "-" ":" (car (cdr date-time)))
               date-time-text (concat date-text " " time-text))

         (apply 'encode-time
                (parse-time-string date-time-text)))

       (defun insert-org-header (header)
         (org-insert-heading t nil t)
         (insert header))

       (defun insert-org-subheader (subheader)
         (end-of-buffer)
         (org-insert-heading t nil t)
         (insert subheader)
         (org-demote))

       (defun insert-org-link (link title)
         (end-of-buffer)
         (org-insert-heading t)
         (org-insert-link nil link title))

       (defun once (f)
         (lexical-let ((g f)
                       (is-invoked nil))
           (lambda ()
             (if is-invoked nil
               (progn
                 (setq is-invoked t)
                 (funcall g))))))

       (defun insert-file-headers ()
         (insert "# -*- epa-file-encrypt-to: (\"fnmurillo@yandex.com\"); -*-\n")
         (insert "# -*- backup-inhibited: t; auto-save-default: nil; -*-\n")

         (insert "#+STARTUP: content\n")
         (insert "#+OPTIONS: toc:nil\n"))

       (defun render-header ()
         (insert-org-header md-title))

       (defun render-note-section ()
         (insert-org-subheader md-note-title)
         (newline-and-indent)
         (insert md-note-text))

       (defun render-journal-section ()
         (insert-org-subheader md-journal-title)
         (setq journal-files
               (directory-files-by-extension md-journal-dir "org"))

         (setq value nil
               demote-first (once (lambda () (org-demote))))

         (dolist (journal-file journal-files value)
           (progn
             (setq journal-time (parse-date-from-filename journal-file)
                   journal-title
                   (format-time-string md-journal-time-format journal-time))

             (insert-org-link
              (concat "file:" md-journal-dir-name "/" journal-file)
              journal-title)
             (funcall demote-first)
             (org-set-property "CREATED_ON"
                               (format-time-string "%F %T" journal-time)))))

       (defun render-media-section ()
         (insert-org-subheader md-media-title)
         (setq photo-files
               (directory-files-by-extension md-photo-dir "jpg")
               audio-files
               (directory-files-by-extension md-audio-dir "wav")
               media-files
               (sort (append photo-files audio-files)
                     (lambda (left right)
                       (progn
                         (setq result
                               (compare-strings
                                (file-name-sans-extension left) nil nil
                                (file-name-sans-extension right) nil nil
                                nil))
                         (if (booleanp result) t
                           (if (> result 0) nil t))))))

         (setq value nil
               demote-first (once (lambda () (org-demote))))

         (intern-soft "photo")
         (intern-soft "audio")

         (dolist (media-file media-files values)
           (progn
             (setq media-time (parse-time-from-filename media-file)
                   media-type
                   (if (string-equal (file-name-extension media-file) "wav")
                       'audio 'photo)
                   media-time-format
                   (if (eq media-type 'audio) md-audio-time-format md-photo-time-format)
                   media-dir-name
                   (if (eq media-type 'audio) md-audio-dir-name md-photo-dir-name)
                   media-title (format-time-string media-time-format media-time))

             (insert-org-link
              (concat "file:" media-dir-name "/" media-file)
              media-title)
             (funcall demote-first)
             (org-set-property "CREATED_ON"
                               (format-time-string "%F %T" media-time)))))

       (find-file
        (expand-file-name md-file md-root))

       (insert-file-headers)
       (render-header)
       (render-note-section)
       (render-journal-section)
       (render-media-section)

       (beginning-of-buffer)
       (org-set-startup-visibility))

     (defun fn/rename-link ()
       (interactive)
       (setq org-element (org-element-context)
             org-path (org-element-property :raw-link org-element)
             org-link (org-element-property :path org-element))
       (org-insert-link nil org-path nil))
   #+END_SRC

** Open standard buffers
   Nice to see the standard buffers

   #+BEGIN_SRC emacs-lisp
     (defun fn/open-message-buffer ()
       (interactive)
       (switch-to-buffer "*Messages*"))
   #+END_SRC

** Open config file
   This is just a convenience to open this config file

   #+BEGIN_SRC emacs-lisp
     (defun fn/find-config-file ()
       (interactive)
       (find-file (expand-file-name "config.org" user-emacs-directory)))
   #+END_SRC
** Four way layout
   Split the windows into a nice four panel division. This works even
   well with [[golden-ratio]].

   #+BEGIN_SRC emacs-lisp
     (defun fn/four-way-horizontal-window-layout ()
       (interactive)
       (delete-other-windows)
       (split-window-vertically)
       (split-window-horizontally)
       (other-window 2)
       (split-window-horizontally)
       (other-window 2))

     (defun fn/four-way-vertical-window-layout ()
       (interactive)
       (split-window-vertically)
       (delete-other-windows)
       (split-window-horizontally)
       (other-window 2)
       (split-window-vertically)
       (other-window 2))
   #+END_SRC

* My Bindings
  Here is where all the key binding I mapped to

  #+BEGIN_SRC emacs-lisp
    ;; Application
    (define-key global-map (kbd  "C-c x") 'helm-M-x)

    ;; Buffers
    (define-key global-map (kbd  "C-c n k") 'kill-this-buffer)

    ;; Windows
    (define-key global-map (kbd "C-c m w h") 'fn/four-way-horizontal-window-layout)
    (define-key global-map (kbd "C-c m w v") 'fn/four-way-vertical-window-layout)

    ;; System Buffers
    (define-key global-map (kbd "C-c m b m") 'fn/open-message-buffer)

    ;; Shell
    (define-key global-map (kbd "C-c n s") 'shell)

    ;; Files
    (define-key global-map (kbd "C-c m b c") 'fn/find-config-file)
    (define-key global-map (kbd "C-c m b o") 'fn/find-main-org-file)

    ;; Functions
    (define-key global-map (kbd  "C-c m r s") 'fn/startup)
    (define-key global-map (kbd  "C-c m r c") 'fn/cleanup)

    ;; Custom Emacs
    (define-key global-map (kbd  "C-c m e e") 'fn/bootstrap-experimental)
    (define-key global-map (kbd  "C-c m e s") 'fn/bootstrap-spacemacs)
    (define-key global-map (kbd  "C-c m e f") 'fn/bootstrap-from-dir)

    ;; Review Custom Emacs
    (define-key global-map (kbd  "C-c m e p") 'fn/bootstrap-steve-purcell)
    (define-key global-map (kbd  "C-c m e z") 'fn/bootstrap-zak-elep)
    (define-key global-map (kbd  "C-c m e c") 'fn/bootstrap-sacha-chua)
    (define-key global-map (kbd  "C-c m e j") 'fn/bootstrap-john-wiegley)
  #+END_SRC

* Sandbox

  #+BEGIN_SRC emacs-lisp

  #+END_SRC
* Reference
  - [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha Chua]]: I took her configuration as a base to make this org configuration
  - [[https://github.com/zakame/.emacs.d][Zak Elep]]: One of the master and first known ally.
