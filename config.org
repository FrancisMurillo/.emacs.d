#+TITLE: Francis Murillo's Emacs configuration
#+AUTHOR: Francis Murillo
#+OPTIONS: toc:4 h:4
* Introduction
** If I Forget
   No words can describe my awe with Emacs and continue to do so. A text
   editor with a lisp interpreter, it's concept is so simple and
   sublime. What joy.

   I remember starting Emacs seriously at around August of 2015. Before
   then, I picked it up lightly and thought(not use) about it; but what
   really drove me to use it is.

   - Growth ::
   I was using an IDE before and somebody told me that GUIs change but
   the shell remains the same. I found myself over time exploring
   keyboard shortcuts, better terminals and Emacs(or maybe vi).
   - Lightweight ::
   I had a crappy laptop that always needed to be plugged, had a lot
   dead pixels, and closes when it overheats; I needed something that
   would work with what I had.
   - Linux ::
   Moving from Windows to Linux forced me to reevaluate the software I
   used. Adopting a new philosophy and OS pushed me in the right direction

   Whatever the reason might have been. I just want to say I'm a happy
   Emacs user and I find comfort and joy in hearing other people talk
   and share about it.

** About My Configuration
   I use org-babel as my configuration file once I heard you can do so.
   Splitting the configuration to multiple files was the plan but the
   way it weaves nicely to documentation immediately drew me in.

   You can load this with =(org-babel-load-file "/path/to/file")= if you
   need to reload any changes or just take any snippet you want. I do my
   best to make my configuration copy friendly on different environments.

   Or with an function instead

   #+BEGIN_SRC emacs-lisp
     (defun fn/reload-config ()
       "Reload my configuration again"
       (interactive)
       (org-babel-load-file
        (expand-file-name fn/config-file user-emacs-directory)))
   #+END_SRC

* Bootstrap
** Lexical Binding
   This makes it so that the file that is produced from tangling this
   file uses lexical scoping and all succeeding files

   #+BEGIN_SRC emacs-lisp
     (setq lexical-binding t)
   #+END_SRC

** Package Sources
   Add package sources if not present and reload, this should have been added in the =init.el= but checked here again for completion.

   #+BEGIN_SRC emacs-lisp
     (defconst fn/package-archives (list
                                    (cons "gnu" "http://elpa.gnu.org/packages/")
                                    (cons "org" "http://orgmode.org/elpa/")
                                    (cons "melpa" "http://melpa.org/packages/")
                                    (cons "melpa-stable" "https://stable.melpa.org/packages/"))
       "List of my packages")

     (mapc (lambda (package-archive)
             (pcase-let ((`(,name . ,_) package-archive))
               (unless (assoc-default name package-archives)
                 (add-to-list 'package-archives package-archive))))
           fn/package-archives)

   #+END_SRC

** Package Manager
   The package manager of this whole configuration

   #+BEGIN_SRC emacs-lisp
     (require 'use-package)

     (setq use-package-verbose t)
   #+END_SRC

** Org Src
   Configuration for using the tangling nature of this configuration

   #+BEGIN_SRC emacs-lisp
     (setq org-src-tab-acts-natively t)
   #+END_SRC

** Constants
   Some constants to work with

   #+BEGIN_SRC emacs-lisp
     (defconst fn/minute-per-second 60
       "Obviously converting minutes to seconds")

     (defconst fn/cache-dir-name ".cache"
       "Place every moving file in this directory")

     (defconst fn/cache-dir (expand-file-name fn/cache-dir-name user-emacs-directory)
       "Every cached or moving file should be here like with Spacemacs")


     (defconst fn/extra-dir-name "extra"
       "Anything under the sun you can put here")

     (defconst fn/extra-dir (expand-file-name fn/extra-dir-name user-emacs-directory)
       "Anything under the sun directory")


     (defconst fn/custom-package-dir-name "elisp"
       "Custom elisp packages directory name")

     (defconst fn/custom-package-dir (expand-file-name fn/custom-package-dir-name user-emacs-directory)
       "Custom elisp packages directory")
   #+END_SRC

* Basic Setup
  Basic configurations anyone can do for vanilla Emacs

** Personal Information
   Just some things that relate to me

   #+BEGIN_SRC emacs-lisp
     (defconst fn/personal-file-name "personal.el"
       "Personal configuration file name")

     (defconst fn/personal-file (expand-file-name fn/personal-file-name user-emacs-directory)
       "Personal configuration file to be loaded")

     (load fn/personal-file t)
   #+END_SRC

** Customization
   Basis for configuration

   #+BEGIN_SRC emacs-lisp
     (defgroup fn nil
       "My namespace for customizing my configuration")

   #+END_SRC

** Startup
   Everything related to the startup state

   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold (* 128 1024 1024)) ;; High memory for Emacs

     (setq inhibit-startup-screen t ;; No need for the awesome startup screen.
           initial-scratch-message nil)
   #+END_SRC

** Environment
   Some environment configuration.

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8") ;; UTF-8 should be the enivorment

     (setq visible-bell t) ;; Visual bell for me since audio is a bit more distractive

     (fset 'yes-or-no-p 'y-or-n-p) ;; Y or N
   #+END_SRC

** Backups
   Backups are good, just annoying when things are good

   #+BEGIN_SRC emacs-lisp
     (defconst fn/backup-dir-name "backups"
       "Backup directory name")

     (defconst fn/backup-dir (expand-file-name fn/backup-dir-name fn/cache-dir)
       "Backup directory")


     (defconst fn/auto-save-dir-name "auto-save-list"
       "Auto save directory name")

     (defconst fn/auto-save-dir (expand-file-name fn/auto-save-dir-name fn/cache-dir)
       "Auto save directory")


     (setq auto-save-timeout 15
           auto-save-list-file-name fn/auto-save-dir

           delete-old-versions t
           version-control t
           vc-make-backup-files t
           backup-by-copying t
           kept-new-versions 10
           kept-old-versions 50

           backup-directory-alist (list
                                   (cons "." fn/backup-dir))

           auto-save-file-name-transforms (list
                                           (list ".*" fn/auto-save-dir t)))
   #+END_SRC

** History
   Save minibuffer history

   #+BEGIN_SRC emacs-lisp
     (defconst fn/savehist-file-name "savehist"
       "Save history file name")

     (defconst fn/savehist-file (expand-file-name fn/savehist-file-name fn/cache-dir)
       "Save history file")


     (setq savehist-file fn/savehist-file

           history-length t
           history-delete-duplicates t

           savehist-save-minibuffer-history t
           savehist-additional-variables (list 'kill-ring
                                               'search-ring
                                               'regexp-search-ring))

     (savehist-mode t)


     (setq bookmark-file (expand-file-name "bookmarks" fn/cache-dir)
           bookmark-default-file (expand-file-name "bookmarks-default" fn/cache-dir))


   #+END_SRC

** Editing
   Some editing configurations

   #+BEGIN_SRC emacs-lisp
     (setq whitespace-line-column 10000 ;; No line too long font locking please

           ;; C-M-a should go to the beginning of a sentence
           sentence-end-double-space nil

           require-final-newline t)

     ;; I like tabs but they should just be converted to spaces for equality
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Search
   You must have this setup, it's like butter and you're the bread.

   #+BEGIN_SRC emacs-lisp
     (defconst fn/default-search-whitespace-regexp search-whitespace-regexp
       "Store the default whitespace option")

     (setq search-highlight t)

     ;; This ignores whitespace when searching
     (setq-default search-whitespace-regexp".*?")


     (defun fn/isearch-forward-normally ()
       "This custom command does i-search without the whitespace skips,
        the vanilla behavior"
       (interactive)
       (let ((search-whitespace-regexp fn/default-search-whitespace-regexp))
         (isearch-forward)))


     (defun fn/isearch-backward-normally ()
       "Ditto with fn/isearch-foward-normally except backwards."
       (interactive)
       (let ((search-whitespace-regexp fn/default-search-whitespace-regexp))
         (isearch-backward)))
   #+END_SRC

** Coding
   Some programming configuration that make sense

   #+BEGIN_SRC emacs-lisp
     ;; Please indent after newline to maintain sanity
     (global-set-key (kbd "RET") 'newline-and-indent)


     (make-variable-buffer-local
      (defvar fn/whitespace-cleanup-on-save t
        "When non-nil, delete trailing whitespace on save"))

     (add-to-list 'safe-local-variable-values '(fn/whitespace-cleanup-on-save))

     (defun fn/delete-trailing-whitespace-on-save ()
       (when fn/whitespace-cleanup-on-save
         (with-current-buffer (current-buffer)
           (message "Deleting trailing whitespace in %s" (current-buffer))
           (delete-trailing-whitespace (point-min) (point-max)))))

     (add-hook 'before-save-hook #'fn/delete-trailing-whitespace-on-save)


     (temp-buffer-resize-mode t)

     (setq compilation-window-height 10
           compilation-scroll-output 'first-error
           compilation-ask-about-save nil)
   #+END_SRC

** Mouse
   I better be a cat

   #+BEGIN_SRC emacs-lisp
     (mouse-avoidance-mode 'cat-and-mouse)
   #+END_SRC

** Commands
   Unlock some commands I need

   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

* Dependencies
  Everything needed to support this more complex configurations

** async
   Not really builtin but should be

   #+BEGIN_SRC emacs-lisp
     (use-package async
       :ensure t)
   #+END_SRC

** s
   A string library, everyone needs that

   #+BEGIN_SRC emacs-lisp
     (use-package s
       :ensure t)
   #+END_SRC
** f
   File manipulation library for Emacs

   #+BEGIN_SRC emacs-lisp
     (use-package f
       :ensure t)
   #+END_SRC

** unicode-fonts
   Unicode is an required aesthetic

   #+BEGIN_SRC emacs-lisp
     (use-package pcache ;; Required by unicode-fonts
       :ensure t
       :init
       ;; Mentioned here to redirect directory
       (setq pcache-directory (expand-file-name "pcache/" fn/cache-dir)))

     (use-package unicode-fonts
       :ensure t
       :config
       (unicode-fonts-setup))
   #+END_SRC

** exec-path-from-shell
   The path variable from the shell is need to run commands

   #+BEGIN_SRC emacs-lisp
     (defconst fn/exec-path-from-shell-package-dir
       (expand-file-name "exec-path-from-shell/" fn/custom-package-dir)
       "Htmlize package dir")

     (use-package exec-path-from-shell
       :load-path fn/exec-path-from-shell-package-dir
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** execute-shell
   Some external commands might be required, so gotta check them if they
   exist or install them if you have the time

   #+BEGIN_SRC emacs-lisp
     (defun fn/run-command (command &rest args)
       ;; Calls the process *command* and gets it's output, nil if there is an error"
       (condition-case ex
           (with-temp-buffer
             (let ((string-args (mapcar (lambda (arg)
                                          (cond
                                           ((numberp arg) (number-to-string arg))
                                           (t arg)))
                                        args)))
               (apply 'call-process (append
                                     (list command nil t nil)
                                     string-args))
               (string-trim (buffer-string))))
         ('error nil)))

     (defun fn/check-command (command)
       ;; Another alias to *fn/run-command* but this time logs an output if the command does not exist
       (if (fn/run-command command)
           t
         (progn
           (message "Command *%s* is not available" command)
           nil)))
   #+END_SRC

** htmlize
   For exporting purposes

   #+BEGIN_SRC emacs-lisp
     (defconst fn/htmlize-package-dir (expand-file-name "htmlize-custom/" fn/custom-package-dir)
       "Htmlize package dir")

     (use-package htmlize
       :load-path fn/htmlize-package-dir
       :after ox-reveal)
   #+END_SRC

* Terminator
  Shell related aspect

** term
   An enhancement for =term=

   #+BEGIN_SRC emacs-lisp
     (use-package term
       :bind (("C-c n t" . ansi-term))
       :config
       (defadvice term-sentinel (around ansi-term-kill-buffer (proc msg))
         (if (memq (process-status proc) '(signal exit))
             (let ((buffer (process-buffer proc)))
               ad-do-it
               (kill-buffer buffer))
           ad-do-it))
       (ad-activate 'term-sentinel)

       ;; Set the term program and ask for a name
       (defadvice ansi-term (before ansi-term-force-shell)
         (interactive (list (getenv "SHELL")
                            (let ((term-name (string-trim (read-from-minibuffer "Name the term buffer: "))))
                              (if (string-empty-p term-name) nil term-name)))))
       (ad-activate 'ansi-term)


       (add-hook 'term-mode-hook 'goto-address-mode)
       (add-hook 'term-exec-hook
                 '(lambda ()
                    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
   #+END_SRC

** eshell
   Another enhancement for the shell

   #+BEGIN_SRC emacs-lisp
     (use-package eshell
       :bind (("C-c n e" . eshell))
       :config
       (setq eshell-directory-name (expand-file-name "eshell" fn/extra-dir))

       (defun fn/eshell-rename-buffer-before-command ()
         (let* ((last-input
                 (buffer-substring eshell-last-input-start eshell-last-input-end)))
           (rename-buffer
            (format "*eshell[%s]$ %s...*" default-directory last-input) t)))

       (defun fn/eshell-rename-buffer-after-command ()
         (rename-buffer
          (format "*eshell[%s]$ %s*" default-directory
                  (eshell-previous-input-string 0)) t))

       (add-hook 'eshell-pre-command-hook
                 'fn/eshell-rename-buffer-before-command)
       (add-hook 'eshell-post-command-hook
                 'fn/eshell-rename-buffer-after-command
                 )
       (use-package em-smart)

       (setq eshell-where-to-jump 'begin
             eshell-review-quick-commands nil
             eshell-smart-space-goes-to-end t)

       (add-hook 'eshell-mode-hook
                 (lambda ()
                   (eshell-smart-initialize))))
   #+END_SRC
** prodigy
   Living in the shell requires some genius

   #+BEGIN_SRC emacs-lisp
     (use-package prodigy
       :ensure t
       :defer t
       :bind (("C-c n q" . prodigy)))
   #+END_SRC
** emamux
   Work better with tmux

   #+BEGIN_SRC emacs-lisp
     (use-package emamux
       :ensure t
       :defer t)
   #+END_SRC

* Editor
  Anything to do with editing in Emacs

** Environment
*** guru
    Remember the Emacs's way to do things, but I think I'm good now. I
    only use it when I am one handed.

    #+BEGIN_SRC emacs-lisp
      (use-package guru-mode
        :ensure t
        :disabled t ;; Finally graduated from using the arrow keys
        :diminish guru-mode
        :config
        (guru-global-mode t))
    #+END_SRC

*** visual-line
    Visual lines make more sense than the hard lines, what you see is
    what you get. Besides, I use syntax motions

    #+BEGIN_SRC emacs-lisp
      (use-package visual-line
        :init
        (global-visual-line-mode t)
        (diminish 'visual-line-mode))
    #+END_SRC

*** auto-fill
    Useful mode when writing, keeps things under 80 characters.

    #+BEGIN_SRC emacs-lisp
      (use-package auto-fill
        :init
        (add-hook 'text-mode-hook 'turn-on-auto-fill)
        (diminish 'auto-fill-function)
        (setq-default fill-column 72))
    #+END_SRC

*** auto-revert
    The more generic revert

    #+BEGIN_SRC emacs-lisp
      (use-package auto-revert
        :diminish auto-revert-mode
        :init
        (global-auto-revert-mode t)
        (setq global-auto-revert-non-file-buffers t
              auto-revert-verbose nil))
    #+END_SRC

*** autorevert
    Enhancement for log reading

    #+BEGIN_SRC emacs-lisp
      (use-package autorevert
        :diminish auto-revert-mode
        :mode (("\\.log\\'" . auto-revert-tail-mode)));
    #+END_SRC

** Editing
*** hungry-delete
    Very useful default delete functionality

    #+BEGIN_SRC emacs-lisp
      (use-package hungry-delete
        :diminish hungry-delete-mode
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'hungry-delete-mode)
        (add-hook 'org-mode-hook 'hungry-delete-mode))
    #+END_SRC

*** aggressive-indent
    Maintaining indentation is awesome

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :ensure t
        :diminish aggressive-indent-mode
        :init
        (add-hook 'prog-mode-hook 'aggressive-indent-mode))
    #+END_SRC

*** expand-region
    Another great feature for marking

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :bind (("C-=" . er/expand-region)))
    #+END_SRC

*** multiple-cursors
    This functions does not get too much attention

    #+BEGIN_SRC emacs-lisp
      (use-package multiple-cursors
        :ensure t
        :bind (("C-S-c C-S-c" . mc/edit-lines)
               ("C->" . mc/mark-next-like-this)
               ("C-<" . mc/mark-previous-like-this)
               ("C-c C-<" . mc/mark-all-like-this)))
    #+END_SRC
*** undo-tree
    Visualizing undo like vi

    #+BEGIN_SRC emacs-lisp
      (use-package undo-tree
        :diminish undo-tree-mode
        :ensure t
        :config
        (global-undo-tree-mode 1))
    #+END_SRC

** Completion
*** hippie-exp
    Hippie expand rocks

    #+BEGIN_SRC emacs-lisp
      (use-package hippie-exp
        :config
        (global-set-key (kbd "M-/") 'hippie-expand)
        (setq hippie-expand-try-functions-list
              '(
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-complete-file-name-partially
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol)))
    #+END_SRC

*** company
    A replacement for =autocomplete=.

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :diminish company-mode
        :init
        (add-hook 'prog-mode-hook 'company-mode)
        :config
        (setq company-idle-delay 0.2
              company-minimum-prefix-length 4

              company-begin-commands (list 'self-insert-command))

        (setq company-show-numbers t
              company-tooltip-limit 20
              company-tooltip-align-annotations t)

        (setq company-dabbrev-time-limit 0.001
              company-dabbrev-code-time-limit 0.001)


        (setq company-backends (list))
        (add-to-list 'company-backends 'company-dabbrev)
        (add-to-list 'company-backends 'company-elisp)

        (defun fn/combine-backends (backend new-backend)
          (if (and (listp backend) (member new-backend backend))
              backend
            (let* ((list-backend (if (consp backend)
                                     backend
                                   (list backend)))
                   (with-backend (if (member ':with list-backend)
                                     list-backend
                                   (append list-backend '(:with)))))
              (append with-backend (list new-backend)))))

        (defun fn/append-to-backends (new-backend)
          (setq company-backends
                (mapcar
                 (lambda (backend)
                   (fn/combine-backends backend new-backend))
                 company-backends)))

        (setq fn/company-prog-backends '(company-dabbrev-code company-keywords))

        (defun fn/backend-with-prog ()
          (fn/append-to-backends 'company-keywords)
          (fn/append-to-backends 'company-dabbrev-code))

        (add-hook 'after-init-hook 'fn/backend-with-prog))
    #+END_SRC

*** yasnippet
    Snippet system along with autocomplete is awesome

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :ensure t
        :after company
        :defer t
        :diminish yas-minor-mode
        :bind (("C-c n y" . yas-new-snippet))
        :init
        (add-hook 'prog-mode-hook 'yas/minor-mode-on)
        :config
        (setq yas-verbosity 3
              yas-snippet-dirs (list (expand-file-name "snippets" fn/extra-dir)))

        (push 'yas-hippie-try-expand hippie-expand-try-functions-list)

        (yas-reload-all)

        (defun fn/add-company-yasnippet ()
          "Add yasnippet to company backends"
          (fn/append-to-backends 'company-yasnippet))

        (add-hook 'after-init-hook 'fn/add-company-yasnippet))
    #+END_SRC3
* Ergonomic
  Things to assist in managing Emacs

** Windows
   Anything related to window management

*** workgroups
    Saving window state is very helpful specially when you move a lots

    #+BEGIN_SRC emacs-lisp
      (use-package workgroups2
        :ensure t
        :bind (("C-c n w" . workgroups-mode))
        :init
        (setq wg-prefix-key (kbd "C-c w")
              wg-session-file (expand-file-name "workgroups" fn/cache-dir))

        (setq wg-morph-on nil)

        (setq wg-emacs-exit-save-behavior           'save
              wg-workgroups-mode-exit-save-behavior 'save)

        (setq wg-flag-modified nil)

        (setq wg-mode-line-display-on t
              wg-mode-line-decor-left-brace "["
              wg-mode-line-decor-right-brace "]"
              wg-mode-line-decor-divider ":"))
    #+END_SRC

*** winner
    You got to have those window configuration

    #+BEGIN_SRC emacs-lisp
      (use-package winner
        :ensure t
        :config
        (winner-mode t))
    #+END_SRC

*** window-numbering
    A must to navigate through windows with numbers.

    #+BEGIN_SRC emacs-lisp
      (use-package window-numbering
        :ensure t
        :config
        (window-numbering-mode t)

        (defun fn/tweak-window-numbering-faces ()
          (custom-set-faces
           '(window-numbering-face ((t (:foreground "tomato" :weight extra-bold))) t)))

        (fn/tweak-window-numbering-faces)

        (add-hook 'smart-mode-line-hook 'fn/tweak-window-numbering-faces))
    #+END_SRC

*** golden-ratio
    Makes windows large enough to see.

    #+BEGIN_SRC emacs-lisp
      (use-package golden-ratio
        :ensure t
        :after window-numbering
        :diminish golden-ratio-mode
        :bind (("C-c q" . golden-ratio)
               ("C-c n q" . golden-ratio-mode))
        :config
        (golden-ratio-mode t)

        (setq split-width-threshold nil
              golden-ratio-adjust-factor 1.0)

        ;; Until golden-ratio "advices" select-window, this is the unofficial fix
        (add-hook 'buffer-list-update-hook #'golden-ratio)
        (add-hook 'focus-in-hook #'golden-ratio)
        (add-hook 'focus-out-hook #'golden-ratio))
    #+END_SRC

*** uniquify
    Nicer naming convention

    #+BEGIN_SRC emacs-lisp
      (use-package uniquify
        :if (version<= emacs-version "24.3.1")
        :config
        (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
    #+END_SRC

** Buffers
   Anything related to buffers

*** recentf
    Accessing the files recently

    #+BEGIN_SRC emacs-lisp
      (use-package recentf
        :config
        (setq recentf-save-file (expand-file-name "recentf" fn/cache-dir)

              recentf-max-menu-items 100

              recentf-exclude '("TAGS" ".*-autoloads\\.el\\'"))

        (recentf-mode t)

        (global-set-key (kbd "C-x C-r") 'recentf-open-files))
    #+END_SRC

*** projectile
    Must have a project finder when using a project.

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :diminish projectile-mode
        :config
        (setq projectile-cache-file (expand-file-name "projectile.cache" fn/cache-dir)
              projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" fn/cache-dir))

        (defconst fn/project-file ".project.el"
          "Project configuration file")

        (defconst fn/project-local-file ".project-locals.el"
          "Project local setting file")

        (defconst fn/project-init-files (list fn/project-file fn/project-local-file)
          "Project init files")

        (defun fn/create-projectile-file ()
          (interactive)
          (lexical-let* ((target-dir  (read-directory-name "Where do you want to the .projectile placed?"))
                         (projectile-file-name ".projectile")
                         (projectile-file (expand-file-name projectile-file-name target-dir)))
            (cond
             ((file-exists-p projectile-file)
              (message "Projectile file alread exists"))
             (t
              (message "Creating %s" projectile-file)
              (find-file projectile-file)))))

        (defun fn/load-project-file ()
          ;; When the project is switched, run a custom initialization file.
          ;; Be careful though with side effects, make the init file fast and pure/side-effect free
          (interactive)
          (when (projectile-project-p)
            (let* ((current-project-root (projectile-project-root))
                   (project-init-file (expand-file-name fn/project-file current-project-root)))
              (when (file-exists-p project-init-file)
                (message "Loading project init file for %s" (projectile-project-name))
                (unwind-protect
                    (load project-init-file t)
                  (message "There was an error loading %s" project-init-file))))))

        (defun fn/load-project-local-file ()
          (interactive)
          (when (projectile-project-p)
            (let* ((current-project-root (projectile-project-root))
                   (project-local-init-file (expand-file-name fn/project-local-file current-project-root)))
              (when (and  (file-exists-p project-local-init-file)
                          (not (member (buffer-file-name) fn/project-init-files)))
                (message "Loading project local file for %s on %s" (projectile-project-name) (buffer-name))
                (unwind-protect
                    (load project-local-init-file t)
                  (message "There was an error loading %s" project-local-init-file))))))

        (lexical-let* ((project-memoized (lambda ()
                                           (lexical-let ((initialized-projects (list ".")))
                                             #'(lambda ()
                                                 (when (projectile-project-p)
                                                   (lexical-let ((current-project (projectile-project-root)))
                                                     (if (not (member current-project initialized-projects))
                                                         (progn
                                                           (add-to-list 'initialized-projects current-project)
                                                           (fn/load-project-file))
                                                       current-project
                                                       )))))))
                       (load-project-hook (funcall project-memoized)))

          (add-hook 'find-file-hook load-project-hook)
          (add-hook 'find-dired-hook load-project-hook))


        (add-hook 'find-file-hook 'fn/load-project-local-file)
        (add-hook 'find-dired-hook 'fn/load-project-local-file)

        (projectile-global-mode t)
        (setq projectile-indexing-method 'native)

        (add-to-list 'projectile-project-root-files "config.xml"))
    #+END_SRC

*** helm
    The revolutionary package to find

    #+BEGIN_SRC emacs-lisp
      (use-package helm
        :ensure t
        :diminish helm-mode
        :defer 2
        :bind (("M-x" . helm-M-x)
               ("C-c f" . helm-recentf)
               ("C-h a" . helm-apropos)
               ("C-h r" . helm-info-emacs)
               ("C-x b" . helm-mini)
               ("C-x C-b" . helm-buffers-list)
               ("C-x C-f" . helm-find-files)
               ("M-s o" . helm-occur))
        :config
        (require 'helm-config)

        (setq helm-split-window-in-side-p t
              helm-yank-symbol-first t

              helm-mode-fuzzy-match t
              helm-completion-in-region-fuzzy-match t
              helm-buffers-fuzzy-matching t
              helm-apropos-fuzzy-match t
              helm-recentf-fuzzy-match t
              helm-semantic-fuzzy-match t
              helm-locate-fuzzy-match t

              helm-su-or-sudo "su"

              helm-ff-file-name-history-use-recentf t
              helm-ff-auto-update-initial-value t

              helm-echo-input-in-header-line t)

        (setq helm-debug-root-directory fn/cache-dir)

        (helm-mode t)


        (setq helm-adaptive-history-file (expand-file-name "helm-adaptive-history" fn/cache-dir))

        (helm-adaptive-mode t)


        (helm-autoresize-mode t)

        (add-hook 'eshell-mode-hook (lambda ()
                                      (define-key eshell-mode-map
                                        [remap eshell-pcomplete]
                                        'helm-esh-pcomplete)
                                      (define-key eshell-mode-map
                                        (kbd "M-p")
                                        'helm-eshell-history)))

        (ido-mode -1))


      (use-package helm-projectile
        :ensure t
        :after (projectile helm)
        :bind (("C-c p h" . helm-projectile)
               ("C-c p p" . helm-projectile-switch-project))
        :config
        (setq projectile-completion-system 'helm)
        (helm-projectile-on))

      (use-package helm-swoop
        :ensure t
        :after helm
        :bind (("M-i" . helm-swoop)
               ("C-c M-i" . helm-multi-swoop))
        :config
        (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
        (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line))

      (use-package wgrep-helm
        :ensure t
        :after helm
        :config
        (setq wgrep-auto-save-buffer t))
    #+END_SRC

** Help
   Helper functions ere

*** command-log
    A command log when needed

    #+BEGIN_SRC emacs-lisp
      (use-package command-log-mode
        :ensure t
        :diminish command-log-mode
        :config
        (global-command-log-mode t))
    #+END_SRC

*** keyfreq
    Nice to know what key's I press the most

    #+BEGIN_SRC emacs-lisp
      (use-package keyfreq
        :ensure t
        :bind (("C-c n K" . keyfreq-show))
        :config
        (keyfreq-mode t)
        (keyfreq-autosave-mode t)

        (setq keyfreq-file (expand-file-name "keyfreq" fn/cache-dir)
              keyfreq-file-lock (expand-file-name "keyfreq.lock" fn/cache-dir)))
    #+END_SRC

*** which-key
    A mnemionic for key bindings

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :ensure t
        :diminish which-key-mode
        :config
        (which-key-mode t))
    #+END_SRC

*** which-function
    Likewise with key and funcitons

    #+BEGIN_SRC emacs-lisp
      (use-package which-function
        :init
        (which-function-mode t))
    #+END_SRC

*** eldoc
    Nice to have the documentation at any time in the buffer.

    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :diminish eldoc-mode
        :init
        (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

        (add-hook 'org-mode-hook 'turn-on-eldoc-mode))
    #+END_SRC

*** helm-descbinds
    Another way to check bindings

    #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :ensure t
        :after helm
        :bind (("C-h b" . helm-descbinds)))
    #+END_SRC

*** helm-describe-modes
    A nice way to describe the current modes

    #+BEGIN_SRC emacs-lisp
      (use-package helm-describe-modes
        :ensure t
        :after helm
        :config
        (global-set-key [remap describe-mode] #'helm-describe-modes))
    #+END_SRC
** Packages
   Anything to manage packages

*** paradox
    The package management improvement

    #+BEGIN_SRC emacs-lisp
      (use-package paradox
        :ensure t
        :bind (("C-c n p" . paradox-list-packages))
        :config
        (setq paradox-github-token t))
    #+END_SRC

* Artist
  Visual aesthetics is also a functional thing as well

** Font
   I like fixed font specially DejaVu Mono

   #+BEGIN_SRC emacs-lisp
     (set-frame-font "DejaVu Sans Mono-8" t t )
   #+END_SRC

** Screen
   I prefer no clutter in my screen so I disable majority of the niceties.

   #+BEGIN_SRC emacs-lisp
     (defun fn/optimize-visual-space ()
       (let ((try-set-mode (lambda (mode value)
                             (when (fboundp 'mode)
                               (mode value)))))
         (funcall try-set-mode 'tooltip-mode -1)
         (funcall try-set-mode 'tool-bar-mode -1)
         (funcall try-set-mode 'menu-bar-mode -1)
         (funcall try-set-mode 'fringe-mode 0)))

     (fn/optimize-visual-space)

     (add-hook 'after-init-hook 'toggle-frame-fullscreen)
   #+END_SRC

** Theme
   I like dark themes, my eyes respond better to it

   My chosen themes

   #+BEGIN_SRC emacs-lisp
     (use-package apropospriate-theme
       :ensure t
       :defer t)

     (use-package base16-theme
       :ensure t
       :defer t)

     (use-package tronesque-theme
       :ensure t
       :defer t)
   #+END_SRC

   Load the theme if it is a terminal or desktop.

   #+BEGIN_SRC emacs-lisp
     (cond
      ((window-system) (load-theme 'apropospriate-dark t))
      ((not (window-system)) (load-theme 'tronesque t)))
   #+END_SRC

** Aesthetic
   Somewhat more aesthetic than functional

*** whitespace
    Got to love that whitespace display

    #+BEGIN_SRC emacs-lisp
      (use-package whitespace-mode
        :init
        (global-whitespace-mode t)
        (diminish 'global-whitespace-mode))
    #+END_SRC

*** diff-hl
    Diffing tool

    #+BEGIN_SRC emacs-lisp
      (use-package diff-hl
        :ensure t
        :config
        (global-diff-hl-mode)
        (setq diff-hl-side 'left)
        (diff-hl-margin-mode))

      (use-package diff-hl
        :after magit
        :config
        (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
    #+END_SRC
*** hl-line
    Highlight the current line

    #+BEGIN_SRC emacs-lisp
      (use-package hl-line
        :diminish hl-line-mode
        :init
        (global-hl-line-mode t))
    #+END_SRC

*** smart-mode-line
    It is a nice feature

    #+BEGIN_SRC emacs-lisp
      (use-package smart-mode-line-powerline-theme
        :ensure t)

      (use-package smart-mode-line
        :ensure t
        :config
        (setq sml/no-confirm-load-theme t
              sml/shorten-directory t
              sml/shorten-modes t
              sml/theme 'powerline)

        (sml/setup))
    #+END_SRC

** Screensaver
   When idle time hits

*** nyan
    Love them kitty down there. Also this keeps things in perspective to have fun.

    #+BEGIN_SRC emacs-lisp
      (use-package nyan-mode
        :ensure t
        :config
        (nyan-mode t))
    #+END_SRC

*** fireplace
    Warm and cozy feeling

    #+BEGIN_SRC emacs-lisp
      (use-package fireplace
        :bind (("C-c n f" . fireplace))
        :ensure t)
    #+END_SRC

*** zone
    I love to zone out from time to time.

    #+BEGIN_SRC emacs-lisp
      (use-package zone
        :ensure t
        :config
        (zone-when-idle (* fn/minute-per-second 5))

        (setq zone-programs (list))

        (setq
         zone-animation-directory (expand-file-name "elisp/custom-zone" user-emacs-directory)
         end-of-buffer-animation (expand-file-name "end-of-buffer.el" zone-animation-directory)
         waves-animation (expand-file-name "waves.el" zone-animation-directory)
         )

        (load-file end-of-buffer-animation)
        (load-file waves-animation)

        (add-to-list 'zone-programs 'zone-end-of-buffer)
        (add-to-list 'zone-programs 'zone-waves))

      (use-package zone-nyan
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-nyan))

      (use-package zone-rainbow
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-rainbow))

      (use-package zone-sl
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-sl))
    #+END_SRC

** Coding
   Whatever pertains to coding

*** font-lock
    Syntax highlighting is a requirement

    #+BEGIN_SRC emacs-lisp
      (global-font-lock-mode t)

      (setq font-lock-support-mode 'jit-lock-mode)
      (setq font-lock-maximum-decoration t)
    #+END_SRC
*** prettify-symbols
    Make things more algebraic

    #+BEGIN_SRC emacs-lisp
      (setq fn/enable-prettify-symbols nil)

      (use-package prettify-symbols-mode
        :if (version<= "24.4.4" emacs-version)
        :init
        (setq fn/enable-prettify-symbols t))
    #+END_SRC

*** rainbow-delimeter
    Visual aid helps with very nested code

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
        :config
        (custom-set-faces
         ;; Thanks to https://ericscrivner.me/2015/06/better-emacs-rainbow-delimiters-color-scheme/
         '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
         '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
         '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
         '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
         '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
         '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
         '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
         '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))))

    #+END_SRC

*** color-identifiers-mode
    Make things easier to see

    #+BEGIN_SRC emacs-lisp
      (use-package color-identifiers-mode
        :ensure t
        :defer t
        :diminish color-identifiers-mode
        )
    #+END_SRC
*** show-paren
    Also a vital thing to keeping things highlighted

    #+BEGIN_SRC emacs-lisp
      (show-paren-mode t)

      (setq show-paren-style 'expression)
    #+END_SRC

* Organizer
  Things to organize life in general

** epa
   Encryption is a must

   Credits to [[http://conornash.com/2014/03/transparently-encrypt-org-files-in-emacs/][Conor Nash]] for this

   #+BEGIN_SRC emacs-lisp
     (require 'epa-file)
     (epa-file-enable)

     (defun fn/backup-each-save-filter (filename)
       (let ((ignored-filenames
              '("\\.gpg$"))
             (matched-ignored-filename nil))
         (mapc
          (lambda (x)
            (when (string-match x filename)
              (setq matched-ignored-filename t)))
          ignored-filenames)
         (not matched-ignored-filename)))

     (setq backup-each-save-filter-function 'fn/backup-each-save-filter)

     (setq enable-local-variables :safe)

     (add-to-list 'safe-local-variable-values '(auto-save-default))
     (add-to-list 'safe-local-variable-values  '(backup-inhibited . t))
     (add-to-list 'safe-local-variable-values '(epa-file-encrypt-to))
   #+END_SRC
** org
   org-mode my buddy. This is filed under external modes since I download a new copy of org mode to be updated.

   Some basic setup which I use =org-drill= and =org-journal=

   Here is a reference to the  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Time-Parsing.html][date time format]].

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :bind (("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c h" . helm-org-in-buffer-headings)
              ("C-c c" . org-capture))
       :config
       ;; org files
       (defconst fn/org-dir (expand-file-name "~/Fakespace/nobody-library")
         "Main library for org files")

       (defconst fn/org-default-capture-file (expand-file-name "capture.org" fn/org-dir)
         "Main capture org file")

       (defconst fn/org-main-file (expand-file-name "main.org" fn/org-dir)
         "Main org planning file")

       (defconst fn/org-todo-file (expand-file-name "todo.org" fn/org-dir)
         "Main org todo file")

       (defconst fn/org-event-file (expand-file-name "event.org" fn/org-dir)
         "My event planning file")

       ;; org itself
       (setq org-id-locations-file (expand-file-name "org-id-locations" fn/cache-dir))


       ;; org-src
       (setq org-src-window-setup 'current-window)


       ;; org-todo
       (setq org-todo-keywords
             '((sequence "INVESTIGATE(i)" "TODO(t)" "PENDING(p)" "|" "DONE(d)" "CANCELLED(c)")))


       ;; org-capture
       (setq org-capture-templates
             (list
              (list "t" "Todo" 'entry
                    (list 'file+headline fn/org-todo-file "Todo")
                    "* INVESTIGATE %?\n   %i")
              (list "e" "Event" 'entry
                    (list 'file+headline  fn/org-event-file "Events")
                    "* %? :event:")))


       ;; org-agenda
       (setq org-agenda-span 14) ;; Fortnight

       (setq org-agenda-files
             (list
              fn/org-main-file
              fn/org-todo-file))

       (setq org-refile-targets nil) ;; TODO: Make refile tagets

       ;; org-clock
       (setq org-log-done 'time)

       (defun fn/clock-todo-change ()
         "A nice little hook that clocks in when a todo is change to PENDING"
         (let ((new-state org-state))
           (pcase new-state
             ("PENDING" (org-clock-in))
             (_ nil))))

       (add-hook 'org-after-todo-state-change-hook 'fn/clock-todo-change))
   #+END_SRC

   I prefer to see my main org file on boot

   #+BEGIN_SRC emacs-lisp
      (defun fn/find-main-org-file ()
        (interactive)
        (find-file fn/org-main-file))
    #+END_SRC

*** org-journal
    Having a journal is good

    #+BEGIN_SRC emacs-lisp
      (use-package org-journal
        :ensure t
        :after org
        :bind (("C-c n j" . org-journal-new-entry)) ;; C-c j conflicts with normal org-mode
        :config
        (setq org-journal-dir
              (expand-file-name "diary" fn/org-dir))

        (setq org-journal-date-format "%Y-%b-%d %a" ;; YYYY-MMM-DD DAY
              org-journal-time-format "%T ") ;; HH:MM:SS and the space is required

        (setq org-journal-file-format "%Y-%m-%d.journal.org.gpg") ;; Encryption via epa

        (setq org-journal-find-file 'find-file)

        (defun fm/insert-private-file-headers ()
          (interactive)
          (add-file-local-variable-prop-line 'backup-inhibited t)
          (add-file-local-variable-prop-line 'auto-save-default nil))

        (defun fm/insert-org-gpg-headers ()
          (interactive)
          (add-file-local-variable-prop-line
           'epa-file-encrypt-to (list "fnmurillo@yandex.com"))
          (fm/insert-private-file-headers))

        (defun fmj/insert-summary-block ()
          "Insert summary block at point, this is pretty much #+BEGIN_SRC except summary"
          (interactive)
          (let ((summary-block
                 (string-join (list "#+BEGIN_SUMMARY"
                                    "Something happened but I was too lazy to write it down"
                                    "#+END_SUMMARY")
                              "\n")))
            (insert (concat summary-block "\n"))))

        (defun fmj/insert-org-journal-headers ()
          (interactive)
          (fm/insert-org-gpg-headers)

          (end-of-visual-line)
          (newline-and-indent)

          (when (string-match "\\(20[0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)"
                              (buffer-name))
            (let ((year  (string-to-number (match-string 1 (buffer-name))))
                  (month (string-to-number (match-string 2 (buffer-name))))
                  (day (string-to-number (match-string 3 (buffer-name))))
                  (datim nil))
              (setq datim (encode-time 0 0 0 day month year))

              (insert "#+STARTUP: content\n")
              (insert (format-time-string
                       "#+TITLE: Journal Entry - %Y-%b-%d %a\n" datim))

              (fmj/insert-summary-block)


              (insert (format-time-string
                       "* %Y-%b-%d %a" datim)))))

        (auto-insert-mode t)
        (setq auto-insert-query t) ;; Don't ask, just put it in there
        (add-hook 'find-file-hook 'auto-insert)

        (add-to-list 'auto-insert-alist '(".*\.org\.gpg$" . fm/insert-org-gpg-headers))
        (add-to-list 'auto-insert-alist '(".*\.private.org" . fm/insert-private-file-headers))
        (add-to-list 'auto-insert-alist '(".*\.journal.org.gpg" . fmj/insert-org-journal-headers)))
    #+END_SRC

***
*** org-reveal
     A nice presentation framework

     #+BEGIN_SRC emacs-lisp
       (use-package ox-reveal
         :ensure t
         :after org
         :config
         (setq org-reveal-root "file:////home/fnmurillo/Fakespace/reveal-js")

         (define-minor-mode fn-reveal-editing
           "Some editing enhancement when editing org-reveal files"
           :lighter " FnRevealer"
           :init-value nil
           :global nil
           :keymap (let* ((map (make-sparse-keymap))
                          (tangle-current-file (lambda ()
                                                 (interactive)
                                                 (let* ((current-file (buffer-file-name))
                                                        (target-file (replace-regexp-in-string ".org" ".js" current-file))
                                                        (target-lang "javascript"))
                                                   (org-babel-tangle-file current-file target-file target-lang))))
                          (export-reveal (lambda ()
                                           (interactive)
                                           (message "Exporting %s" (buffer-file-name))
                                           (org-reveal-export-to-html t))))
                     (define-key map (kbd "C-c C-n C-p") tangle-current-file)
                     (define-key map (kbd "C-c C-n C-e") export-reveal)
                     map)

           (let ((export-reveal (lambda ()
                                  (when fnr/enable-auto-export-on-save
                                    (message "Auto exporting %s" (buffer-file-name))

                                    (org-reveal-export-to-html t)))))
             (add-hook 'after-save-hook export-reveal t t)))

         (make-variable-buffer-local
          (defvar fnr/enable-auto-export-on-save t
            "When non-nil. auto exports org-reveal files on save")))
     #+END_SRC
*** org-drill
    Flash cards are a must

    #+BEGIN_SRC emacs-lisp
      (use-package org-drill
        :after org
        :config
        (add-to-list 'org-modules 'org-drill)

        (defconst fn/org-review-file (expand-file-name "learning.org" fn/org-dir)
          "Main org drill files")

        (add-to-list 'org-capture-templates
                     (list "r" "Review/Remember" 'entry
                           (list 'file+headline fn/org-review-file "Learning Notes" "Review")
                           "* %? :drill:\n  CREATED_ON: %T"))

        (add-to-list 'org-agenda-files fn/org-review-file)

        (setq org-drill-scope
              (list fn/org-review-file)))
    #+END_SRC
*** org-mobile
    Mobile org document

    #+BEGIN_SRC emacs-lisp
      (use-package org-mobile
        :after org
        :config
        (defconst fn/org-mobile-directory (expand-file-name "mobile" fn/org-dir)
          "My org mobile directory")

        (defconst fn/org-mobile-inbox-directory (expand-file-name "mobile-pull" fn/org-dir)
          "My org mobile directory")

        (setq org-mobile-directory  fn/org-mobile-directory
              org-mobile-inbox-for-pull fn/org-mobile-inbox-directory))

    #+END_SRC

** flyspell
    Having a good spell checker is a must. I use =flyspell= although I have read issues about it

    #+BEGIN_SRC emacs-lisp
      (use-package flyspell
        :ensure t
        :defer t
        :diminish flyspell-mode
        :init
         (add-hook 'org-mode-hook 'flyspell-mode t))
    #+END_SRC

** dired
    Directory management for Emacs

    #+BEGIN_SRC emacs-lisp
      (require 'dired-x) ;; Allows multi open marked files

      (setq dired-recursive-copies 'always  ;; Don't ask because I did it
            dired-recursive-deletes 'always)

      (setq dired-dwim-target t) ;; Split pane copying, be careful though with this

      (setq dired-listing-switches "-alh") ;; Want to see the size with better details

      (dired-async-mode t)

      (add-hook 'dired-mode-hook 'dired-hide-details-mode)
    #+END_SRC

*** image-dired
    Text is not enough, images are important too

    #+BEGIN_SRC emacs-lisp
      (use-package image-dired
        :ensure t
        :after image-dired
        :defer t
        :config
        (setq image-dired-dir (expand-file-name "image-dired" fn/cache-dir-name)))
    #+END_SRC

*** tmtxt
    Experimental =dired= with =rsync= all thanks to [[https://github.com/tmtxt][tmtxt]]

    #+BEGIN_SRC emacs-lisp
      (defconst fn/tmtxt-package-dir (expand-file-name "tmtxt/" fn/custom-package-dir)
        "tmtxt package directory")

      (use-package tmtxt-async-tasks
        :load-path fn/tmtxt-package-dir
        :defer 2
        :after dired
        :config
        (setq-default tat/window-close-delay "10"
                      tat/window-height 5))

      (use-package tmtxt-dired-async
        :after tmtxt-async-tasks
        :config
        (setq-default tda/rsync-arguments "-avzh --progress")

        (define-key dired-mode-map (kbd "C-c C-r") 'tda/rsync)
        (define-key dired-mode-map (kbd "C-c C-t") 'tda/rsync-delete)

        (define-key dired-mode-map (kbd "C-c C-a") 'tda/rsync-multiple-mark-file)
        (define-key dired-mode-map (kbd "C-c C-e") 'tda/rsync-multiple-empty-list)
        (define-key dired-mode-map (kbd "C-c C-d") 'tda/rsync-multiple-remove-item)
        (define-key dired-mode-map (kbd "C-c C-v") 'tda/rsync-multiple)
        (define-key dired-mode-map (kbd "C-c C-z") 'tda/zip)
        (define-key dired-mode-map (kbd "C-c C-u") 'tda/unzip)

        (define-key dired-mode-map (kbd "C-c C-s") 'tda/get-files-size)

        (define-key dired-mode-map (kbd "C-c C-q") 'tda/download-to-current-dir)
        (define-key dired-mode-map (kbd "C-c C-l") 'tda/download-clipboard-link-to-current-dir))
    #+END_SRC

** tramp
   Tramp is too good to pass up

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :config
       (setq tramp-persistency-file-name (expand-file-name "tramp" fn/cache-dir)))
   #+END_SRC

** ledger
   Something to keep track of my finances

   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :ensure t
       :defer t
       :init
       (setq ledger-clear-whole-transactions t))

     (use-package flycheck-ledger
       :ensure t
       :after (ledger-mode flycheck))
   #+END_SRC
** woman
   Man pages are nice

   #+BEGIN_SRC emacs-lisp
     (use-package woman
       :ensure t)
   #+END_SRC
* Code Monkey
  Modes for my programming experiences

** Support
   Generic support for coding

*** type-break-mode
    I definitely need to chill out from time to time

    #+BEGIN_SRC emacs-lisp
      (use-package type-break
        :bind (("C-c n C-t" . type-break))
        :config
        (setq type-break-interval (* fn/minute-per-second 25)
              type-break-good-rest-interva (* fn/minute-per-second 5)

              type-break-file-name (expand-file-name "type-break" fn/cache-dir)
              type-break-auto-save-file-name (expand-file-name "type-break-autosave" fn/cache-dir))

        (type-break-mode t)
        (type-break-query-mode t))
    #+END_SRC

*** auto-compile
    A good mode when editing lisp files

    #+BEGIN_SRC emacs-lisp
      (use-package auto-compile
        :ensure t
        :defer t
        :init
        (add-hook 'emacs-lisp-mode-hook 'auto-compile-mode)
        :config
        (setq load-prefer-newer t)
        (auto-compile-on-load-mode)
        (auto-compile-on-save-mode))
    #+END_SRC
*** smartparens
    This is as handy as =paredit=

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :diminish smartparens-mode
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'smartparens-mode))

      (use-package smartparens-config
        :after smartparens)
    #+END_SRC

*** flycheck
    Syntax checking is very important

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer  t
        :diminish flycheck-mode
        :init
        (add-hook 'js2-mode-hook 'flycheck-mode)
        (add-hook 'web-mode 'flycheck-mode)
        (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
        (add-hook 'python-mode 'flycheck-mode)
        :config
        (setq flycheck-highlighting-mode 'sexps)

        (defun fn/tweak-flycheck-python ()
          ;; TODO:When python get slow in flycheck, highlighting mode should be set to lines instead
          )

        (add-hook 'python-mode-hook 'fn/tweak-flycheck-python))

      (use-package flycheck-pos-tip
        :ensure t
        :after flycheck
        :config
        (flycheck-pos-tip-mode t))
    #+END_SRC

*** magit
    Enough said, [[https://github.com/magit/magit][magit]] is the best git client you can get anywhere.

    There is a sad version requirement for 24.4 to use the latest code.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :ensure t
        :if (version<= "24.4.4" emacs-version)
        :bind (("C-c g" . magit-status)
               ("M-g b" . magit-blame))
        :init
        (setq magit-push-always-verify t))

      (use-package git-timemachine
        :ensure t
        :bind (("M-g t" . git-timemachine)))

      (use-package git-gutter
        :ensure t
        :diminish git-gutter-mode
        :config
        (global-git-gutter-mode t))
    #+END_SRC

*** gist
    GitHub integration with gists

    #+BEGIN_SRC emacs-lisp
      (use-package gist
        :ensure t
        :defer t
        )
    #+END_SRC
** Helper
   Specific helper modes

*** npm
    Call npm with Emacs
    #+BEGIN_SRC emacs-lisp
      (use-package npm-mode
        :ensure t
        :defer t
        :bind (("C-c n e" . npm-mode)))
    #+END_SRC

** Elisp
*** Motion
    Makes you a good lisp developer and quite addictive to have

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t
        :defer t
        :diminish paredit-mode
        :init
        (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook #'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode))

      (use-package paredit
        :after eldoc
        :config
        (eldoc-add-command 'paredit-backward-delete
                           'paredit-close-round))
    #+END_SRC
*** Refactor
    Emacs Lisp refactor mode

    #+BEGIN_SRC emacs-lisp
      (use-package emr
        :ensure t
        :defer t
        :init
        (define-key prog-mode-map (kbd "M-RET") 'emr-show-refactor-menu)
        (add-hook 'prog-mode-hook 'emr-initialize))
    #+END_SRC
*** Formatter
    Not really but nice to have for a lisp language

    #+BEGIN_SRC emacs-lisp
      (use-package elisp-format
        :ensure t
        :defer t
        :disabled t
        :config
        (define-key emacs-lisp-mode-map (kbd "C-c C-f") 'elisp-format-region)

        (make-variable-buffer-local
         (defvar fn/elisp-format-on-save t
           "Enable elisp formatting on save"))

        (defun fn/elisp-format-buffer-on-save ()
          "Format elisp on save"
          (when fn/elisp-format-on-save
            (with-current-buffer (current-buffer)
              (message "Elisp formatting buffer %s" (current-buffer))
              (elisp-format-buffer))))

        (add-hook 'before-save-hook #'fn/elisp-format-buffer-on-save))
    #+END_SRC
** Web
*** Mode
    The defacto mode for web development

    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :ensure t
        :mode (("\\.tt\\'" . web-mode)
               ("\\.erb\\'" . web-mode)
               ("\\.html\\.ep\\'" . web-mode)
               ("\\.blade\\.php\\'" . web-mode)
               ("\\.hbs\\'" . web-mode))
        :init
        (dolist (hook '(emmet-mode))
          (add-hook 'web-mode-hook hook))
        :config
        (setq web-mode-enable-auto-pairing t
              web-mode-enable-auto-closing t
              web-mode-enable-current-element-highlight t
              web-mode-enable-current-column-highlight t))

      (use-package company-web
        :ensure t
        :after web)
    #+END_SRC

*** Editing
    I do a lot of HTML editing, YASnippet can do but emmet is better

    #+BEGIN_SRC emacs-lisp
      (use-package emmet-mode
        :ensure t
        :defer t
        :init
        (dolist (hook '(sgml-mode-hook css-mode-hook kolon-mode-hook))
          (add-hook hook 'emmet-mode)))
    #+END_SRC

*** CSS
    I use [[http://sass-lang.com/][sass]] for my jekyll blog

    #+BEGIN_SRC emacs-lisp
      (use-package sass-mode
        :ensure t
        :defer t
        :config
        ((add-to-list 'auto-mode-alist '("\\.sass\\'" . sass-mode))))
    #+END_SRC
** JavaScript
*** Mode
    The ultimate JS mode

    #+BEGIN_SRC emacs-lisp
      (use-package js2-mode
        :ensure t
        :interpreter (("node" . js2-mode))
        :mode (("\\.\\(js\\|json\\)$" . js2-mode))
        :defer t
        :config
        (add-hook 'js-mode-hook 'js2-minor-mode)
        (setq js2-highlight-level 3
              js2-mode-show-parse-errors nil
              js2-mode-show-strict-warnings nil))

      (use-package js-doc
        :ensure t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook
                  #'(lambda ()
                      (define-key js2-mode-map "\C-ci" 'js-doc-insert-function-doc)
                      (define-key js2-mode-map "@" 'js-doc-insert-tag)))


        (setq js-doc-mail-address user-mail-address
              js-doc-author (format "I am <%s>" js-doc-mail-address)
              js-doc-url "francismurillo.github.io"
              js-doc-license "GPL"))
    #+END_SRC

*** Refactor

    #+BEGIN_SRC emacs-lisp
      (use-package js2-refactor
        :diminish js2-refactor-mode
        :ensure t
        :defer t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook #'js2-refactor-mode)
        :config
        (js2r-add-keybindings-with-prefix "C-c C-m"))
    #+END_SRC

*** Autocomplete
    A must have for Javascript development

    #+BEGIN_SRC emacs-lisp
      (use-package tern
        :ensure t
        :defer t
        :diminish tern-mode
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook 'tern-mode))

      (use-package company-tern
        :ensure t
        :after (tern company)
        :config
        (add-to-list 'company-backends 'company-tern))
    #+END_SRC

*** Formatter
    Formatter for js

    #+BEGIN_SRC emacs-lisp
      (use-package web-beautify
        :ensure t
        :after js2-mode
        :bind (("C-c C-b" . web-beautify-js)))

    #+END_SRC

*** Snippets
    Snippet support

    #+BEGIN_SRC emacs-lisp
      (use-package react-snippets
        :ensure t
        :after (js2 yasnippet))
    #+END_SRC
*** REPL
    Got to have those REPLs

    #+BEGIN_SRC emacs-lisp
      (use-package nodejs-repl
        :ensure t
        :bind (("C-c C-n C-c" . nodejs-repl-send-buffer)
               ("C-c C-n C-r" . nodejs-repl-send-region)
               ("C-c C-n C-e" . nodejs-repl-send-last-sexp))
        :after js2-mode)

      (use-package skewer-mode
        :defer t
        :diminish skewer-mode
        :bind (("C-c K" . run-skewer))
        :ensure t
        :init
        (add-hook 'js2-mode-hook 'skewer-mode)
        (add-hook 'css-mode-hook 'skewer-css-mode)
        (add-hook 'html-mode-hook 'skewer-html-mode))
    #+END_SRC

*** Prettify
    My symbols for JS

    #+BEGIN_SRC emacs-lisp
      (when fn/enable-prettify-symbols
        (add-hook 'js2-mode-hook
                  (lambda ()
                    (push '("function" . ?) prettify-symbols-alist)
                    (push '("arguments" . ?) prettify-symbols-alist)
                    (push '("var" . ?) prettify-symbols-alist)
                    (push '("return" . ?) prettify-symbols-alist)
                    (push '("this" . ?) prettify-symbols-alist)

                    (push '("for" . ?) prettify-symbols-alist)
                    (push '("in" . ? ) prettify-symbols-alist)

                    (push '("Object" . ?) prettify-symbols-alist)

                    (push '("if" . ?) prettify-symbols-alist)
                    (push '("else if" . ?) prettify-symbols-alist)
                    (push '("else" . ?) prettify-symbols-alist)

                    (push '("->" . ?) prettify-symbols-alist)
                    (push '("&&" . ?) prettify-symbols-alist)
                    (push '("||" . ?) prettify-symbols-alist)

                    (push '("!" . ?) prettify-symbols-alist)
                    (push '("!!" . ?) prettify-symbols-alist)

                    (push '("=" . ?) prettify-symbols-alist)
                    (push '(":" . ?) prettify-symbols-alist)

                    (push '("===" . ?) prettify-symbols-alist)
                    (push '("!==" . ?) prettify-symbols-alist)

                    (push '(">=" . ?) prettify-symbols-alist)
                    (push '("<=" . ?) prettify-symbols-alist)

                    (push '("true" . ?) prettify-symbols-alist)
                    (push '("false" . ?) prettify-symbols-alist)

                    (push '("null" . ?) prettify-symbols-alist)
                    (push '("undefined" . ?) prettify-symbols-alist)

                    (push '(", ". ?) prettify-symbols-alist)
                    (push '("{". ?) prettify-symbols-alist)
                    (push '("},". ?) prettify-symbols-alist)
                    (push '("}". ?) prettify-symbols-alist)
                    (push '("};". ?) prettify-symbols-alist)

                    (push '("(". ?) prettify-symbols-alist)
                    (push '(")". ?) prettify-symbols-alist)
                    (push '(");". ?) prettify-symbols-alist)
                    (push '("),". ?) prettify-symbols-alist)
                    (push '(").". ?) prettify-symbols-alist)

                    (push '("[". ?) prettify-symbols-alist)
                    (push '("]". ?) prettify-symbols-alist)
                    (push '("],". ?) prettify-symbols-alist)
                    (push '("].". ?) prettify-symbols-alist)
                    (push '("];". ?) prettify-symbols-alist)

                    (push '(";". ?) prettify-symbols-alist)

                    (prettify-symbols-mode t))))
    #+END_SRC
*** JSON
    JSON support

    #+BEGIN_SRC emacs-lisp
      (use-package json-snatcher
        :ensure t
        :after js2-mode
        :bind (("C-c C-g" . jsons-print-path)))
    #+END_SRC

** Python
*** Mode
    My favorite programming language, unassuming like Marcy from Peanuts

    #+BEGIN_SRC emacs-lisp
      (use-package python
        :defer t
        :ensure t)
    #+END_SRC

*** Formatter
    Pep me bro

    #+BEGIN_SRC emacs-lisp
      (use-package py-autopep8
        :ensure t
        :defer t
        :after python)
    #+END_SRC

*** REPL
    Using =Ipython= for this

    #+BEGIN_SRC emacs-lisp
      (use-package ein
        :ensure t
        :defer t
        :after python
        :config
        (setq ein:use-auto-complete t
              ein:use-smartrep t))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    #+END_SRC

*** Autocomplete
    The newer Python IDE, [[https://github.com/davidhalter/jedi][Jedi]], much easier to grok.

    This requires [[https://pypi.python.org/pypi/pip/][pip]] and the packages  [[https://pypi.python.org/pypi/virtualenv][virtualenv]]. The snippet below is for the hard dependency. Let =jedi:install-server= do the work

    #+BEGIN_SRC sh
      curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

      python get-pip.py

      pip install virtualenv
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package company-jedi
        :after company
        :config
        (add-to-list 'company-backends 'company-jedi))
    #+END_SRC

*** IDE
    Making Python an IDE

    #+BEGIN_SRC emacs-lisp
      (use-package elpy
        :ensure t
        :defer t
        :init
        (add-hook 'python-mode-hook 'elpy-enable)

        (add-hook 'elpy-mode-hook 'flycheck-mode)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
        :config
        (setq elpy-python-command "python3"
              elpy-rpc-python-command "python3"
              elpy-rpc-backend "jedi")

        (setq elpy-interactive-python-command "ipython")
        (elpy-use-ipython)

        (setq elpy-modules (delq 'elpy-module-flycheck elpy-modules))

        (require 'py-autopep8)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
    #+END_SRC

** Haskell
*** Mode
    The defacto for Haskell development

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :ensure t
        :defer t
        :mode "\\.hs\\'"
        :init
        (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
        (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
        (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
        :config
        (require 'haskell-interactive-mode)
        (require 'haskell-process)
        ;; Reset mapping as it does more damage than good
        (setq haskell-cabal-mode-map (make-keymap)
              interactive-haskell-mode-map (make-keymap))

        (define-key haskell-mode-map (kbd "<f8>") 'haskell-navigate-imports)

        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile)
        (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile)

        ;; Haskell bindings
        (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
        (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
        (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
        (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Cabal bindings
        ;; (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Interactive Haskell
        (define-key interactive-haskell-mode-map (kbd "C-c M-.") 'haskell-mode-goto-loc)
        (define-key interactive-haskell-mode-map (kbd "C-c M-t") 'haskell-mode-show-type-at)

        (setq haskell-stylish-on-save t)

        (setq interactive-haskell-mode t)

        (setq haskell-process-suggest-remove-import-lines t
              haskell-process-auto-import-loaded-modules t
              haskell-process-log t
              haskell-process-suggest-hoogle-imports t
              haskell-interactive-mode-eval-mode 'haskell-mode))
    #+END_SRC

*** Motion
    The paredit for haskell, this weirdly needs [[exec-path-from-shell]] to work

    #+BEGIN_SRC emacs-lisp
      (use-package shm
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook 'structured-haskell-mode)
        :config
        ;; (define-key shm-map  "\C-j" 'shm/newline-indent)
        (define-key shm-map (kbd "M-a") 'shm/goto-parent)
        (define-key shm-map (kbd "M-e") 'shm/goto-parent-end)
        ;; (define-key shm-map  "\C-+" 'shm/add-operand)
        (define-key shm-map (kbd "M-r") 'shm/raise)
        (define-key shm-map (kbd "M-^") 'shm/delete-indentation)
        (define-key shm-map (kbd "M-k") 'shm/kill)
        (define-key shm-map (kbd "C-y") 'shm/yank)
        (define-key shm-map (kbd "M-k") 'shm/kill-line)
        (define-key shm-map (kbd "C-c C-s") 'shm/case-split))
    #+END_SRC

*** Autocomplete
    Company for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package company-ghc
        :ensure t
        :after (haskell-mode company)
        :config
        (add-to-list 'company-backends 'company-ghc))

      (use-package company-ghci
        :ensure t
        :after (haskell-mode company)
        :config
        (add-to-list 'company-backends 'company-ghci))

    #+END_SRC
*** Formatter
    Formatter for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package hindent
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook #'hindent-mode)
        :config
        (setq hindent-style "johan-tibell"))
    #+END_SRC

*** Linter
    Syntax checker for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-haskell
        :ensure t
        :after (flycheck haskell-mode)
        :init
        (add-hook 'haskell-mode-hook 'flycheck-mode)
        :config
        (flycheck-haskell-setup))
    #+END_SRC

***

*** Prettify
    My symbols for Haskell

    #+BEGIN_SRC emacs-lisp
      (when fn/enable-prettify-symbols
        (add-hook 'haskell-mode-hook
                  (lambda ()
                    (push '("->" . ?) prettify-symbols-alist)
                    (push '("let" . ?) prettify-symbols-alist)
                    (push '("if" . ?) prettify-symbols-alist)
                    (push '("in" . ?) prettify-symbols-alist)
                    (push '("then" . ?) prettify-symbols-alist)
                    (push '("else" . ?) prettify-symbols-alist)
                    (push '("where" . ?) prettify-symbols-alist)
                    (push '("module" . ?) prettify-symbols-alist)
                    (push '("data" . ?) prettify-symbols-alist)
                    (push '("deriving" . ?) prettify-symbols-alist)
                    (prettify-symbols-mode t))))

    #+END_SRC
*** Build Tools
    Maybe stack or hack?
** Elm
   Functional JavaScript frontend

*** Mode
   Elm major mode

   #+BEGIN_SRC emacs-lisp
     (use-package elm-mode
       :ensure t
       :defer t
       :config
       nil)
   #+END_SRC

   There is a conflict if you're using this with aggressive indent

   #+BEGIN_SRC emacs-lisp
     (use-package elm-mode
       :after aggressive-indent
       :config
       (add-hook 'elm-mode-hook
                 (lambda ()
                   (setq-local aggressive-indent-mode nil))))
   #+END_SRC

*** Linter
    Linter for Elm

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-elm
        :ensure t
        :after (flycheck elm-mode)
        :config
        (flycheck-elm-setup))
    #+END_SRC

*** Formatter
    Formatter for Elm, requires =elm-format=

    #+BEGIN_SRC emacs-lisp
      (use-package elm-mode
        :config
        (setq elm-format-on-save t
              elm-sort-imports-on-save t))

    #+END_SRC
*** Autocomplete
    A needed feature, requires =elm-oracle=

    #+BEGIN_SRC emacs-lisp
      (use-package elm-mode
        :after (elm-mode company)
        :config
        (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
        (add-to-list 'company-backends 'company-elm))
    #+END_SRC

*** Snippets
    Snippets too

    #+BEGIN_SRC emacs-lisp
      (use-package elm-yasnippets
        :ensure t
        :after (elm yasnippets))
    #+END_SRC

** Elixir
   The dynamic Haskell in my opinion... or was it Python

*** Mode
    Main mode for Elixir

    #+BEGIN_SRC emacs-lisp
      (use-package elixir-mode
        :ensure t
        :defer t)
    #+END_SRC

*** Linter
    A linter is always needed

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-elixir
        :ensure t
        :after (elixir-mode flycheck)
        :defer t)
    #+END_SRC

    Integration with =mix=

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck-mix
        :ensure t
        :after (elixir-mode flycheck)
        :defer t)
    #+END_SRC

*** Snippets
    Snippets support via yasnippet

    #+BEGIN_SRC emacs-lisp
      (use-package elixir-yasnippets
        :ensure t
        :after (elixir-mode yasnippet)
        :defer t)
    #+END_SRC

*** Build Tools
    Build tool for Elixir

    #+BEGIN_SRC emacs-lisp
      (use-package alchemist
        :ensure t
        :after elixir-mode
        :defer t)
    #+END_SRC

** dotNet
*** omnisharp
    For C# development

    #+BEGIN_SRC emacs-lisp
      (use-package omnisharp
        :ensure t
        :defer t
        :init
        (add-hook 'csharp-mode-hook 'omnisharp-mode)
        :config
        (setq omnisharp-root-dir
              (expand-file-name "~/Fakespace/omnisharp-server"))
        (setq omnisharp-server-executable-path
              (expand-file-name "OmniSharp/bin/Debug/" omnisharp-root-dir)))
    #+END_SRC

** LaTeX
   LaTeX editing for my files


   #+BEGIN_SRC emacs-lisp
     (use-package auctex
       :ensure t
       :defer t
       :init
       (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
       (add-hook 'latex-mode-hook 'turn-on-reftex)
       (setq reftex-plug-into-AUCTex t))

     (use-package company-auctex
       :ensure t
       :after auctex
       :config
       (company-auctex-init))

     (use-package auctex-latexmk
       :ensure t
       :after auctex)
   #+END_SRC

*** haskell-snippets
    Easy snippets for Haskell

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-snippets
        :ensure t
        :after (yasnippet haskell-mode)
        :config
        (require 'haskell-snippets))
    #+END_SRC
* Random Was Alone
  Anything that just does something useful

** twittering
    Integrating with emacs is very fun via [[https://github.com/hayamiz/twittering-mode][twittering]]

    #+BEGIN_SRC emacs-lisp
      (use-package twittering-mode
        :ensure t
        :defer t
        :init
        (setq twittering-auth-method 'oauth)
        (setq twittering-use-master-password t)
        :config
        (twittering-icon-mode t)
        (setq twittering-convert-fix-size 24))
    #+END_SRC

** engine
    Instant search with Emacs, sign me up.

    #+BEGIN_SRC emacs-lisp
      (use-package engine-mode
        :ensure t
        :config
        (engine-mode t)

        (engine/set-keymap-prefix (kbd "C-c s"))
        (setq engine/browser-function 'browse-url-firefox)

        (defengine amazon
          "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")

        (defengine duckduckgo
          "https://duckduckgo.com/?q=%s"
          :keybinding "d")

        (defengine emacsgo
          "https://duckduckgo.com/?q=emacs+%s"
          :keybinding "e")

        (defengine github
          "https://github.com/search?ref=simplesearch&q=%s"
          :keybinding "g")

        (defengine project-gutenberg
          "http://www.gutenberg.org/ebooks/search/?query=%s")

        (defengine rfcs
          "http://pretty-rfc.herokuapp.com/search?q=%s")

        (defengine stack-overflow
          "https://stackoverflow.com/search?q=%s"
          :keybinding "t")

        (defengine twitter
          "https://twitter.com/search?q=%s")

        (defengine wikipedia
          "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
          :keybinding "w"
          :docstring "Searchin' the wikis.")

        (defengine wiktionary
          "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

        (defengine wolfram-alpha
          "http://www.wolframalpha.com/input/?i=%s")

        (defengine youtube
          "http://www.youtube.com/results?aq=f&oq=&search_query=%s"))
    #+END_SRC

** elfeed
   RSS Reader in Emacs

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :ensure t
       :defer t
       :bind (("C-c n r" . elfeed))
       :if (fn/check-command "curl")
       :init
       ;; Update feeds on startup
       (add-hook 'after-init-hook 'elfeed-update)
       :config
       (setq elfeed-curl-program-name "curl")

       (setq elfeed-feeds (list
                           (list "http://planet.emacsen.org/atom.xml" 'emacs)
                           (list "http://sachachua.com/blog/category/emacs/feed" 'emacs)))

       (setq elfeed-search-filter "@2-weeks-ago +unread "))
   #+END_SRC

** bbdb
    People organization

    #+BEGIN_SRC emacs-lisp
      (use-package bbdb
        :ensure t
        :defer t
        :config
        (bbdb-initialize)
        (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))
    #+END_SRC

** emms
   This controls the music player.

   #+BEGIN_SRC emacs-lisp
     (use-package emms
       :ensure t
       :defer t
       :init
       (setq emms-directory (expand-file-name "emms" fn/cache-dir))
       :config
       (emms-standard)
       (emms-default-players)

       (setq emms-source-file-default-directory "~/Music/")

       (setq emms-info-asynchronously nil
             emms-playlist-buffer-name "*Music*")

       (setq emms-playlist-default-major-mode 'emms-playlist-mode)

       ;; emms-mark
       (require 'emms-mark)

       ;; emms-history
       (require 'emms-history)
       (emms-history-load)

       ;; emms-mode-line
       (require 'emms-mode-line)
       (emms-mode-line 1)

       (require 'emms-playing-time)
       (emms-playing-time 1)

       ;; emms-browser
       (require 'emms-browser)

       ;; emms-volume
       (emms-volume-minor-mode t)

       (setq emms-volume-mode-timeout 1)

       (define-key emms-volume-minor-mode-map (kbd "C-c -") 'emms-volume-minus)
       (define-key emms-volume-minor-mode-map (kbd "C-c +") 'emms-volume-plus))
   #+END_SRC

* Scripts
** Initial View
   My intial view when Emacs boots up

   #+BEGIN_SRC emacs-lisp
     ;; (setq initial-buffer-choice org-main-file)
     (setq org-agenda-window-setup 'current-window)

     (add-hook 'after-init-hook (lambda ()
                                  (message "Setting up initial view")
                                  (fn/find-main-org-file)
                                  (split-window-horizontally)
                                  (other-window 1)
                                  (org-todo-list)
                                  (other-window 1)))
   #+END_SRC

** Custom Emacs
   Bootstrap different configurations of Emacs for reviewing expert
   configurations and trying different modes

*** Configurable
    Let's bootstrap from different configurations dynamically

    #+BEGIN_SRC emacs-lisp
      (defun fn/bootstrap-from-dir ()
        (interactive)
        (setq new-home (read-directory-name "What Emacs config would you like to boot?" "~"))
        (fn/bootstrap-new-emacs new-home))
    #+END_SRC

*** Itself
    Load another copy of this configuration for vanity sake I suppose?

    #+BEGIN_SRC emacs-lisp
      (defun fn/bootstrap-itself ()
        (interactive)
        (fn/bootstrap-new-emacs nil))
    #+END_SRC

*** Experimental
    Just a random build for myself

    #+BEGIN_SRC emacs-lisp
      (setq fn/experimental-home "~/.fmacs.d/")

      (defun fn/bootstrap-experimental ()
        (interactive)
        (fn/bootstrap-new-emacs fn/experimental-home))
    #+END_SRC

*** Spacemacs
    The love child of Emacs and Vim, what does it hold?

    #+BEGIN_SRC emacs-lisp
      (setq fn/spacemacs-home "~/.spacemacs.d/")

      (defun fn/bootstrap-spacemacs ()
        (interactive)
        (fn/bootstrap-new-emacs fn/spacemacs-home))
    #+END_SRC

*** Zak Elep
    First known master and friend

    #+BEGIN_SRC emacs-lisp
      (setq fn/zak-elep-home "~/Fakespace/zakame.d/")

      (defun fn/bootstrap-zak-elep ()
        (interactive)
        (fn/bootstrap-new-emacs fn/zak-elep-home))
    #+END_SRC

*** Sacha Chua
    Inspiration for the configuration

    #+BEGIN_SRC emacs-lisp
      (setq fn/sacha-chua-home "~/Fakespace/sacha.d/")

      (defun fn/bootstrap-sacha-chua  ()
        (interactive)
        (fn/bootstrap-new-emacs fn/sacha-chua-home))
    #+END_SRC

*** Steve Purcell
    One of the known masters

    #+BEGIN_SRC emacs-lisp
      (setq fn/steve-purcell-home "~/Fakespace/purcell.d/")

      (defun fn/bootstrap-steve-purcell ()
        (interactive)
        (fn/bootstrap-new-emacs fn/steve-purcell-home))
    #+END_SRC

*** John Wiegley
    A master and maintainer of Emacs

    #+BEGIN_SRC emacs-lisp
      (setq fn/john-wiegley-home "~/Fakespace/wiegley.d/")

      (defun fn/bootstrap-john-wiegley ()
        (interactive)
        (fn/bootstrap-new-emacs fn/john-wiegley-home))
    #+END_SRC
** Window Layouts
   Split the windows into a nice four panel division. This works even
   well with [[golden-ratio]].

   #+BEGIN_SRC emacs-lisp
     (require 'dash)

     (defconst fmw/empty-buffer "*unchained buffer*"
       "A buffer to represent an empty one")

     (defun fmw/remap-window-buffers (buffer-remapper)
       "Reassigns the windows with new buffers taking a remapper function over the old ones"
       (lexical-let* ((current-buffers (mapcar 'window-buffer (window-list)))
                      (empty-buffer (if (get-buffer fmw/empty-buffer)
                                        (get-buffer fmw/empty-buffer)
                                      (generate-new-buffer fmw/empty-buffer)))
                      (new-buffers (funcall buffer-remapper current-buffers)))
         (mapc (lambda (pair)
                 (pcase-let ((`(,current-buffer . ,current-window) pair))
                   (when current-window
                     (set-window-buffer current-window
                                        (if current-buffer current-buffer
                                          empty-buffer))))
                 )
               (-zip-fill nil new-buffers (window-list)))))

     (defun fmw/restore-buffers (window-movement)
       "Restore buffers after doing a window layout"
       (lexical-let ((mover window-movement))
         (fmw/remap-window-buffers (lambda (old-buffers)
                                     (funcall window-movement)
                                     old-buffers))))

     (defun fmw/rotate-window-buffers (arg)
       "Rotate the buffers from window to the next like a clock"
       (interactive "P")
       (lexical-let ((rotation (if arg arg 1)))
         (fmw/remap-window-buffers (lambda (old-buffers)
                                     (-rotate rotation old-buffers)))))

     (defun fmw/four-part-horizontal-window-layout ()
       "Split the frame into four windows horizontally. I use this when I'm working in a project where the
        - upper left serves the main file
        - upper right serves as a secondary file
        - lower left serves as auxilliary or task buffer
        - lower right serves a project buffer"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-vertically)
                              (split-window-horizontally)
                              (other-window 2)
                              (split-window-horizontally)
                              (other-window 2))))

     (defun fmw/four-part-vertical-window-layout ()
       "Unlike with the =fn/four-way-horizontal-layout=, I use this more oftenly on dired to make file moving easier
        (and probably more)"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-vertically)
                              (split-window-horizontally)
                              (other-window 2)
                              (split-window-horizontally)
                              (other-window 2))))

     (defun fmw/three-part-left-window-layout ()
       "Like =fn/four-way-horizontal-layout= but fits a smaller screen namely my Raspberry Pi."
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-horizontally)
                              (other-window 1)
                              (split-window-vertically)
                              (other-window 2))))

     (defun fmw/three-part-vertical-window-layout ()
       "An layout seen at a meetup, seems interesting to work with.
        However, this is disables golden-ration-mode to maintain the delicate origami folds"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode nil)
                              (delete-other-windows)
                              (lexical-let* ((total-width (frame-width))
                                             (one-third-fold  (/ total-width 3)))
                                ;; Split the right window by a third, negative arguments huh.
                                (split-window-horizontally (- one-third-fold))
                                (split-window-horizontally (- one-third-fold))))))

     (defun fmw/four-part-equal-vertical-window-layout ()
       "This is for my music conversion but not that mind blowing to do"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode nil)
                              (delete-other-windows)

                              (split-window-horizontally)
                              (split-window-horizontally)
                              (other-window 2)

                              (split-window-horizontally)
                              (other-window 2))))

   #+END_SRC

** Utility Commands
   Some commands to get me here and there

   #+BEGIN_SRC emacs-lisp
     (defun fn/insert-date ()
       "Insert time at point, useful when you want to put a date.
        TODO: Would be useful if you can change formats too"
       (interactive)
       (let ((time-format "%Y-%m-%d"))
         (insert (format-time-string time-format))))

     (defun fn/save-and-kill-buffer ()
       "Save and kill the buffer in one command"
       (interactive)
       (call-interactively 'save-buffer)
       (call-interactively 'kill-this-buffer))
   #+END_SRC

** Coins.Ph API
   Some things to help me trade bitcoins, so this section might not be
   useful to anyone else.

   #+BEGIN_SRC emacs-lisp
     (require 's)

     (defconst fmc/coin-cli-file (expand-file-name "coiner-cli.py" "~/Fakespace/coins-watcher")
       "The cli file to interact with")

     (defconst fmc/coin-cli-executor "python"
       "CLI command to run the script")

     (defun fmc/parse-json (json-text)
       "My shiv of parsing json into alist, sadly json.el doesn't work in parsing weirdly"

       (lexical-let* ((json-regex "\'\\(\\w+\\)\':\s+\\([a-Z0-9.]+\\)[,\}]")
                      (json-matches (s-match-strings-all json-regex json-text))
                      (json-key-values (mapcar #'cdr json-matches)))
         (mapcar (lambda (pair)
                   (lexical-let* ((key (car pair))
                                  (value (cadr pair))
                                  (symbolic-key key)
                                  (symolic-value (string-to-number value)))
                     (cons symbolic-key symolic-value)))
                 json-key-values)))

     (defun fmc/call-cli (command &optional amount)
       "Main function to execute fmc commands"
       (lexical-let* ((coin-cli-buffer (find-file-noselect fmc/coin-cli-file)))
         (with-current-buffer coin-cli-buffer
           (lexical-let* ((command-args (list fmc/coin-cli-executor fmc/coin-cli-file))
                          (action-arg (list command))
                          (amount-args (list "-a" amount))
                          (base-args (append command-args action-arg))
                          (args (if amount (append base-args amount-args)
                                  base-args))
                          (cli-output (apply 'fn/run-command args)))
             (fmc/parse-json (format "\"%s\"" cli-output))))))

     (defun fmc/get-quote ()
       "Get quote from the bitcoin site"
       (interactive)
       (fmc/call-cli "quote"))

     (defun fmc/buy-coin ()
       "Buy coins"
       (interactive)
       (lexical-let* ((amount (read-number "Enter amount: "))
                      (current-quote (fmc/call-cli "quote"))
                      (current-buy (cdr (assoc "buy" current-quote)))
                      (current-value (/ amount current-buy))
                      (confirm-action (yes-or-no-p (format "Are you sure you to buy %f at %f" amount current-buy))))
         (when confirm-action
           (fmc/call-cli "buy" amount)
           (message "Successfully bought %f at %f amounting to %f" amount current-buy current-value))))

     (defun fmc/sell-coin ()
       "Sell coins"
       (interactive)
       (lexical-let* ((amount (read-number "Enter amount: "))
                      (current-quote (fmc/call-cli "quote"))
                      (current-sell (cdr (assoc "sell" current-quote)))
                      (current-value (* amount current-sell))
                      (confirm-action (yes-or-no-p (format "Are you sure you to sell %f at %f amounting to %f" amount current-sell current-value))))
         (when confirm-action
           (fmc/call-cli "sell" amount)
           (message "Successfully sold %f at %f" amount current-value))))
   #+END_SRC

** starup and shutdown hook
   Small script to update my org files

   #+BEGIN_SRC emacs-lisp
     (defun fn/startup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library && git pull origin master"))

     (defun fn/cleanup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library\
      && git add diary/*\
      && git commit -a -m \"Home Update\"\
      && git push origin master"))

     (define-key global-map "\C-cms" 'fn/startup)
     (define-key global-map "\C-cmc"'fn/cleanup)
   #+END_SRC

** projectile-init script
   This script runs .projectile-hook.el in each project root to ease development

   #+BEGIN_SRC emacs-lisp
     (defun fn/load-projectile-hook ()
       (interactive)
       (mapcar (lambda (project)
        (setq fn/current-project (expand-file-name project))
        (load
         (expand-file-name ".projectile-hook" fn/current-project)
         t))
 projectile-known-projects))
   #+END_SRC

** Create media diary
   A personal script to bundle my journal, recordings and images into one org file. Not to be consumed by anyone else

   #+BEGIN_SRC emacs-lisp
     (require 's)


     (defun fmd/get-document-property (key &optional selected-buffer)
       "Get the property of the document which starts with #+PROPERTY"
       (with-current-buffer (if selected-buffer selected-buffer (buffer-name))
         (lexical-let* ((property-regex (format  "\#\\+%s:\s+\\(.*\\)" key))
                        (property-match (s-match property-regex (buffer-substring-no-properties (point-min) (point-max))))
                        (property (if property-match (cadr property-match)
                                    nil)))
           property)))

     (defun fmd/get-title (&optional selected-buffer)
       "Get the #+TITLE value of the current buffer"
       (fmd/get-document-property "TITLE" selected-buffer))


     (defconst fmd/md-root "/media/veracrypt1/media-diary"
       "The media diary directory")

     (defconst fmd/md-summary-file-name "media-diary.org"
       "The media diary directory")

     (defconst fmd/md-summary-file (expand-file-name  "media-diary.org" fmd/md-root)
       "The media diary directory")

     (defconst fmd/md-title "Media Diary"
       "Main header of the file")

     (defconst fmd/md-note-title "Notes"
       "Note header of the file")

     (defconst fmd/md-journal-title "Journal"
       "Journal header of the file")

     (defconst fmd/md-media-title "Media"
       "Journal header of the file")


     (defconst fmd/md-datetime-format "%b. %d, %Y"
       "Time format for the compilation")

     (defconst fmd/md-audio-datetime-format "%b. %d, %Y %T : Recording"
       "Audio time format for the compilation")

     (defconst fmd/md-photo-datetime-format "%b. %d, %Y %T : Photograph"
       "Photo format for the compilation")

     (defconst fmd/md-summary-default-text "Something profound happened but I forgot like Dory"
       "The default text to be displayed")


     (defconst fmd/md-journal-dir-name "journal"
       "The journal directory source")

     (defconst fmd/md-audio-dir-name "audio"
       "The audio directory source")

     (defconst fmd/md-photo-dir-name "photo"
       "The photo directory source")


     (defconst fmd/md-photo-extension "jpg"
       "The photo file extension")

     (defconst fmd/md-audio-extension "wav"
       "The audio file extension")


     (defconst fmd/md-journal-dir (expand-file-name fmd/md-journal-dir-name fmd/md-root)
       "The journal directory")

     (defconst fmd/md-audio-dir (expand-file-name fmd/md-audio-dir-name fmd/md-root)
       "The audio directory")

     (defconst fmd/md-photo-dir (expand-file-name fmd/md-photo-dir-name fmd/md-root)
       "The audio directory")

     (defun fmd/parse-file-parts (file)
       "Parse the file name compatible for the media diary file"
       (lexical-let* ((file-regex  "\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)?_?\\([0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}+\\)?\\( - \\)?\\(.+\\)?\\.\\(.+\\)")
                      (filename (file-name-nondirectory file))
                      (file-matches (s-match-strings-all file-regex filename))
                      (file-match (car file-matches)))
         (message filename)
         (lexical-let* ((file-date (nth 1 file-match))
                        (file-time (nth 2 file-match))
                        (file-title (nth 4 file-match))
                        (file-extension (nth 5 file-match)))
           (lexical-let* ((parts (list))
                          (time-part (if file-time (s-replace "-" ":" file-time)
                                       "00:00:00"
                                       ))
                          (date-raw (concat file-date " " time-part))
                          (datetime-part (apply 'encode-time (parse-time-string date-raw))))
             (setq parts (plist-put parts 'datetime datetime-part))
             (setq parts (plist-put parts 'title file-title))
             (setq parts (plist-put parts 'extension file-extension))
             parts))))


     (defun fmd/insert-org-header (header)
       "Insert header"
       (org-insert-heading t nil t)
       (insert header))

     (defun fmd/insert-org-subheader (subheader)
       "Insert subheader"
       (end-of-buffer)
       (org-insert-heading t nil t)
       (insert subheader)
       (org-demote))

     (defun fmd/insert-org-link (link title)
       "Insert link"
       (end-of-buffer)
       (org-insert-heading t)
       (org-insert-link nil link title))

     (defun fmd/insert-document-option (key value)
       "Insert document file option"
       (insert (format "#+%s: %s\n" key value)))

     (defun fmd/insert-file-headers (start-date)
       "Insert default file headers"
       (interactive)
       (fm/insert-org-gpg-headers)

       (end-of-visual-line)
       (newline)

       (fmd/insert-document-option "TITLE" (format "Media Diary of %s"
    u                                               (format-time-string "%b. %Y" start-date)))
       (fmd/insert-document-option "DATE" (format-time-string "%D" start-date))
       (fmd/insert-document-option "STARTUP" "content")
       (fmd/insert-document-option "OPTIONS" "toc:nil"))


     (defun fmd/filter-files (directory prefix extension)
       "Get the files based on prefix and extension"
       (directory-files directory nil
                        (format-message "%s-.*\\.%s$" prefix extension)))

     (defun fmd/once (f)
       "Invoke a function only once, useful inside a loop"
       (lexical-let ((g f)
                     (is-invoked nil))
         (lambda (&rest args)
           (if is-invoked nil
             (progn
               (setq is-invoked t)
               (apply g args))))))


     (defun fmd/compile-media-diary ()
       "Compile the media diary"
       (interactive)
       (lexical-let* ((md-prefix (read-input "Input year-month[yyyy-mm]:" "2016-06"))
                      (md-start-date
                       (lexical-let ((start-date-text (format "%s-01 00:00:00" md-prefix)))
                         (apply 'encode-time (parse-time-string start-date-text)))))
         (lexical-let* ((render-header
                         (lambda ()
                           (fmd/insert-file-headers)
                           (fmd/insert-org-header fmd/md-title)))
                        (render-note-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-note-title)
                           (newline-and-indent)
                           (insert fmd/md-summary-default-text)))
                        (render-journal-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-journal-title)
                           (lexical-let* ((journal-files (fmd/filter-files fmd/md-journal-dir md-prefix "org"))
                                          (demote-first (fmd/once (lambda () (org-demote)))))
                             (mapc (lambda (journal-file-name)
                                     (lexical-let* ((journal-file (expand-file-name journal-file-name fmd/md-journal-dir))
                                                    (journal-piece (fmd/parse-file-parts journal-file-name))
                                                    (journal-time (plist-get journal-piece 'datetime))
                                                    (journal-base-title (format-time-string fmd/md-datetime-format journal-time))
                                                    (journal-title
                                                     (progn
                                                       (lexical-let ((journal-buffer (find-file-noselect journal-file))
                                                                     (journal-buffer-title nil))
                                                         (setq journal-buffer-title (fmd/get-title journal-buffer))
                                                         (kill-buffer journal-buffer)
                                                         journal-buffer-title)))
                                                    (journal-full-title
                                                     (format "%s - %s" journal-base-title journal-title)))
                                       (fmd/insert-org-link (concat "file:" fmd/md-journal-dir-name "/" journal-file-name)
                                                            journal-full-title)
                                       (funcall demote-first)
                                       (org-set-property "CREATED_ON"
                                                         (format-time-string "%F %T" journal-time))))
                                   journal-files))))
                        (render-media-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-media-title)

                           (lexical-let* ((photo-files (fmd/filter-files fmd/md-photo-dir md-prefix fmd/md-photo-extension))
                                          (audio-files (fmd/filter-files fmd/md-audio-dir md-prefix fmd/md-audio-extension))
                                          (media-files
                                           (sort (append photo-files audio-files)
                                                 (lambda (left right)
                                                   (lexical-let* ((result
                                                                   (compare-strings
                                                                    (file-name-sans-extension left) nil nil
                                                                    (file-name-sans-extension right) nil nil
                                                                    nil)))
                                                     (if (booleanp result) t
                                                       (if (> result 0) nil t))))))
                                          (demote-first (fmd/once (lambda () (org-demote)))))

                             (intern-soft "photo")
                             (intern-soft "audio")

                             (mapc (lambda (media-file)
                                     (lexical-let* ((media-piece (fmd/parse-file-parts media-file) )
                                                    (media-time (plist-get media-piece 'datetime))
                                                    (media-title (plist-get media-piece 'title))
                                                    (media-extension (plist-get media-piece 'extension))
                                                    (media-type (if (string-equal media-extension fmd/md-audio-extension)
                                                                    'audio 'photo))
                                                    (media-time-format (if (eq media-type 'audio)
                                                                           fmd/md-audio-datetime-format
                                                                         fmd/md-photo-datetime-format))
                                                    (media-dir-name (if (eq media-type 'audio)
                                                                        fmd/md-audio-dir-name fmd/md-photo-dir-name))
                                                    (media-base-title (format-time-string media-time-format media-time))
                                                    (media-full-title (if media-title (format "%s - %s" media-base-title media-title)
                                                                        media-base-title)))
                                       (fmd/insert-org-link (concat "file:" media-dir-name "/" media-file)
                                                            media-full-title)
                                       (funcall demote-first)
                                       (org-set-property "CREATED_ON"
                                                         (format-time-string "%F %T" media-time))))
                                   media-files)))))

           (find-file fmd/md-summary-file)

           (funcall render-header)
           (funcall render-note-section)
           (funcall render-journal-section)
           (funcall render-media-section)

           (beginning-of-buffer)
           (org-set-startup-visibility)
           (save-buffer))))
   #+END_SRC

** Open standard buffers
   Nice to see the standard buffers

   #+BEGIN_SRC emacs-lisp
     (defun fn/open-message-buffer ()
       (interactive)
       (switch-to-buffer "*Messages*"))
   #+END_SRC

** Open config file
   This is just a convenience to open this config file

   #+BEGIN_SRC emacs-lisp
     (defun fn/find-config-file ()
       (interactive)
       (find-file (expand-file-name "config.org" user-emacs-directory)))
   #+END_SRC

* Custom Bindings
  Here is where all the key binding I mapped to

  #+BEGIN_SRC emacs-lisp
    (defun fn/trigger-key (key)
      "Returns a function that triggers the function bound by the key"
      (lexical-let* ((key-trigger key)
                     (trigger (lambda ()
                                (interactive)
                                (let ((key-command (key-binding key-trigger)))
                                  (cond
                                   (key-command
                                    (message "Triggering %s" key-command)
                                    (command-execute key-command))
                                   (t
                                    (message "No key bound to %s" key-trigger)))))))
        trigger))

    ;; Motion
    ;; (global-set-key (kbd "C-!") (fn/trigger-key (kbd "C-RET")))
    ;; (global-set-key (kbd "M-!") (fn/trigger-key (kbd "M-RET")))


    ;; Keys
    (global-set-key (kbd "M-n") (fn/trigger-key (kbd "DEL")))

    ;; Search
    (global-set-key (kbd "C-c n C-s") 'fn/isearch-forward-normally)
    (global-set-key (kbd "C-c n C-r") 'fn/isearch-backward-normally)


    ;; Buffers
    (global-set-key (kbd "C-c n k") 'kill-this-buffer)
    (global-set-key (kbd "C-c n C-k") 'fn/save-and-kill-buffer)

    ;; Windows
    (global-set-key (kbd "C-c m w h") 'fmw/four-part-horizontal-window-layout)
    (global-set-key (kbd "C-c m w v") 'fmw/four-part-vertical-window-layout)
    (global-set-key (kbd "C-c m w t") 'fmw/three-part-left-window-layout)
    (global-set-key (kbd "C-c m w 3") 'fmw/three-part-vertical-window-layout)
    (global-set-key (kbd "C-c m w 4") 'fmw/four-part-equal-vertical-window-layout)
    (global-set-key (kbd "C-c m w r") 'fmw/rotate-window-buffers)

    ;; System Buffers
    (global-set-key (kbd "C-c m b m") 'fn/open-message-buffer)

    ;; Shell
    (global-set-key (kbd "C-c n s") 'shell)

    ;; Commands
    (global-set-key (kbd "C-x C-x") (fn/trigger-key (kbd "M-x")))

    ;; Files
    (global-set-key (kbd "C-c m b c") 'fn/find-config-file)
    (global-set-key (kbd "C-c m b o") 'fn/find-main-org-file)

    ;; Functions
    (global-set-key (kbd  "C-c m r s") 'fn/startup)
    (global-set-key (kbd  "C-c m r c") 'fn/cleanup)

    ;; Custom Emacs
    (global-set-key (kbd  "C-c m e e") 'fn/bootstrap-experimental)
    (global-set-key (kbd  "C-c m e s") 'fn/bootstrap-spacemacs)
    (global-set-key (kbd  "C-c m e f") 'fn/bootstrap-from-dir)

    ;; Review Custom Emacs
    (global-set-key (kbd  "C-c m e p") 'fn/bootstrap-steve-purcell)
    (global-set-key (kbd  "C-c m e z") 'fn/bootstrap-zak-elep)
    (global-set-key (kbd  "C-c m e c") 'fn/bootstrap-sacha-chua)
    (global-set-key (kbd  "C-c m e j") 'fn/bootstrap-john-wiegley)
  #+END_SRC

* Sandbox

** avy
   Interesting but I hasn't stuck with me

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :defer t
       :bind (("C-:" . avy-goto-char))
       :config
       (avy-setup-default))
   #+END_SRC

** ssniper
   Swiper no swiping

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :ensure t
       :defer t)
   #+END_SRC
** ace-window
   Not really interested but doing it for bug fixes

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :bind (("M-p" . ace-window)))
   #+END_SRC
** f3

   #+BEGIN_SRC emacs-lisp
     (use-package f3
       :ensure t
       :defer t)
   #+END_SRC

** vdiff

   #+BEGIN_SRC emacs-lisp
     (use-package vdiff
       :config
       (define-key vdiff-mode-map (kbd "C-c") vdiff-mode-prefix-map))
   #+END_SRC
* Reference
  - [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha Chua]]: I took her configuration as a base to make this org configuration
  - [[https://github.com/zakame/.emacs.d][Zak Elep]]: One of the master and first known ally.
