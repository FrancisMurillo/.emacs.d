#+TITLE: Francis Murillo's Emacs configuration
#+AUTHOR: Francis Murillo
#+OPTIONS: toc:4 h:4
* Introduction
** If I Forget
   No words can describe my awe with Emacs and continue to do so. A text
   editor with a lisp interpreter, it's concept is so simple and
   sublime. What joy.

   I remember starting Emacs seriously at around August of 2015. Before
   then, I picked it up lightly and thought(not use) about it; but what
   really drove me to use it is.

   - Growth ::
   I was using an IDE before and somebody told me that GUIs change but
   the shell remains the same. I found myself over time exploring
   keyboard shortcuts, better terminals and Emacs(or maybe vi).
   - Lightweight ::
   I had a crappy laptop that always needed to be plugged, had a lot
   dead pixels, and closes when it overheats; I needed something that
   would work with what I had.
   - Linux ::
   Moving from Windows to Linux forced me to reevaluate the software I
   used. Adopting a new philosophy and OS pushed me in the right direction

   Whatever the reason might have been. I just want to say I'm a happy
   Emacs user and I find comfort and joy in hearing other people talk
   and share about it.

** About My Configuration
   I use org-babel as my configuration file once I heard you can do so.
   Splitting the configuration to multiple files was the plan but the
   way it weaves nicely to documentation immediately drew me in.

   You can load this with =(org-babel-load-file "/path/to/file")= if you
   need to reload any changes or just take any snippet you want. I do my
   best to make my configuration copy friendly on different environments.

   Or with an function instead

   #+BEGIN_SRC emacs-lisp :block-id 45501e2d-cc25-e41b-bceb-8c40d2bf7450
     (defun fn/reload-config ()
       "Reload my configuration again"
       (interactive)
       (org-babel-load-file
        (expand-file-name fn/config-file user-emacs-directory)))

     (defun fn/dired-emacs-dir ()
       "Quickly visit emacs directory"
       (interactive)
       (dired user-emacs-directory))
   #+END_SRC

* Bootstrap
** Lexical Binding
   This makes it so that the file that is produced from tangling this
   file uses lexical scoping and all succeeding files

   #+BEGIN_SRC emacs-lisp :block-id 857ce296-7ba0-9163-25e5-ce16c40bae9c
     (setq lexical-binding t)
   #+END_SRC

** Package Sources
   Add package sources if not present and reload, this should have been added in the =init.el= but checked here again for completion.

   #+BEGIN_SRC emacs-lisp :block-id 8ec65bd3-dc31-0455-99d0-301267fdd059
     (defconst fn/package-archives
       (list
        (cons "gnu" "http://elpa.gnu.org/packages/")
        (cons "org" "http://orgmode.org/elpa/")
        (cons "melpa" "http://melpa.org/packages/")
        (cons "melpa-stable" "https://stable.melpa.org/packages/"))
       "List of my packages")

     (mapc
      (lambda (package-archive)
        (pcase-let ((`(,name . ,_) package-archive))
          (unless (assoc-default name package-archives)
            (add-to-list 'package-archives package-archive))))
      fn/package-archives)

   #+END_SRC

** Package Manager
   The package manager of this whole configuration

   #+BEGIN_SRC emacs-lisp :block-id 363333a0-026e-ebda-9692-2dfed8316172
     (require 'use-package)

     (setq use-package-verbose t
           use-package-minimum-reported-time 0.025
           use-package-always-defer t)
   #+END_SRC

** Org Src
   Configuration for using the tangling nature of this configuration

   #+BEGIN_SRC emacs-lisp :block-id 0e5504a8-93dd-d412-b479-a18198b0a9f2
     (setq org-confirm-babel-evaluate nil
           org-src-fontify-natively t
           org-src-tab-acts-natively t)
   #+END_SRC

** Constants
   Some constants to work with

   #+BEGIN_SRC emacs-lisp :block-id 0830626b-8d70-6934-e7ed-d5b0a42c34e2
     (defconst fn/minute-per-second 60
       "Obviously converting minutes to seconds")

     (defconst fn/cache-dir-name ".cache"
       "Place every moving file in this directory")

     (defconst fn/cache-dir (expand-file-name fn/cache-dir-name user-emacs-directory)
       "Every cached or moving file should be here like with Spacemacs")

     (make-directory fn/cache-dir t)

     (defconst fn/lib-dir-name "lib"
       "External non-standard files directory")

     (defconst fn/lib-dir (expand-file-name fn/lib-dir-name user-emacs-directory)
       "External library directory")

     (make-directory fn/lib-dir t)


     (defconst fn/system-dir-name "system"
       "System library dependencies directory")

     (defconst fn/system-dir (expand-file-name fn/system-dir-name fn/lib-dir)
       "System library for external files.")

     (make-directory fn/system-dir t)


     (defconst fn/font-dir-name "fonts"
       "Font dependencies directory")

     (defconst fn/font-dir (expand-file-name fn/font-dir-name fn/system-dir)
       "External font directory.")

     (make-directory fn/font-dir t)


     (defconst fn/extra-dir-name "extra"
       "Anything under the sun you can put here")

     (defconst fn/extra-dir (expand-file-name fn/extra-dir-name user-emacs-directory)
       "Anything under the sun directory")

     (make-directory fn/extra-dir t)


     (defconst fn/custom-module-dir-name "modules"
       "Custom elisp packages directory name")

     (defconst fn/custom-module-dir (expand-file-name fn/custom-module-dir-name fn/library-dir)
       "Custom elisp packages directory")

     (make-directory fn/custom-module-dir t)

     (defconst fn/custom-script-dir-name "scripts"
       "Custom elisp script directory name")

     (defconst fn/custom-script-dir (expand-file-name fn/custom-script-dir-name fn/library-dir)
       "Custom elisp script directory")


     (make-directory fn/custom-script-dir t)

     (add-to-list 'load-path fn/custom-script-dir)


     (defconst fn/external-module-dir (expand-file-name "Modules" "~")
       "My external module directory name.")

     (make-directory fn/external-module-dir t)
   #+END_SRC

* Basic Setup
  Basic configurations anyone can do for vanilla Emacs

** Personal Information
   Just some things that relate to me

   #+BEGIN_SRC emacs-lisp :block-id fb2d2f9a-2897-33af-e228-d088d9e8c242
     (defconst fn/personal-file-name "personal.el"
       "Personal configuration file name")

     (defconst fn/personal-file (expand-file-name fn/personal-file-name user-emacs-directory)
       "Personal configuration file to be loaded. This is symlinked in another private repository")

     (load fn/personal-file t)
   #+END_SRC

** Customization
   Basis for configuration

   #+BEGIN_SRC emacs-lisp :block-id 8e36f9f4-4f43-646d-eb41-4ff7d425d03e
     ;; Don't really care about custom file
     (setq custom-file (expand-file-name "custom-file.el" fn/cache-dir))


     (defgroup fn nil
       "My namespace for customizing my configuration")


     ;;* Custom Prefixes
     ;; Anything that just calls normal commands
     ;; Binding: C-c n
     (define-prefix-command 'fn-standard-prefix-map)

     ;; Anything that I worked experimentally on
     ;; Binding: C-c m
     (define-prefix-command 'fn-custom-prefix-map)

     ;; Anything that is important while I am working on something
     ;; Binding: C-c C-m / C-c C-n / C-c b / C-C C-b
     (define-prefix-command 'fn-work-prefix-map)


     (defun fn/make-prefixed-keymap (key &optional base-keymap)
       "Make a sparse keymap that is already prefixed by KEY.
     It also accepts a BASE-KEYMAP if you are prefixing an existing key map."
       (let* ((prefixed-keymap (make-sparse-keymap))
              (target-keymap (or base-keymap
                                 prefixed-keymap)))
         (define-key target-keymap key prefixed-keymap)
         prefixed-keymap))


     ;;* Custom Key Sequences
     (defconst fn/standard-key-sequence (kbd "C-c n")
       "My standard key sequence.")

     (defconst fn/custom-key-sequence (kbd "C-c m")
       "My custom key sequence.")

     (defconst fn/work-key-sequence (kbd "C-c C-m")
       "My work key sequence.")

     (defun fn/make-work-keymap (&optional base-keymap)
       "Just `fn/make-prefixed-keymap` with `fn/work-key-sequence`."
       (fn/make-prefixed-keymap fn/work-key-sequence base-keymap))


     (global-set-key (kbd "C-c n") fn-standard-prefix-map)
     (global-set-key (kbd "C-c m") fn-custom-prefix-map)
   #+END_SRC

** Startup
   Everything related to the startup state

   #+BEGIN_SRC emacs-lisp :block-id e3857d2d-0e50-e886-7186-cd58a7fd80ee
     (defconst fn/gc-cons-threshold (* 256 1024 1024)
       "A high limit for garbage colection.")

     (setq gc-cons-threshold fn/gc-cons-threshold) ;; High memory for Emacs


     (defvar fn/my-lightning (concat
                         (propertize " MY LIGHTNING "
                                     'face '(:background "#ff1e02" :foreground "#110200"
                                                         :box (:line-width 0 :color "#ff1e02")))
                         "...")
       "A reference to continue?987654321.
     May I accept the lightning.")

     (defvar fn/my-prayer (format "%s %s"
                             fn/my-lightning
                             (concat
                              (propertize " MY PRAYER "
                                          'face '(:background "#ffffff" :foreground "#121212"
                                                              :box (:line-width 0 :color "#ffffff")))
                              "..."))
       "The closing message for garbage collection.
     May I be lift up.")

     (setq garbage-collection-messages nil) ;; My lightning... my prayer

     (defun fn/continue-gc (orig-gc &rest args)
       "Wrap some message with ORIG-GC."
       (let ((start-time (current-time)))
         (if (minibuffer-prompt)
             (apply orig-gc args)
           (prog2
               (message fn/my-lightning)
               (apply orig-gc args)
             (message "%s %s"
                      fn/my-prayer
                      (format "(%.4fs)"
                              (float-time (time-subtract (current-time) start-time))))))))

     (advice-add 'garbage-collect :around #'fn/continue-gc)


     ;; Since the limit is high, it might never gc. So if I am idle, do some cleanup.
     (run-with-idle-timer 30 t #'garbage-collect)


     (setq inhibit-startup-screen t ;; No need for the awesome startup screen.
           initial-scratch-message nil)
   #+END_SRC

** Environment
   Some environment configuration.

   #+BEGIN_SRC emacs-lisp :block-id e0adbf59-f7d8-f4c2-281d-4cabc523a47e
     (set-language-environment "UTF-8") ;; UTF-8 should be the enivorment

     (setq visible-bell t) ;; Visual bell for me since audio is a bit more distractive

     (fset 'yes-or-no-p 'y-or-n-p) ;; Y or N
   #+END_SRC

** Backups
   Backups are good, just annoying when things are good

   #+BEGIN_SRC emacs-lisp :block-id 99737619-18ed-431b-bca5-4d2cce5f20fe
     (defconst fn/backup-dir-name "backups/"
       "Backup directory name")

     (defconst fn/backup-dir (expand-file-name fn/backup-dir-name fn/cache-dir)
       "Backup directory")


     (defconst fn/auto-save-dir-name "auto-save-list/"
       "Auto save directory name")

     (defconst fn/auto-save-dir (expand-file-name fn/auto-save-dir-name fn/cache-dir)
       "Auto save directory")


     (setq auto-save-timeout 15
           auto-save-list-file-name fn/auto-save-dir

           delete-old-versions t
           version-control t
           vc-make-backup-files t
           backup-by-copying t
           kept-new-versions 10
           kept-old-versions 50

           backup-directory-alist
           (list
            (cons "." fn/backup-dir))

           auto-save-list-file-prefix
           fn/auto-save-dir

           auto-save-file-name-transforms
           (list
            (list ".*" fn/auto-save-dir t)))
   #+END_SRC

** History
   Save minibuffer history

   #+BEGIN_SRC emacs-lisp :block-id e5b95f5c-2062-2e1d-981b-a709f39da9d7
     (defconst fn/savehist-file-name "savehist"
       "Save history file name")

     (defconst fn/savehist-file (expand-file-name fn/savehist-file-name fn/cache-dir)
       "Save history file")


     (setq savehist-file fn/savehist-file

           history-length t
           history-delete-duplicates t

           savehist-save-minibuffer-history t
           savehist-additional-variables (list 'kill-ring
                                               'search-ring
                                               'regexp-search-ring))

     (savehist-mode t)


     (setq bookmark-file (expand-file-name "bookmarks" fn/cache-dir)
           bookmark-default-file (expand-file-name "bookmarks-default" fn/cache-dir))


   #+END_SRC

** Editing
   Some editing configurations

   #+BEGIN_SRC emacs-lisp :block-id b761153a-62c3-05c4-7231-89856bbae249
     (setq whitespace-line-column 10000 ;; No line too long font locking please

           ;; C-M-a should go to the beginning of a sentence
           sentence-end-double-space nil

           require-final-newline t)

     ;; I like tabs but they should just be converted to spaces for equality
     (setq-default indent-tabs-mode nil)

     (add-hook 'makefile-mode 'indent-tabs-mode)
   #+END_SRC

** Bookmark
   Bookmark configuration

   #+BEGIN_SRC emacs-lisp :block-id 3730e40d-63fb-3b03-1830-a85c557fe522
     (setq bookmark-default-file (expand-file-name "bookmarks" fn/cache-dir)
        bookmark-save-flag t)
   #+END_SRC

** Search
   You must have this setup, it's like butter and you're the bread.

   #+BEGIN_SRC emacs-lisp :block-id 7d1d92eb-2c93-53fe-e24f-dfcb94509754
     (defconst fn/default-search-whitespace-regexp search-whitespace-regexp
       "Store the default whitespace option")

     (setq search-highlight t)

     ;; This ignores whitespace when searching
     (setq-default search-whitespace-regexp ".*?")


     (defun fn/isearch-forward-normally ()
       "This custom command does i-search without the whitespace skips,
        the vanilla behavior"
       (interactive)
       (let ((search-whitespace-regexp fn/default-search-whitespace-regexp))
         (isearch-forward)))


     (defun fn/isearch-backward-normally ()
       "Ditto with fn/isearch-foward-normally except backwards."
       (interactive)
       (let ((search-whitespace-regexp fn/default-search-whitespace-regexp))
         (isearch-backward)))
   #+END_SRC

** Coding
   Some programming configuration that make sense

   #+BEGIN_SRC emacs-lisp :block-id 0654a092-0c78-f18e-e9bb-515041e26a3a
     (setq save-interprogram-paste-before-kill t)

     ;; Please indent after newline to maintain sanity
     (global-set-key (kbd "RET") 'newline-and-indent)


     (make-variable-buffer-local
      (defvar fn/whitespace-cleanup-on-save t
        "When non-nil, delete trailing whitespace on save"))

     (add-to-list 'safe-local-variable-values '(fn/whitespace-cleanup-on-save))

     (defun fn/delete-trailing-whitespace-on-save ()
       "Delete trailing whitespace on save."
       (when fn/whitespace-cleanup-on-save
         (with-current-buffer (current-buffer)
           (message "Deleting trailing whitespace in %s" (current-buffer))
           (delete-trailing-whitespace (point-min) (point-max)))))

     ;; (add-hook 'before-save-hook 'fn/delete-trailing-whitespace-on-save)

     (defun fn/disable-delete-trailing-whitespace-on-save ()
       "Disable `fn/delete-trailing-whitespace-on-save' for a specific mode."
       (setq-local fn/whitespace-cleanup-on-save nil))

     (add-hook 'makefile-mode-hook 'fn/disable-delete-trailing-whitespace-on-save t)


     (temp-buffer-resize-mode t)

     (setq compilation-window-height 10
           compilation-scroll-output 'first-error
           compilation-ask-about-save nil)
   #+END_SRC

** Mouse
   I better be a cat

   #+BEGIN_SRC emacs-lisp :block-id 218a476d-ce2f-a92a-cf26-54576622e00a
     (mouse-avoidance-mode 'cat-and-mouse)
   #+END_SRC
** Others
   Some other configurations that I can't classify yet

   #+BEGIN_SRC emacs-lisp :block-id 0bf9bac3-a449-98ef-8936-fa7e6d1f4205
     (setq auth-sources (list (list  :source "~/.authinfo.gpg")))

     (setq browse-url-browser-function 'browse-url-generic
           browse-url-generic-program "conkeror")
   #+END_SRC
** Commands
   Unlock some commands I need

   #+BEGIN_SRC emacs-lisp :block-id 2ff0370d-50fa-3ca8-7b00-e9e8b9a3e850
     (put 'narrow-to-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC
* Dependencies
  Everything needed to support this more complex configurations

** dash
   Functionally elisp

   #+BEGIN_SRC emacs-lisp :block-id fd8d45fa-ef70-5322-8ec6-04d8fc1e13d5
     (use-package dash
       :ensure t)

     (use-package dash-functional
       :ensure t
       :after dash)
   #+END_SRC

** async
   Not really builtin but should be

   #+BEGIN_SRC emacs-lisp :block-id bfae8c52-4b79-e605-1b26-7da4ae8eeade
     (use-package async
       :ensure t)
   #+END_SRC

** s
   A string library, everyone needs that

   #+BEGIN_SRC emacs-lisp :block-id 80387d51-f9a0-25ab-75ea-a36947dbeb03
     (use-package s
       :ensure t)
   #+END_SRC
** f
   File manipulation library for Emacs

   #+BEGIN_SRC emacs-lisp :block-id bad34a22-8eab-ea19-6a8b-da30a258fff8
     (use-package f
       :ensure t)
   #+END_SRC

** unicode-fonts
   Unicode is an required aesthetic

   #+BEGIN_SRC emacs-lisp :block-id 0e75a034-c275-fe20-35db-c9d18176e817
     (use-package pcache ;; Required by unicode-fonts
       :ensure t
       :init
       ;; Mentioned here to redirect directory
       (setq pcache-directory (expand-file-name "pcache/" fn/cache-dir)))

     (use-package unicode-fonts
       :ensure t
       :demand t
       :config
       (unicode-fonts-setup))
   #+END_SRC

** persistent-soft
   Nice to have some persistence.

   #+BEGIN_SRC emacs-lisp :block-id 5ae1d8f2-f9b7-4eff-d903-020af5b5a9b3
     (use-package persistent-soft
       :ensure t
       :demand t
       :config
       (defconst fn/persistence-location "custom-persistence"
         "My persistence location.")

       (defvar fn/persistence-managed-symbols (list)
         "Managed persistent symbols.")


       (defun fn/persistence-store (key value)
         "Just a wrapper for `persistent-soft-store' with KEY and VALUE,
     location is defined by `fn/-persistence-location'."
         (persistent-soft-store key value fn/persistence-location))

       (defun fn/persistence-fetch (key)
         "Another wrapper for `persistent-soft-fetch' with KEY,
     and location is defined by `fn/custom-persistence-file'."
         (persistent-soft-fetch key fn/persistence-location))

       (defun fn/persistence-flush ()
         "Store all symbols in `fn/persistence-managed-symbols' before Emacs closes."
         (mapc
          (lambda (symbol)
            (ignore-errors
              (fn/persistence-store symbol (symbol-value symbol))))
          fn/persistence-managed-symbols))

       (add-hook 'kill-emacs-hook #'fn/persistence-flush)

       (defun fn/persistence-manage-symbol (symbol)
         (set symbol (fn/persistence-fetch symbol))
         (push symbol fn/persistence-managed-symbols)))
   #+END_SRC

** exec-path-from-shell
   The path variable from the shell is need to run commands

   #+BEGIN_SRC emacs-lisp :block-id ad0dfafc-912b-1abc-12bb-fa6c5bbea607
     (defconst fn/exec-path-from-shell-package-dir
       (expand-file-name "exec-path-from-shell/" fn/custom-module-dir)
       "Htmlize package dir")

     (use-package exec-path-from-shell
       :ensure t
       :if (not (eq system-type 'windows-nt)) ;; Sorry Windows
       :demand t
       :config
       (setq exec-path-from-shell-variables
          (list
           "PATH" "MANPATH"
           "PROMPT" "PS1"

           "JAVA_HOME" "ECLIPSE_HOME")
          exec-path-from-shell-arguments
          (list
           "-l" "-i"))

       (exec-path-from-shell-initialize))
   #+END_SRC

** execute-shell
   Some external commands might be required, so gotta check them if they
   exist or install them if you have the time

   #+BEGIN_SRC emacs-lisp :block-id eb59aa17-8976-e43a-85b1-19916b2f9105
     (defun fn/run-command (command &rest args)
       ;; Calls the process *command* and gets it's output, nil if there is an error"
       (condition-case ex
           (with-temp-buffer
             (let ((string-args (mapcar (lambda (arg)
                                          (cond
                                           ((numberp arg) (number-to-string arg))
                                           (t arg)))
                                        args)))
               (apply 'call-process (append
                                     (list command nil t nil)
                                     string-args))
               (string-trim (buffer-string))))
         ('error nil)))
   #+END_SRC

** htmlize
   For exporting purposes

   #+BEGIN_SRC emacs-lisp :block-id bbe7dfa0-4a96-977f-20e6-ef6ab6642fc5
     (defconst fn/htmlize-package-dir (expand-file-name "htmlize-custom/" fn/custom-module-dir)
       "Htmlize package dir")

     (use-package htmlize
       :load-path fn/htmlize-package-dir
       :after ox-reveal)
   #+END_SRC
** request
   I love them request library like in Python

   #+BEGIN_SRC emacs-lisp :block-id 19aa11f8-524f-986e-84d8-45eb781bbee5
     (use-package request
       :ensure t
       :defer t
       :config
       (setq request-storage-directory (expand-file-name "request" fn/cache-dir)))
   #+END_SRC

** log4e
   Nice logging library

   #+BEGIN_SRC emacs-lisp :block-id e8344e55-09ff-27a8-a6c0-8d76e44cd3f0
     (use-package log4e
       :ensure t
       :config
       (log4e:deflogger
         "chat"
         ">>> %t \n%m\n<<<"
         "%F %H:%M:%S"
         (list (cons 'info "info")))

       (chat--log-enable-logging)


       (defface fn/chat-server-name  '((t (:weight bold :height 0.9)))
         "Chat server name face")

       (defface fn/chat-channel-name  '((t (:weight ultra-bold :height 1.1)))
         "Chat server  name face")

       (defface fn/chat-chatter-name  '((t (:underline t :weight semi-bold :height 1.0)))
         "Chat sender name face")

       (defface fn/chat-message  '((t (:weight thin :height 1.0)))
         "Chat message face")


       (defun fn/chat-propertize (text style)
         "Add extra coloring with TEXT and STYLE."
         (let ((new-text (substring text)))
           (add-face-text-property
            0
            (length new-text)
            style
            nil
            new-text)
           new-text))


       (defun fn/prettify-word (word)
         "Prettify word if possible."
         (if (fboundp 'text-candy-candied-word)
             (text-candy-candied-word word)
           word))

       (defun fn/chat-log (server channel chatter message)
         "Log SERVER, CHANNEL, CHATTER and MESSAGE."
         (unless (string-empty-p message)
           (let* ((out
                (string-trim-right
                 (format "[%s/%s] %s: %s"
                         (fn/chat-propertize (fn/prettify-word server) 'fn/chat-server-name)
                         (fn/chat-propertize (fn/prettify-word channel) 'fn/chat-channel-name)
                         (fn/chat-propertize chatter 'fn/chat-chatter-name)
                         (fn/chat-propertize message 'fn/chat-message)))))
             (chat--log-info out)
             out)))

       (defun fn/chat-log-open ()
         "Open chat log."
         (interactive)
         (chat--log-open-log))


       (defconst fn/chat-log-file (expand-file-name ".chat-log.txt.gpg" fn/cache-dir)
         "My chat log file.")

       (defun fn/chat-log-clear ()
         "Clear chat log."
         (interactive)
         (chat--log-clear-log))

       (defun fn/chat-log-flush (&optional retain)
         "Save log for posterity.  If RETAIN is non-nil, do not clear the log."
         (ignore-errors
           (save-window-excursion
             (fn/chat-log-open) ;; NOTE: Error might result if the log isn't populated yet.
             (let ((new-log
                  (with-current-buffer log4e--log-buffer-chat
                    (buffer-substring-no-properties (point-min) (point-max))))
                 (file (find-file-noselect fn/chat-log-file)))
               (with-current-buffer file
                 (end-of-buffer)
                 (newline)
                 (insert new-log)
                 (save-buffer))
               (unless retain
                 (fn/chat-log-clear))
               nil))))

       (defun fn/chat-log-flush-before-clear (&rest args)
         "Save the log before clearing."
         (fn/chat-log-flush t))

       (advice-add 'chat--log-clear-log :before #'fn/chat-log-flush-before-clear)
       (add-hook 'kill-emacs-hook #'fn/chat-log-flush)


       (use-feature log4e-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'log4e-mode
          (list 'all-the-icons-octicon "clippy" :v-adjust 0.0))))
   #+END_SRC

** auto-compile
   Automatic compilation of package files

   #+BEGIN_SRC emacs-lisp :block-id cf5a9ca5-1bd8-421b-d6f6-76a4cf5194fc
     (use-package auto-compile
       :ensure t
       :demand t
       :config
       (auto-compile-on-load-mode)
       (auto-compile-on-save-mode))
   #+END_SRC
** promise
   Something to help with package configuration

   #+BEGIN_SRC emacs-lisp :block-id e0719481-70d9-9187-00c6-a424983cef0e
     (defconst fn/promise-package-dir (expand-file-name "promise/" fn/custom-module-dir)
       "Promise package location")

     (use-package promise
       :load-path fn/promise-package-dir
       :demand t
       :config
       (defmacro use-function (name function &rest body)
         (let ((function-name-var (make-symbol "function-name")))
           `(let ((,function-name-var ,(symbol-name name)))
              (message "Checking function %s" ,function-name-var)
              (if (not (fboundp (quote ,function)))
                  (message "Function does not exist")
                (message "Loading function %s" ,function-name-var)
                ,@body
                (message "Configured function %s" ,function-name-var)))))

       (defmacro use-feature (name features &rest body)
         (let ((now-var (make-symbol "now"))
               (elapsed-var (make-symbol "elapsed"))
               (feature-name-var (make-symbol "feature-name")))
           `(promise-then
             (apply #'promise-all-features (list ,@(if features
                                                       (mapcar (lambda (feature) (list 'quote feature)) features)
                                                     (list (list 'quote 'use-package)))))
             (lambda (loaded-features)
               (let ((,feature-name-var ,(symbol-name name))
                     (,now-var (current-time)))
                 (message "Loading feature package %s" ,feature-name-var)
                 ,@body
                 (let ((,elapsed-var (float-time (time-subtract (current-time) ,now-var))))
                   (if (> ,elapsed-var ,use-package-minimum-reported-time)
                       (message
                        "Configuring feature package %s ... done (%.3fs)"
                        ,feature-name-var
                        ,elapsed-var)
                     (message
                      "Configuring feature package %s... done"
                      ,feature-name-var))
                   nil))))))

       ;; Indent like =use-packagh=
       (put 'use-feature 'lisp-indent-function 'defun)
       (put 'use-function 'lisp-indent-function 'defun))
   #+END_SRC

** all-the-icons
   Making Emacs more modern.

   Sadly, this has to be placed here because =use-feature= cannot load
   it properly.

   #+BEGIN_SRC emacs-lisp :block-id 1c07422d-833b-c29a-44dd-3c62d3498e7f
     (defconst fn/all-the-icon-font-dir (expand-file-name "all-the-icons-font" fn/custom-module-dir)
       "All the icon font library.")

     (defconst fn/all-the-icon-font-families
       (list
        (cons "FontAwesome" "fontawesome.ttf")
        (cons "Weather Icons" "weathericons.ttf")
        (cons "file-icons" "file-icons.ttf")
        (cons "github-octicons" "octicons.ttf")
        (cons "all-the-icons" "all-the-icons.ttf"))
       "The font available.")

     (fset 'fn/add-major-mode-icon 'ignore)

     (unless noninteractive
       (use-package all-the-icons
         :ensure t
         :demand t
         :config
         (defun fn/add-major-mode-icon (main-mode icon-config)
           "Add icon mapping to major mode given MAIN-MODE, ICON-CONFIG."
           (add-to-list
            'all-the-icons-mode-icon-alist
            (append (list main-mode) icon-config)))

         (fn/add-major-mode-icon
          'makefile-mode
          (list 'all-the-icons-faicon "wrench" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'special-mode
          (list 'all-the-icons-faicon "birthday-cake" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'fundamental-mode
          (list 'all-the-icons-faicon "pencil" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'compilation-mode
          (list 'all-the-icons-faicon "cog" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'process-menu-mode
          (list 'all-the-icons-faicon "list" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'package-menu-mode
          (list 'all-the-icons-octicon "package" :v-adjust 0.0))


         (defun fn/check-installed-font-families ()
           "Check if `fn/all-the-icon-font-families' is intalled."
           (mapc
            (lambda (pair)
              (pcase-let ((`(,family . ,_) pair))
                (unless (member family (font-family-list))
                  (message "The %s is not installed, you might want it installed." family))))
            fn/all-the-icon-font-families))

         (add-hook 'after-init-hook 'fn/check-installed-font-families)))
   #+END_SRC

* Terminator
  Shell related aspect

** nsm
   The network security manager for Emacs

   #+BEGIN_SRC emacs-lisp :block-id 17fd5dfb-4c56-cb92-865d-448fd1e56804
     (use-package nsm
       :demand t
       :config
       (setq nsm-settings-file (expand-file-name "network-security.data" fn/cache-dir)
             network-security-level 'high))
   #+END_SRC

** shell
   Some configurations on the terminal

   #+BEGIN_SRC emacs-lisp :block-id da6d7eb9-45f4-ee00-154d-11e39b59d7bf
     (setq async-shell-command-buffer 'new-buffer)

     (use-feature shell-mode--mode-icon
       (all-the-icons)
       (fn/add-major-mode-icon
        'shell-mode
        (list 'all-the-icons-faicon "terminal" :v-adjust 0.0)))
   #+END_SRC

** term
   An enhancement for =term=

   #+BEGIN_SRC emacs-lisp :block-id 539bc87d-8763-f0fb-47de-4620fa090f43
     (use-package term
       :bind (:map fn-standard-prefix-map
                   ("x t" . ansi-term))
       :config
       (defadvice term-sentinel (around ansi-term-kill-buffer (proc msg))
         (if (memq (process-status proc) '(signal exit))
             (let ((buffer (process-buffer proc)))
               ad-do-it
               (kill-buffer buffer))
           ad-do-it))
       (ad-activate 'term-sentinel)

       ;; Set the term program and ask for a name
       (defadvice ansi-term (before ansi-term-force-shell)
         (interactive (list (getenv "SHELL")
                            (let ((term-name (string-trim (read-from-minibuffer "Name the term buffer: "))))
                              (if (string-empty-p term-name) nil term-name)))))
       (ad-activate 'ansi-term)


       (add-hook 'term-mode-hook 'goto-address-mode)
       (add-hook 'term-exec-hook
                 '(lambda ()
                    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))
   #+END_SRC

** eshell
   Another enhancement for the shell

   #+BEGIN_SRC emacs-lisp :block-id 8365fbc6-47af-b2ac-e913-af5aa85cb479
     (use-package eshell
       :bind (:map fn-standard-prefix-map
                   ("x e" . eshell))
       :config
       (defun fn/eshell-prompt-function ()
         "My eshell prompt function."
         (concat " λ "))

       (setq eshell-highlight-prompt nil
          eshell-directory-name (expand-file-name "eshell" fn/cache-dir)
          eshell-prefer-lisp-functions t
          eshell-prompt-function #'fn/eshell-prompt-function))
   #+END_SRC

*** Autocompletion
    We got completion here

    #+BEGIN_SRC emacs-lisp :block-id 114da1f2-d600-af5b-af05-f5097502456d
      (use-package pcomplete
        :ensure t)

      (use-package pcmpl-git
        :ensure t
        :after pcomplete)

      (use-package pcmpl-pip
        :ensure t
        :after pcomplete)

      (use-package pcomplete-extension
        :ensure t
        :after pcomplete)
    #+END_SRC

*** Scripts
    My scripts for eshell

    #+BEGIN_SRC emacs-lisp :block-id 96e77612-2bfc-55d9-fe66-8e5d4e612c20

    #+END_SRC

*** Commands
    My eshell commands for eshell

    #+BEGIN_SRC emacs-lisp :block-id 630dc69a-0e85-f569-c06c-57e761d746d3
      (defun eshell/x ()
        (insert "exit")
        (eshell-send-input)
        (delete-window))
    #+END_SRC

** prodigy
   Living in the shell requires some genius

   #+BEGIN_SRC emacs-lisp :block-id dc93746e-c346-c682-730d-a3d26b5e258a
     (defconst fn/prodigy-dir (expand-file-name "prodigy/" fn/custom-module-dir)
       "Prodigy dir")

     (defconst fn/prodigy-map (fn/make-prefixed-keymap (kbd "P") fn-standard-prefix-map)
       "My custom prodigy map.")

     (use-package prodigy
       :ensure t
       :bind (:map fn/prodigy-map
                   ("P" . prodigy))
       :demand t
       :config
       (defmacro fn/prodigy-with-buffer (&rest body)
         "Execute BODY within an exisiting prodigy buffer."
         `(progn
            (when (prodigy-buffer)
              (with-current-buffer (prodigy-buffer)
                ,@body))))

       (defun fn/prodigy-refresh ()
         "Refresh prodigy buffer."
         (ignore-errors
           (fn/prodigy-with-buffer
            (prodigy-refresh)
            (prodigy-goto-first-line))))

       (defmacro fn/prodigy-with-default-filters (&rest body)
         `(fn/prodigy-with-buffer
           (fn/prodigy-clear-default-filter)
           ,@body
           (fn/prodigy-set-default-filter-hook)))


       (defvar fn/prodigy-default-filters nil
         "Default filters for prodigy.")

       (defun fn/prodigy-clear-default-filter ()
         "Clear default prodigy filters."
         (setq fn/prodigy-default-filters nil))

       (defun fn/prodigy-add-default-filter (type value)
         "Add default filter for prodigy with TYPW and VALUE."
         (push (list type value) fn/prodigy-default-filters))

       (defun fn/prodigy-add-default-tag-filter (tag)
         "Add a default TAG filter."
         (fn/prodigy-add-default-filter :tag tag))

       (defun fn/prodigy-set-default-filter-hook ()
         "Add default filters when opening prodigy"
         (fn/prodigy-with-buffer
          (message "Applying default prodigy filters")
          (setq prodigy-filters fn/prodigy-default-filters))
         (fn/prodigy-refresh))

       (add-hook 'prodigy-mode-hook #'fn/prodigy-set-default-filter-hook)


       (defun fn/prodigy-switch-to-process-buffer (service)
         "Just an wrapper for said function with SERVICE."
         (if (prodigy-service-started-p service)
             (prodigy-switch-to-process-buffer service)
           (lexical-let* ((service-delay 3)
               (service service))
             (message "Starting %s service." (plist-get service :name))
             (prodigy-start-service service)
             (run-with-idle-timer service-delay nil 'fn/prodigy-switch-to-process-buffer service))))

       (defun fn/prodigy-prepared-switch-to-process-buffer (service)
         "Another wrapper to make specific functions for viewing SERVICE."
         (lexical-let* ((service-name (plist-get service :name))
             (command-name (or (plist-get service :bind-command-name)
                              (symbol-name (gensym "prodigy-view-"))))
             (prefix "fmpv/")
             (function-symbol (intern (format "%s%s" prefix command-name)))
             (service service))
           (fset function-symbol
                 `(lambda ()
                    ,(format "A prodigy view function for %s" service-name)
                    (interactive)
                    (fn/prodigy-switch-to-process-buffer (quote ,service))))
           function-symbol))

       (defun fn/prodigy-define-service (&rest args)
         "When creating a service, check for a :bind keyword to create an automatic keybinding for it."
         (let ((result (apply #'prodigy-define-service args)))
           (prog1
               result
             (let* ((service (car result))
                 (name (plist-get service :name))
                 (bind (plist-get service :bind))
                 (bind-map (or (plist-get service :bind-map) global-map)))
               (when bind
                 (message "Creating binding for %s" name)
                 (define-key bind-map bind (fn/prodigy-prepared-switch-to-process-buffer service)))))))


       ;; Display prodigy buffers on the same windowx
       (add-to-list
        'display-buffer-alist
        (cons
         (rx bos "*prodigy*" eos)
         (cons 'display-buffer-same-window (list))))

       (add-to-list
        'display-buffer-alist
        (cons
         (rx bos "*prodigy-" (* anything))
         (cons 'display-buffer-same-window (list))))


       (use-feature prodigy-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'prodigy-mode
          (list 'all-the-icons-faicon "cogs" :v-adjust -0.1))

         (fn/add-major-mode-icon
          'prodigy-view-mode
          (list 'all-the-icons-faicon "cog" :v-adjust -0.1))))
   #+END_SRC
** procred
   Similarly, manage processes.

   #+BEGIN_SRC emacs-lisp :block-id 0ae1df3b-b802-c3f2-4e17-450d5e8245f8
     (use-package proced
       :ensure t
       :defer t
       :bind (:map fn-standard-prefix-map
                   ("C-M-p p" . proced)))
   #+END_SRC

** emamux
   Work better with tmux

   #+BEGIN_SRC emacs-lisp :block-id 13d23dc8-e0a7-3d2c-71b6-13cefdd9fb96
     (use-package emamux
       :ensure t
       :defer t)
   #+END_SRC

** docker
   Containers eh?

   #+BEGIN_SRC emacs-lisp :block-id e9ab7472-6b2b-33b2-93e4-19113b3dff15
     (use-package docker
       :ensure t
       :defer t)
   #+END_SRC

   Something to edit =Dockerfile=

   #+BEGIN_SRC emacs-lisp :block-id f2ccee62-1618-98e4-ca5c-1fe84800ccd4
     (use-package dockerfile-mode
       :ensure t
       :mode (("Dockerfile\\'" . dockerfile-mode)))
   #+END_SRC

** memory-usage
   Nice to know if my baby is getting to fat to quick

   #+BEGIN_SRC emacs-lisp :block-id 2f9e8622-448e-2a55-c269-285f71ec82bb
     (use-package memory-usage
       :ensure t
       :bind (:map fn-standard-prefix-map
                   ("m" . memory-usage)))
   #+END_SRC

* Editor
  Anything to do with editing in Emacs

** Environment
*** guru
    Remember the Emacs's way to do things, but I think I'm good now. I
    only use it when I am one handed.

    #+BEGIN_SRC emacs-lisp :block-id 58184164-573b-ce16-5e68-95cac5029252
      (use-package guru-mode
        :ensure t
        :disabled t ;; Finally graduated from using the arrow keys
        :diminish guru-mode
        :config
        (guru-global-mode t))
    #+END_SRC

*** visual-line
    Visual lines make more sense than the hard lines, what you see is
    what you get. Besides, I use syntax motions

    #+BEGIN_SRC emacs-lisp :block-id c1dad918-e45c-608c-f71c-66922e5aa4ec
      (use-feature visual-line-mode
        nil
        (global-visual-line-mode t)
        (diminish 'visual-line-mode))
    #+END_SRC

*** auto-fill
    Useful mode when writing, keeps things under 80 characters.

    #+BEGIN_SRC emacs-lisp :block-id 6be4492f-5e2a-4cbb-fcc4-31baf82851e1
      (use-feature auto-fill-mode
        nil
        (add-hook 'text-mode-hook 'turn-on-auto-fill)
        (diminish 'auto-fill-function)
        (setq-default fill-column 72))
    #+END_SRC

*** auto-revert
    The more generic revert

    #+BEGIN_SRC emacs-lisp :block-id f2576d89-b810-5cf0-f398-7b530420997d
      (use-feature auto-revert
        nil
        (global-auto-revert-mode t)

        (setq global-auto-revert-non-file-buffers t
              auto-revert-verbose nil)

        (diminish 'auto-revert-mode))
    #+END_SRC

*** autorevert
    Enhancement for log reading

    #+BEGIN_SRC emacs-lisp :block-id 30faefd0-5219-3cd8-1ae0-8ea74ab7cf7b
      (use-package autorevert
        :diminish auto-revert-mode
        :mode (("\\.log\\'" . auto-revert-tail-mode)));
    #+END_SRC

** Editing
*** hungry-delete
    Very useful default delete functionality

    #+BEGIN_SRC emacs-lisp :block-id 3fd0ecbe-3c3a-10f8-c4d5-8bb9fdbea9a5
      (use-package hungry-delete
        :ensure t
        :diminish hungry-delete-mode
        :bind (:map fn-standard-prefix-map
                    ("C-d C-d" . hungry-delete-forward)
                    ("C-d DEL" . hungry-delete-backward)))
    #+END_SRC

*** expand-region
    Another great feature for marking

    #+BEGIN_SRC emacs-lisp :block-id d4f2e1bb-e7a6-1ef8-5fc0-99eb5712ce71
      (use-package expand-region
        :ensure t
        :bind (("C-=" . er/expand-region)))
    #+END_SRC

*** multiple-cursors
    This functions does not get too much attention

    #+BEGIN_SRC emacs-lisp :block-id 46dc1c91-1847-19d5-981e-6b68a22b3b16
      (use-package multiple-cursors
        :ensure t
        :bind (("C-S-c C-S-c" . mc/edit-lines)
               ("C->" . mc/mark-next-like-this)
               ("C-<" . mc/mark-previous-like-this)
               ("C-c C-<" . mc/mark-all-like-this)))
    #+END_SRC
*** undo-tree
    Visualizing undo like vi

    #+BEGIN_SRC emacs-lisp :block-id 30703a30-7eb6-884f-b69c-ec5e4ab5b73a
      (use-package undo-tree
        :ensure t
        :defer t
        :diminish undo-tree-mode
        :bind (:map fn-standard-prefix-map
                    ("C-_" . undo-tree-visualize)))
    #+END_SRC

** Completion
*** hippie-exp
    Hippie expand rocks

    #+BEGIN_SRC emacs-lisp :block-id 04958daf-7aa0-94ab-8038-98ea3e2e7e05
      (use-package hippie-exp
        :bind (("M-/" . hippie-expand))
        :config
        (setq hippie-expand-try-functions-list
           '(
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-complete-file-name-partially
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol))

        (use-feature hippie-ggtags
          (ggtags)
          (add-to-list 'hippie-expand-try-functions-list 'ggtags-try-complete-tag)))
    #+END_SRC

*** company
    A replacement for =autocomplete=.

    #+BEGIN_SRC emacs-lisp :block-id 14b030d6-a17c-98ae-444f-7529560d8b4d
      (unless noninteractive
        (use-package company
          :ensure t
          :diminish company-mode
          :defines company-backends
          :demand t
          :init
          (add-hook 'prog-mode-hook 'company-mode)
          :config
          (setq company-idle-delay (/ 60.0)
             company-minimum-prefix-length 3

             company-begin-commands (list 'self-insert-command))


          (setq company-show-numbers t
             company-tooltip-limit 20
             company-tooltip-align-annotations t)


          (setq company-dabbrev-time-limit 0.001
             company-dabbrev-code-time-limit 0.001)


          (setq company-backends (list))

          (add-to-list 'company-backends 'company-capf)
          (add-to-list 'company-backends 'company-dabbrev)
          (add-to-list 'company-backends 'company-elisp)

          (defun fn/combine-backends (backend new-backend)
            "Combine BACKEND with NEW-BACKEND."
            (if (and (listp backend) (member new-backend backend))
                backend
              (let* ((list-backend (if (consp backend)
                                    backend
                                  (list backend)))
                  (with-backend (if (member ':with list-backend)
                                    list-backend
                                  (append list-backend '(:with)))))
                (append with-backend (list new-backend)))))

          (defun fn/append-to-backends (new-backend)
            "Append NEW-BACKEND to company."
            (setq company-backends
               (mapcar
                (lambda (backend)
                  (fn/combine-backends backend new-backend))
                company-backends)))

          (setq fn/company-prog-backends (list 'company-dabbrev-code))

          (defun fn/backend-with-prog ()
            (fn/append-to-backends 'company-keywords))))
    #+END_SRC

*** yasnippet
    Snippet system along with autocomplete is awesome

    #+BEGIN_SRC emacs-lisp :block-id 26aea11a-6b42-e3c0-dc5f-a8ba5ceb6f42
      (unless noninteractive
        (use-package yasnippet
          :ensure t
          :after company
          :defer t
          :diminish yas-minor-mode
          :bind (:map fn-standard-prefix-map
                      ("y" . yas-new-snippet))
          :init
          (setq yas-verbosity 3
             yas-snippet-dirs (list (expand-file-name "snippets" fn/extra-dir)))

          (add-hook 'prog-mode-hook 'yas/minor-mode-on)
          :config

          (push 'yas-hippie-try-expand hippie-expand-try-functions-list)

          ;; (yas-reload-all)

          (defun fn/add-company-yasnippet ()
            "Add yasnippet to company backends"
            (fn/append-to-backends 'company-yasnippet))))
    #+END_SRC

* Ergonomic
  Things to assist in managing Emacs

** Jump
   Things to jump around with
*** recentf
    Accessing the files recently

    #+BEGIN_SRC emacs-lisp :block-id 3f6c8b53-5f56-d1bb-8852-71807ad0c314
      (unless noninteractive
        (use-package recentf
          :bind (("C-x C-r" . recentf-open-files))
          :config
          (setq recentf-save-file (expand-file-name "recentf" fn/cache-dir)

             recentf-max-menu-items 1000
             recentf-max-saved-items 1000

             recentf-exclude '("TAGS" ".*-autoloads\\.el\\'"))

          (recentf-mode t))

        (use-package recentf-ext
          :ensure t
          :after recentf))
    #+END_SRC

*** bookmark+
    Enhancement for normal bookmarking

    #+BEGIN_SRC emacs-lisp :block-id 3165bffb-1127-0d5d-0a4f-7ff0b07d7612
      (unless noninteractive
        (use-package bookmark+
          :ensure t
          :demand t
          :config
          nil))
    #+END_SRC

** Windows
   Anything related to window management

*** desktop
    Managing buffers the Emacs way.

    #+BEGIN_SRC emacs-lisp :block-id d638037a-5b8e-86de-e653-20b58c670c66
      (defconst fn/desktop-map (fn/make-prefixed-keymap (kbd "d") fn-standard-prefix-map)
        "My custom desktop bookmarked map.")

      (use-package desktop
        :demand t
        :config
        (defconst fn/desktop-dir (expand-file-name "desktop/" fn/cache-dir)
          "My desktop dir")

        (make-directory fn/desktop-dir t)

        (setq desktop-path (list)
           desktop-base-file-name "blank"
           desktop-base-lock-name ".desk-lock"
           desktop-save 'if-exists

           desktop-restore-eager 15
           desktop-lazy-idle-delay 10
           desktop-lazy-verbose t)

        (desktop-save-mode)

        (use-feature bookmarked-desktop
          (bookmark+)
          (define-key fn/desktop-map (kbd "s") 'bmkp-set-desktop-bookmark)

          (setq bmkp-desktop-default-directory fn/desktop-dir
             bmkp-desktop-jump-save-before-flag t)))

      (use-package desktop+
        :ensure t
        :after desktop
        :bind (:map fn/desktop-map
                    ("s" . desktop+-create)
                    ("l" . desktop+-load))
        :config
        (setq desktop+-base-dir fn/desktop-dir))
    #+END_SRC

*** workgroup
    Saving window state is very helpful specially when you move a lots

    #+BEGIN_SRC emacs-lisp :block-id 6c071d29-d448-f4fa-f1d4-63c347a9cb28
      (use-package workgroups2
        :ensure t
        :bind (("C-c w w" . workgroups-mode))
        :init
        (setq wg-prefix-key (kbd "C-c w")
           wg-session-file (expand-file-name "workgroups" fn/cache-dir))
        :config
        (setq wg-morph-on nil

           wg-mode-line-display-on nil

           wg-mess-with-buffer-list nil

           wg-buffer-auto-association-on nil
           wg-undoify-window-configuration-change nil

           wg-buffer-local-variables-alist (list)

           wg-restore-frame-position nil
           wg-restore-scroll-bars nil
           wg-restore-margins nil

           wg-restore-point t
           wg-restore-point-max t

           wg-restore-mark nil
           wg-restore-window-dedicated-p nil
           wg-remember-frame-for-each-wg nil

           wg-emacs-exit-save-behavior           'save
           wg-workgroups-mode-exit-save-behavior 'save)

        (defun fn/wg-session-list-buffers (&optional frame)
          "Get the current session buffers."
          (-reject
           (-compose
            (-partial #'s-starts-with-p " ")
            #'buffer-name)
           (funcall wg-buffer-list-function frame)))

        (defun fn/list-to-hash-table (xs)
          "Convert XS to a hash table with equality comparison."
          (let ((table (make-hash-table)))
            (mapc (lambda (x) (puthash x t table)) xs)
            table))

        (defun fn/wg-switch-to-buffer ()
          "Switch buffer with my custom workgroup."
          (interactive)
          (lexical-let* ((session-buffers (fn/wg-session-list-buffers))
              (buffer-table (fn/list-to-hash-table session-buffers))
              (predicate
               (lambda (buffer-pair)
                 (when (consp buffer-pair)
                   (lexical-let* ((buffer (cdr buffer-pair)))
                     (gethash buffer buffer-table nil)))))
              (buffer (read-buffer
                       "Switch to session buffer: "
                       nil
                       t
                       predicate)))
            (switch-to-buffer buffer)))

        (defun fn/wg-create-workgroup ()
          "Create a blank workgroup."
          (interactive)
          (let ((current-prefix-arg t))
            (call-interactively #'wg-create-workgroup)))


        (define-key wg-prefixed-map (kbd "b") #'fn/wg-switch-to-buffer)
        (define-key wg-prefixed-map (kbd "s") #'wg-switch-to-workgroup)


        (run-with-idle-timer 0 nil (lambda  ()
                                   (define-key workgroups-mode-map
                                     (vector 'remap 'wg-create-workgroup)
                                     #'fn/wg-create-workgroup)))


        (defun fn/wg-cleanup ()
          "Some cleanup with workgroups since it becomes really slow speciall with `execute-extended-command' with `smex'."
          (wg-perform-session-maintenance))

        (add-hook 'wg-after-switch-to-workgroup-hook 'fn/wg-cleanup)
        (add-hook 'wg-after-switch-to-workgroup-hook 'garbage-collect)


        ;; Performance
        ;; Avoid doing things with `post-command-hook'
        (advice-add 'wg-undoify-window-configuration-change :override 'ignore))
    #+END_SRC

*** winner
    You got to have those window configuration

    #+BEGIN_SRC emacs-lisp :block-id 1bccc5be-c2b8-eca5-8158-9b40eccdbc8e
      (use-package winner
        :ensure t
        :config
        (winner-mode t))
    #+END_SRC

*** window-numbering
    A must to navigate through windows with numbers.

    #+BEGIN_SRC emacs-lisp :block-id 8f1e9fc0-580e-1fdb-c8a1-f4c042ce0d68
      (unless noninteractive
        (use-package window-numbering
          :ensure t
          :demand t
          :config
          (window-numbering-mode t)


          (require 'dash)

          (defun fn/get-window-by-number (window-number)
            "Get window by WINDOW-NUMBER."
            (-find
             (lambda (window)
               (= (window-numbering-get-number window) window-number))
             (window-list)))

          (defun fn/swap-windows (this-window that-window)
            "Swap THIS-WINDOW and THAT-WINDOW"
            (let ((this-buffer (window-buffer this-window))
                (that-buffer (window-buffer that-window)))
              (unless (eq this-buffer that-buffer)
                (set-window-buffer this-window that-buffer)
                (set-window-buffer that-window this-buffer))))

          (defun fn/swap-with-numbered-window (window-number)
            "Swap with current window with numbered window."
            (interactive "NWhat window number? ")
            (let ((this-window (selected-window))
                (that-window (fn/get-window-by-number window-number)))
              (if (null that-window)
                  (message "Window %s does not exist"
                           window-number)
                (fn/swap-windows this-window that-window)
                (select-window-by-number window-number))))))
    #+END_SRC

*** window-layout
    Making window layouts

    #+BEGIN_SRC emacs-lisp :block-id 1f3782e2-bdbf-c261-74b3-5ce6bbb064e6
      (use-package window-layout
        :ensure t
        :config
        (use-feature window-numbered-layout
          (window-numbering)
          (require 'dash)

          (defvar fn/current-window-layout nil
            "The current window layout.")

          (defun fn/window-numbering-assign-func ()
            "Window number assignment based on the current window layout."
            (ignore-errors
              (lexical-let ((this-window (selected-window)))
                (when (wlf:wset-p fn/current-window-layout)
                  (let ((layout-index
                       (-find-index
                        (lambda (winfo) (eq (wlf:window-window winfo) this-window))
                        (wlf:wset-winfo-list fn/current-window-layout))))
                    (if layout-index
                        layout-index
                      nil))))))

          (setq window-numbering-assign-func 'fn/window-numbering-assign-func)))
    #+END_SRC

*** golden-ratio
    Makes windows large enough to see.

    #+BEGIN_SRC emacs-lisp :block-id dc0fe50a-04d2-ef04-47f4-fcbf8059e81a
      (unless noninteractive
        (use-package golden-ratio
          :ensure t
          :after window-numbering
          :diminish golden-ratio-mode
          :bind (("C-c q" . golden-ratio)
                 :map fn-standard-prefix-map
                 ("q" . golden-ratio-mode))
          :demand T
          :config
          (golden-ratio-mode t)

          (setq split-width-threshold nil
             golden-ratio-adjust-factor 1.0)


          ;; Frame entry exit fix
          (add-hook 'focus-in-hook #'golden-ratio)
          (add-hook 'focus-out-hook #'golden-ratio)


          (use-feature golden-workgroups
            (workgroups2)
            ;; When switching workgroups, make sure the screen is rationed correctly
            (add-hook 'wg-after-switch-to-workgroup-hook #'golden-ratio))


          (use-feature golden-window-numbering
            (window-numbering)
            (defun fn/golden-ratio-after-select-window-by-number (&rest args)
              (golden-ratio))

            (advice-add
             #'select-window-by-number
             :after
             #'fn/golden-ratio-after-select-window-by-number))))
    #+END_SRC

*** uniquify
    Nicer naming convention

    #+BEGIN_SRC emacs-lisp :block-id 0daef306-f44a-5bc5-dead-1578ba3b8e9d
      (use-package uniquify
        :if (version<= emacs-version "24.3.1")
        :config
        (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
    #+END_SRC

** Interface
   Anything related to buffers

*** projectile
    Must have a project finder when using a project.

    #+BEGIN_SRC emacs-lisp :block-id 8ee23fbf-548c-e172-18e6-0df51729e123
      (unless noninteractive
        (use-package projectile
          :ensure t
          :diminish projectile-mode
          :demand t
          :config
          (setq projectile-cache-file (expand-file-name "projectile.cache" fn/cache-dir)
             projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" fn/cache-dir))

          (defconst fn/project-file ".project.el"
            "Project configuration file")

          (defconst fn/project-local-file ".project-locals.el"
            "Project local setting file")

          (defconst fn/project-init-files (list fn/project-file fn/project-local-file)
            "Project init files")

          (defun fn/create-projectile-file ()
            (interactive)
            (lexical-let* ((target-dir  (read-directory-name "Where do you want to the .projectile placed?"))
                (projectile-file-name ".projectile")
                (projectile-file (expand-file-name projectile-file-name target-dir)))
              (cond
               ((file-exists-p projectile-file)
                (message "Projectile file alread exists"))
               (t
                (message "Creating %s" projectile-file)
                (find-file projectile-file)))))

          (defun fn/load-project-file ()
            ;; When the project is switched, run a custom initialization file.
            ;; Be careful though with side effects, make the init file fast and pure/side-effect free
            (interactive)
            (when (projectile-project-p)
              (let* ((current-project-root (projectile-project-root))
                  (project-init-file (expand-file-name fn/project-file current-project-root)))
                (when (file-exists-p project-init-file)
                  (message "Loading project init file for %s" (projectile-project-name))
                  (condition-case ex
                      (load project-init-file t)
                    ('error (message "There was an error loading %s: %s"
                                     project-init-file
                                     (error-message-string ex))))))))

          (defun fn/load-project-local-file ()
            (interactive)
            (when (projectile-project-p)
              (let* ((current-project-root (projectile-project-root))
                  (project-local-init-file (expand-file-name fn/project-local-file current-project-root)))
                (when (and  (file-exists-p project-local-init-file)
                          (not (member (buffer-file-name) fn/project-init-files)))
                  (message "Loading project local file for %s on %s" (projectile-project-name) (buffer-name))
                  (condition-case ex
                      (load project-local-init-file t)
                    ('error (message "There was an error loading %s: %s"
                                     project-local-init-file
                                     (error-message-string ex))))))))


          ;; This must go before load-project-hook
          (add-hook 'find-file-hook #'fn/load-project-local-file t)
          (add-hook 'find-dired-hook #'fn/load-project-local-file t)


          (lexical-let* ((project-memoized
               (lambda ()
                 (lexical-let ((initialized-projects (list ".")))
                   #'(lambda ()
                       (when (projectile-project-p)
                         (lexical-let ((current-project (projectile-project-root)))
                           (if (not (member current-project initialized-projects))
                               (progn
                                 (add-to-list 'initialized-projects current-project)
                                 (fn/load-project-file))
                             current-project)))))))
              (load-project-hook (funcall project-memoized)))

            (add-hook 'find-file-hook load-project-hook)
            (add-hook 'find-dired-hook load-project-hook))


          (defun fn/find-project-root ()
            "Visit project root."
            (interactive)
            (dired-x-find-file (projectile-project-root)))

          (define-key projectile-command-map (kbd "C-r") #'fn/find-project-root)

          (setq projectile-switch-project-action #'fn/find-project-root)


          (projectile-mode)
          (setq projectile-indexing-method 'native
                projectile-enable-caching t
                projectile-enable-idle-timer nil)

          (setq projectile-sort-order 'modification-time)

          (add-to-list 'projectile-project-root-files "config.xml")))
    #+END_SRC

*** helm
    The revolutionary package to find

    #+BEGIN_SRC emacs-lisp :block-id c632c3e5-f6f1-819f-7739-ae22cdda46a2
      (unless noninteractive
        (use-package helm
          :ensure t
          :diminish helm-mode
          :bind (("M-x" . helm-M-x)
                 ("C-c f" . helm-recentf)
                 ("C-h a" . helm-apropos)
                 ("C-h r" . helm-info-emacs)
                 ("C-x b" . helm-mini)
                 ("C-x C-f" . helm-find-files)
                 ("M-s o" . helm-occur)
                 ("M-s i" . helm-imenu)
                 ("C-c C-/" . helm-dabbrev))
          :demand t
          :config
          (require 'helm-config)

          (helm-mode t)

          ;; core & utils
          (setq helm-yank-symbol-first t

             helm-mode-fuzzy-match nil

             helm-su-or-sudo "sudo"

             helm-input-idle-delay (/ 1 60.0) ;; 60fps
             helm-exit-idle-delay (/ 1 60.0)  ;; ditto

             helm-echo-input-in-header-line nil ;; If the theme does not block it

             helm-split-window-default-side 'same

             helm-debug-root-directory fn/cache-dir)


          ;; files & command
          (setq helm-ff-file-name-history-use-recentf t
             helm-ff-auto-update-initial-value t

             helm-M-x-always-save-history t)


          ;; adaptive
          (setq helm-adaptive-history-file (expand-file-name "helm-adaptive-history" fn/cache-dir)
             helm-adaptive-history-length 100)

          (helm-adaptive-mode t)))
    #+END_SRC

**** helm-projectile
     A nice assist for projectile

     #+BEGIN_SRC emacs-lisp :block-id 4ef689e2-64b3-3e3e-90da-3227eeb127bf
       (defconst fn/helm-projectile-package-dir (expand-file-name "helm-projectile/" fn/custom-module-dir)
         "My custom helm projectile package")

       (unless noninteractive
         (use-feature helm-projectile
           (projectile helm)
           (use-package helm-projectile
             :ensure t
             :bind (("C-c p h" . helm-projectile)
                    ("C-c p p" . helm-projectile-switch-project))
             :demand t
             :config
             (require 'dash)
             (require 's)
             (require 'f)

             (defconst fmc/completion-buffer-name "*Hacker Helm Completions"
               "Just a constant name for the completion buffer")


             (defface fmc/completion-label  '((t (:weight bold :height 1.1)))
               "Label face")

             (defface fmc/completion-delimiter '((t (:weight light :height 0.9)))
               "Delimiter face")

             (defface fmc/completion-description '((t (:weight extra-light :height 0.9)))
               "Description face")


             (defconst fmc/reverse-notation-separator ".."
               "My reversed separator")

             (defconst fmc/completion-separator ">>"
               "My completion separator")

             (defun fmc/uniquify-project-paths (project-paths)
               "Customize how projectile files and more are displayed"
               (lexical-let*
                   ((fn-notation
                     (lambda (path)
                       (lexical-let ((fn-pieces (f-split path)))
                         (string-join (reverse fn-pieces) fmc/reverse-notation-separator))))
                    (relative-parent-path
                     (lambda (path relative-path)
                       (lexical-let
                           ((split-path (f-split path))
                            (split-relative-path (f-split relative-path)))
                         (string-join
                          (-drop-last (length split-relative-path) split-path)
                          (f-path-separator)))))

                    (as-pair
                     (lambda (ish)
                       (if (listp ish)
                           ish (cons ish ish))))
                    (map-car
                     (lambda (f pair)
                       (cons (funcall f (car pair))
                          (cdr pair))))
                    (pair-as-label
                     (lambda (pairs)
                       (lexical-let*
                           ((display-formatter
                             (lambda (name description)
                               (format "%-s %s %-s"
                                       (propertize name 'font-lock-face 'fmc/completion-label)
                                       (propertize fmc/completion-separator 'font-lock-face 'fmc/completion-delimiter)
                                       (propertize description 'font-lock-face 'fmc/completion-description)))))
                         (lambda (pair)
                           (lexical-let*
                               ((unique-path (car pair))
                                (full-path (cdr pair))
                                (parent-path
                                 (funcall relative-parent-path
                                          full-path
                                          unique-path))

                                (display-name
                                 (funcall fn-notation unique-path))
                                (display-description
                                 (funcall fn-notation parent-path))

                                (display-label
                                 (funcall display-formatter
                                          display-name
                                          display-description)))
                             (cons display-label (cdr pair)))))))
                    (uniquify-paths
                     (lambda (paths)
                       ;; Ideally, this is just f-uniquify-alist but there is a minor contrivance
                       (lexical-let*
                           ((is-dir
                             (lambda (path)
                               (string-equal (f-path-separator)
                                             (s-right 1 path))))

                            (swap-pair (lambda (pair)
                                         (cons (cdr pair) (car pair))))
                            (map-pair
                             (lambda (f pair)
                               (cons (funcall f  (car pair)) (funcall f (cdr pair)))))

                            (remove-last-separator
                             (lambda (text)
                               (s-left (1- (length text)) text)))
                            (add-separator
                             (lambda (text)
                               (concat text (f-path-separator)))))
                         (mapcar (-compose
                                  swap-pair)
                                 (if (-any is-dir paths)
                                     ;; Remove separator, uniquify and add separator back
                                     ;; Weird performance shiznit
                                     (funcall
                                      (-compose
                                       (-partial #'mapcar (-partial map-pair add-separator))
                                       #'f-uniquify-alist
                                       (-partial #'mapcar remove-last-separator))
                                      paths)
                                   (f-uniquify-alist paths))))))
                    (refined-paths  (funcall uniquify-paths project-paths)))
                 (mapcar (-compose
                          (funcall pair-as-label refined-paths)
                          as-pair)
                         refined-paths)))

             (defun fmc/custom-helm-completion (prompt choices)
               "Just a custom helm completion for projection"
               (prog1
                   (helm-comp-read prompt (fmc/uniquify-project-paths choices)
                                   :buffer fmc/completion-buffer-name
                                   :must-match t)
                 (kill-buffer fmc/completion-buffer-name)))

             (setq projectile-completion-system #'fmc/custom-helm-completion))))
     #+END_SRC

**** helm-smex
     =smex= is faster than =helm-M-x=

     #+BEGIN_SRC emacs-lisp :block-id 7f1cc404-a888-5187-4df6-dcba60ae2373
       (unless noninteractive
         (use-package smex
           :ensure t
           :demand t
           :config
           (setq smex-save-file (expand-file-name "smex-items" fn/cache-dir)
              smex-history-length (or helm-adaptive-history-length 100))))

       (use-package helm-smex
         :ensure t
         :after smex
         :bind (("M-x" . helm-smex))
         :config
         (setq helm-smex-show-bindings t))
     #+END_SRC

*** ivy
    A lighter and faster library than [[helm]] that uses the minibuffer
    instead of a separate window.

    #+BEGIN_SRC emacs-lisp :block-id a6d7d940-ad4f-97d2-3a24-48ae273f7add
      (use-package ivy
        :ensure t
        :disabled t
        :bind (("M-x" . counsel-M-x))
        :config
        (setq ivy-use-virtual-buffers t))
    #+END_SRC

** Help
   Helper functions ere

*** command-log
    A command log when needed

    #+BEGIN_SRC emacs-lisp :block-id f36a2bde-d269-2571-e02f-c3998aaf439b
      (unless noninteractive
        (use-package command-log-mode
          :ensure t
          :diminish command-log-mode
          :demand t
          :config
          (global-command-log-mode t)))
    #+END_SRC

*** keyfreq
    Nice to know what key's I press the most

    #+BEGIN_SRC emacs-lisp :block-id 5cc8b787-43f6-7250-72a5-c269c6dd8dc0
      (use-package keyfreq
        :ensure t
        :bind (:map fn-standard-prefix-map
                    ("K" . keyfreq-show))
        :config
        (keyfreq-mode t)
        (keyfreq-autosave-mode t)

        (setq keyfreq-file (expand-file-name "keyfreq" fn/cache-dir)
              keyfreq-file-lock (expand-file-name "keyfreq.lock" fn/cache-dir)))
    #+END_SRC

*** which-key
    A mnemionic for key bindings

    #+BEGIN_SRC emacs-lisp :block-id f7b62f99-7365-6e12-adc8-0a1a6e8eadda
      (unless noninteractive
        (use-package which-key
          :ensure t
          :diminish which-key-mode
          :demand t
          :config
          (which-key-mode t)))
    #+END_SRC

*** which-function
    Likewise with key and functions

    #+BEGIN_SRC emacs-lisp :block-id a98dab72-3b51-2570-059c-7b17519d0d00
      (use-feature which-function
        nil
        (which-function-mode t))
    #+END_SRC

*** eldoc
    Nice to have the documentation at any time in the buffer.

    #+BEGIN_SRC emacs-lisp :block-id b1abbbf8-3b46-2d75-0cd8-9bce7ef92427
      (use-package eldoc
        :diminish eldoc-mode
        :init
        (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
        (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

        (add-hook 'org-mode-hook 'turn-on-eldoc-mode))
    #+END_SRC

*** helm-descbinds
    Another way to check bindings

    #+BEGIN_SRC emacs-lisp :block-id 9f63032d-0622-95b7-8b0c-bbd391e3626a
      (use-package helm-descbinds
        :ensure t
        :after helm
        :bind (("C-h b" . helm-descbinds))
        :config
        (setq helm-descbinds-window-style 'same))
    #+END_SRC

*** helm-describe-modes
    A nice way to describe the current modes

    #+BEGIN_SRC emacs-lisp :block-id f260bfd0-c52b-798c-c838-26051a51a8b4
      (use-package helm-describe-modes
        :ensure t
        :after helm
        :config
        (global-set-key [remap describe-mode] #'helm-describe-modes))
    #+END_SRC
** Optimizer
   Some things to help debug Emacs performance

   #+BEGIN_SRC emacs-lisp :block-id dbe3b540-57be-0cbc-4269-c04eaaa41eba
     (use-package profiler-log-size
       :bind (:map fn-standard-prefix-map
                   ("C-p b" . profiler-start)
                   ("C-p e" . profiler-stop)
                   ("C-p r" . profiler-report))
       :init
       (add-hook 'after-init-hook (lambda () (profiler-start 'cpu+mem))))
   #+END_SRC

** Packages
   Anything to manage packages

*** paradox
    The package management improvement

    #+BEGIN_SRC emacs-lisp :block-id 7cf4efda-7aa4-b9df-cbe0-826a5844e7c9
      (use-package paradox
        :ensure t
        :bind (:map fn-standard-prefix-map
                    ("p" . paradox-list-packages))
        :config
        (setq paradox-github-token t)

        (use-feature paradox-menu-mode--mode-icon
          (all-the-icons)
          (fn/add-major-mode-icon
           'paradox-menu-mode
           (list 'all-the-icons-octicon "package" :v-adjust 0.0))))
    #+END_SRC

**** helm-flx
     Flex matching is strong

     #+BEGIN_SRC emacs-lisp :block-id 4d383ad6-7fce-9ac5-d57e-54c4310d0ffa
       (use-package helm-flx
         :ensure t
         :after helm
         :config
         (helm-flx-mode t))
     #+END_SRC

*** elpa-mirror
    Just in case things are down.

    #+BEGIN_SRC emacs-lisp :block-id d9ff5d65-9c4a-24ee-d9e8-81459f7851d3
      (defconst fn/mirror-elpa-repo "mirror-elpa"
        "The name of the elpa mirror repo.")

      (defconst fn/local-elpa-mirror-dir (expand-file-name fn/mirror-elpa-repo fn/external-module-dir)
        "My local elpa mirror.")

      (use-package elpa-mirror
        :ensure t
        :demand t
        :config
        (require 'deferred)

        (make-directory fn/local-elpa-mirror-dir t)
        (setq elpamr-default-output-directory fn/local-elpa-mirror-dir)

        (add-to-list 'package-archives (cons "elpa-mirror" (concat fn/local-elpa-mirror-dir "/")))

        (defun fn/only-github-elpa-mirror-package-archive ()
          "Make `package-archives' be the github elpa mirror repo."
          (setq package-archives
                (list
                 (cons fn/mirror-elpa-repo
                       (format "https://raw.githubusercontent.com/%s/%s/master/"
                               fn/user-github-name
                               fn/mirror-elpa-repo)))))

        (defun fn/only-local-mirror-elpa-package-archive ()
          "Make `package-archives' be the `fn/local-elpa-mirror-dir'."
          (interactive)
          (setq package-archives
                (list
                 (cons fn/mirror-elpa-repo fn/local-elpa-mirror-dir))))

        (defun fn/push-local-elpa-mirror-to-github ()
          "Push local elpa mirror to github repo."
          (interactive)
          (async-shell-command
           (string-join
            (list
             (format "cd %s" fn/local-elpa-mirror-dir)
             (format "git add --all")
             (format "git commit -a -m \"%s\""
                     (format "%s Update" (format-time-string "%F %R")))
             (format "git push origin master"))
            " && ")))


        (defun fn/update-local-elpa-mirror ()
          "Update local elpa mirror when it is older than `package-user-dir'."
          (interactive)
          (when (file-newer-than-file-p package-user-dir fn/local-elpa-mirror-dir)
            (message "Package mirror is older than current package repo. Will update.")
            (fn/batch-update-local-elpa-mirror)
            nil))

        (defun fn/batch-update-local-elpa-mirror ()
          "Updat local elpa mirror using batch invokation."
          (interactive)
          (deferred:$
            (deferred:next
              (lambda () (message "Starting to update... Cleaning up old packages.")))
            (deferred:process-shell-bufferc it
              "rm" "-rf"
              (expand-file-name "*" fn/local-elpa-mirror-dir))
            (deferred:nextc it
              (lambda (&rest args) (message "Updating elpa mirror.")))
            (deferred:process-shell-bufferc it
              "emacs"
              "--batch"
              "-l" user-init-file
              "--eval='(elpamr-create-mirror-for-installed)'")
            (deferred:nextc it
              (lambda (&rest args) (message "Done updating local elpa mirror.")))))

        (add-hook 'after-init-hook 'fn/update-local-elpa-mirror t)


        (use-feature paradox-elpa-mirror
          (elpa-mirror paradox)
          (defun fn/paradox-update-local-elpa-mirror (&rest args)
            "Update elpa mirror when paradox is finished."
            (fn/update-local-elpa-mirror))

          (add-hook 'paradox-after-execute-functions 'fn/paradox-update-local-elpa-mirror)))
    #+END_SRC

* Artist
  Visual aesthetics is also a functional thing as well

** Font
   I like fixed font specially DejaVu Mono

   #+BEGIN_SRC emacs-lisp :block-id bbcd3af3-f5e6-c215-4497-52fa53348966
     (defconst fn/primary-font-name "DejaVu Sans Mono"
       "My ideal font.")

     (unless (member fn/primary-font-name (font-family-list))
       (message "Hey, you're favorite font isn't installed. You can find a copy in %s and get good." fn/font-dir))


     (defconst fn/secondary-font-name "Courier"
       "My backup font.")


     (defconst fn/primary-font-size 8
       "My ideal font size.")


     (cond
      ((member fn/primary-font-name (font-family-list))
       (set-frame-font (format "%s-%s" fn/primary-font-name fn/primary-font-size) t t))
      ((member fn/secondary-font-name (font-family-list))
       (set-frame-font (format "%s-%s" fn/secondary-font-name fn/primary-font-size) t t))
      (t
       (message "Darn it, you have no ideal font set.")))



   #+END_SRC

** Screen
   I prefer no clutter in my screen so I disable majority of the niceties.

   #+BEGIN_SRC emacs-lisp :block-id bae2df75-ec24-6d95-b368-4496329ec3db
     (defun fn/optimize-visual-space ()
       (let ((try-set-mode (lambda (mode value)
                             (when (fboundp 'mode)
                               (mode value)))))
         (funcall try-set-mode 'tooltip-mode -1)
         (funcall try-set-mode 'tool-bar-mode -1)
         (funcall try-set-mode 'menu-bar-mode -1)
         (funcall try-set-mode 'fringe-mode 0)))

     (fn/optimize-visual-space)

     (add-hook 'after-init-hook 'toggle-frame-fullscreen)
   #+END_SRC

** Theme
   I like dark themes, my eyes respond better to it

   My chosen themes

   #+BEGIN_SRC emacs-lisp :block-id 3223619e-5554-3bc0-f00c-3cbc1d8b0507
     (use-package apropospriate-theme
       :ensure t
       :defer t)

     (use-package base16-theme
       :ensure t
       :defer t)

     (use-package tronesque-theme
       :ensure t
       :defer t)

     (use-package material-theme
       :ensure t
       :defer t)
   #+END_SRC

   Load the theme if it is a terminal or desktop.

   #+BEGIN_SRC emacs-lisp :block-id ce022e28-6f80-1566-89e8-ea2d1ac41d47
     (load-theme 'tronesque t)
     (tronesque-mode-line)
     ;; (load-theme 'xresources t)



   #+END_SRC

** Aesthetic
   Somewhat more aesthetic than functional

*** whitespace
    Got to love that whitespace display

    #+BEGIN_SRC emacs-lisp :block-id 8b11bd1d-9022-358b-e3d3-aaba6be1cc1e
      (use-feature whitespace-mode
        nil
        (global-whitespace-mode t)
        (diminish 'global-whitespace-mode))
    #+END_SRC
*** hl-line
    Highlight the current line

    #+BEGIN_SRC emacs-lisp :block-id c4334465-c317-da19-f340-c4f45d90325f
      (use-package hl-line
        :diminish hl-line-mode
        :init
        (global-hl-line-mode t))
    #+END_SRC

** Screensaver
   When idle time hits

*** fireplace
    Warm and cozy feeling

    #+BEGIN_SRC emacs-lisp :block-id 92ab3c0e-66f5-d2ec-37ed-53d2076254a0
      (use-package fireplace
        :bind (:map fn-standard-prefix-map
                    ("f" . fireplace))
        :ensure t)
    #+END_SRC

*** zone
    I love to zone out from time to time.

    #+BEGIN_SRC emacs-lisp :block-id cf05aaab-bb91-8f2a-0589-b4545ffcee56
      (defconst fn/zone-animation-dir (expand-file-name "custom-zone/" fn/custom-module-dir)
        "Custom zone animation directory")

      (unless noninteractive
        (use-package zone
          :ensure t
          :if (not (eq system-type 'windows-nt))
          :demand t
          :config
          (defconst fn/zone-idle-time (* fn/minute-per-second 5)
            "Time for zone to zone")

          (zone-when-idle fn/zone-idle-time)

          (defvar fn/zoning-out-p nil
            "Are we zoning yet?")

          (defun fn/focused-zone (orig-zone &rest args)
            "Only show one window while zoning."
            (save-window-excursion
              (delete-other-windows)
              (setq fn/zoning-out-p t)
              (prog1
                  (apply orig-zone args)
                (setq fn/zoning-out-p nil))))

          (advice-add #'zone :around #'fn/focused-zone)


          ;; Garbage collect after zoning
          (advice-add #'zone :after #'garbage-collect)

          ;; Update mode line if there is.
          (advice-add #'zone :before #'force-mode-line-update)

          (setq zone-programs (list))))

      ;; Custom zone
      (use-package zone-end-of-buffer
        :load-path fn/zone-animation-dir
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-end-of-buffer))

      (use-package zone-waves
        :load-path fn/zone-animation-dir
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-waves))

      ;; Packaged zones
      (defconst fn/zone-matrix-dir (expand-file-name "zone-matrix" fn/custom-module-dir)
        "My zone matrix dir.")

      (use-package zone-matrix
        :load-path fn/zone-matrix-dir
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-matrix)

        (setq zmx-update-time (/ 30.0)
           zmx-update-speed-factor (/ 60.0)))

      (use-package zone-nyan
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-nyan))


      (use-package zone-sl
        :ensure t
        :after zone
        :config
        (add-to-list 'zone-programs 'zone-sl))
    #+END_SRC

** Coding
   Whatever pertains to coding

*** Scratch
    Making *scratch* behave better.

    #+BEGIN_SRC emacs-lisp :block-id 13c9501f-b096-0655-b454-55f245ff7742
      (use-package scratch
        :ensure t
        :demand t)

      (use-package scratch-ext
        :ensure t
        :after scratch
        :config
        (setq scratch-ext-log-directory (expand-file-name ".scratch" fn/cache-dir)))
    #+END_SRC

*** focus-mode
    Seems like a good mode

    #+BEGIN_SRC emacs-lisp :block-id 2141a379-9505-12c0-a682-edba8c2a3b58
      (use-package focus
        :ensure t
        :defer t
        :bind (:map fn-standard-prefix-map
                    ("f" . focus-mode)))
    #+END_SRC

*** font-lock
    Syntax highlighting is a requirement

    #+BEGIN_SRC emacs-lisp :block-id 2627498a-5181-8620-ba8a-70744aaa36d1
      (global-font-lock-mode t)

      (setq font-lock-support-mode 'jit-lock-mode)
      (setq font-lock-maximum-decoration t)
    #+END_SRC
*** prettify-symbols
    Make things more algebraic

    #+BEGIN_SRC emacs-lisp :block-id d6820a0e-ce89-788c-05e2-ceccda66bcb9
      (use-feature prettify-symbols-mode
        nil)
    #+END_SRC

*** rainbow-delimeter
    Visual aid helps with very nested code

    #+BEGIN_SRC emacs-lisp :block-id 33344847-5b8c-bb8f-614a-816e2b6bc0f8
      (use-package rainbow-delimiters
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
        :config
        (custom-set-faces
         ;; Thanks to https://ericscrivner.me/2015/06/better-emacs-rainbow-delimiters-color-scheme/
         '(rainbow-delimiters-depth-1-face ((t (:foreground "dark orange"))))
         '(rainbow-delimiters-depth-2-face ((t (:foreground "deep pink"))))
         '(rainbow-delimiters-depth-3-face ((t (:foreground "chartreuse"))))
         '(rainbow-delimiters-depth-4-face ((t (:foreground "deep sky blue"))))
         '(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
         '(rainbow-delimiters-depth-6-face ((t (:foreground "orchid"))))
         '(rainbow-delimiters-depth-7-face ((t (:foreground "spring green"))))
         '(rainbow-delimiters-depth-8-face ((t (:foreground "sienna1"))))))

    #+END_SRC

*** color-identifiers-mode
    Make things easier to see

    #+BEGIN_SRC emacs-lisp :block-id 5d8818b5-f936-2499-d201-41dc8f6b3c69
      (use-package color-identifiers-mode
        :ensure t
        :defer t
        :diminish color-identifiers-mode
        )
    #+END_SRC
*** show-paren
    Also a vital thing to keeping things highlighted

    #+BEGIN_SRC emacs-lisp :block-id 6c4e0031-3547-ac8a-ce02-b64f5d0e5de0
      (show-paren-mode t)

      (setq show-paren-style 'expression)
    #+END_SRC
** Display Buffer
   My modification on =display-buffer=.

   #+BEGIN_SRC emacs-lisp :block-id 8372b341-c122-bf85-8837-f3eab3c1c801
     (add-to-list
      'display-buffer-alist
      (cons
       (rx bos "*Process List*" eos)
       (cons 'display-buffer-same-window (list))))

     (add-to-list
      'display-buffer-alist
      (cons
       (rx bos "*Async Shell Command*")
       (cons 'display-buffer-same-window (list))))
   #+END_SRC

** Mode Line
   The mode line customization.

   #+BEGIN_SRC emacs-lisp :block-id 671f4309-6508-0ce6-97b4-3bb6060ab82d
     (use-package xpm
       :load-path fn/custom-script-dir
       :demand t)

     (use-package moder
       :load-path fn/custom-script-dir
       :demand t)
   #+END_SRC

** Candy Words
   I like when some words are candied with color.

   #+BEGIN_SRC emacs-lisp :block-id 7ac71aa0-fc7c-0271-3dbc-6de8ed7caa01
     (use-package text-candy
       :load-path fn/custom-script-dir
       :demand t)
   #+END_SRC

* Organizer
  Things to organize life in general

** alert
   A nice alert box would be nice

   #+BEGIN_SRC emacs-lisp :block-id 87b106b9-401f-cf0e-35ef-366900cc6198
     (defconst fn/alert-package-dir (expand-file-name "alert/" fn/custom-module-dir)
       "My customized alert package")

     (unless noninteractive
       (use-package alert
         :load-path fn/alert-package-dir
         :demand t
         :config
         (setq alert-default-style 'libnotify
            alert-log-messages t)

         (defun fn/alert-log-open ()
           "Open alert log."
           (interactive)
           (if (fboundp 'alert--log-open-log)
               (alert--log-open-log)
             (error "No alert logs yet")))

         ;; HACK: Bug #30 in alert to allow default style override
         (alert-add-rule)))
   #+END_SRC

** epa
   Encryption is a must

   Credits to [[http://conornash.com/2014/03/transparently-encrypt-org-files-in-emacs/][Conor Nash]] for this

   #+BEGIN_SRC emacs-lisp :block-id 6d18d023-ad50-2b2d-ee64-7e227cc1ad57
     (require 'epa-file)
     (epa-file-enable)

     (defun fn/backup-each-save-filter (filename)
       (let ((ignored-filenames
              '("\\.gpg$"))
             (matched-ignored-filename nil))
         (mapc
          (lambda (x)
            (when (string-match x filename)
              (setq matched-ignored-filename t)))
          ignored-filenames)
         (not matched-ignored-filename)))

     (setq backup-each-save-filter-function 'fn/backup-each-save-filter)

     (setq enable-local-variables :safe)

     (add-to-list 'safe-local-variable-values '(auto-save-default))
     (add-to-list 'safe-local-variable-values  '(backup-inhibited . t))
     (add-to-list 'safe-local-variable-values '(epa-file-encrypt-to))

     (add-to-list 'auto-mode-alist (cons "\\.org\\.gpg\\'" 'org-mode))
   #+END_SRC
** org
   org-mode my buddy. This is filed under external modes since I download a new copy of org mode to be updated.

   Some basic setup which I use =org-drill= and =org-journal=

   Here is a reference to the  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Time-Parsing.html][date time format]].

   #+BEGIN_SRC emacs-lisp :block-id 4f5f3d2b-61ae-d33b-8316-4c20b3e9c8c0
     (use-package org
       :bind (("C-c l" . org-store-link)
              ("C-c a" . org-agenda)
              ("C-c h" . helm-org-in-buffer-headings)
              ("C-c c" . org-capture))
       :config
       ;; org files
       (defconst fn/org-dir (expand-file-name "~/Fakespace/nobody-library")
         "Main library for org files")

       (defconst fn/org-default-capture-file (expand-file-name "capture.org" fn/org-dir)
         "Main capture org file")

       (defconst fn/org-main-file (expand-file-name "main.org" fn/org-dir)
         "Main org planning file")

       (defconst fn/org-todo-file (expand-file-name "todo.org" fn/org-dir)
         "Main org todo file")

       (defconst fn/org-event-file (expand-file-name "event.org" fn/org-dir)
         "My event planning file")

       (setq org-id-locations-file (expand-file-name "org-id-locations" fn/cache-dir)
          org-directory (concat fn/org-dir "/"))


       (add-to-list 'savehist-additional-variables 'org-insert-link-history)


       ;; Same windowed
       (defun fn/org-switch-to-buffer-other-window (&rest args)
         "This is an hacked form of `org-switch-to-buffer-other-window' to make it open in the same window."
         (org-no-popups
          (apply #'switch-to-buffer args)))

       (fset 'org-switch-to-buffer-other-window #'fn/org-switch-to-buffer-other-window)

       (defun fn/org-ignore-delete-other-windows (orig-fun &rest args)
         "Advice ORIG-FUN to ignore `delete-other-windows'"
         (prog2
             (advice-add 'delete-other-windows :override #'ignore)
             (apply orig-fun args)
           (advice-remove 'delete-other-windows #'ignore))))

     (use-package org-plus-contrib
       :ensure t
       :disabled t
       :after org)
   #+END_SRC

   I prefer to see my main org file on boot

   #+BEGIN_SRC emacs-lisp :block-id 257c9465-3051-7e92-e91d-762f3ec6b8be
     (defun fn/find-main-org-file ()
       (interactive)
       (find-file fn/org-main-file))
   #+END_SRC

*** org-src
    Configuration for =org-src=

    #+BEGIN_SRC emacs-lisp :block-id 1763cf1c-2a1f-1dc3-f38a-d027209d7bab
      (use-feature org-src
        (org)
        (setq org-src-window-setup 'current-window)

        (defun fn/org-src-inhibit-save-window-configuration ()
          "Disable org-src from saving the window configuration"
          ;; HACK: This uses an internal variable, might be unstable
          (setq org-src--saved-temp-window-config nil))

        (add-hook 'org-src-mode-hook #'fn/org-src-inhibit-save-window-configuration))

      (use-feature org-src-alert
        (org alert)
        nil)
      (use-feature org-todo
        (org)
        (setq org-todo-keywords
              '((sequence "TODO(t)" "PENDING(p)" "|" "DONE(d)" "CANCELLED(c)")
                (sequence "EVENT(e)" "|" "ACCEPT(a)" "DECLINE(D)" ))))

      (use-feature org-src-desktop
        (org desktop)
        (add-to-list 'desktop-modes-not-to-save 'org-src-mode))
    #+END_SRC

*** org-capture
    More configurations for the capture

    #+BEGIN_SRC emacs-lisp :block-id 42c9d746-9fe2-506f-2f27-a44df1f38666
      (use-feature org-capture
        (org)
        (setq org-capture-templates
           (list
            (list "t" "Todo" 'entry
               (list 'file+headline fn/org-todo-file "Todo")
               "* TODO %?\n   %i")
            (list "e" "Event" 'entry
               (list 'file+headline  fn/org-event-file "Events")
               "* %? :event:")))

        ;; Same window
        (advice-add 'org-capture-place-template :around #'fn/org-ignore-delete-other-windows))
    #+END_SRC

*** org-agenda
    More configuration for org-agenda

    #+BEGIN_SRC emacs-lisp :block-id 9ef84ce7-49a3-4194-b3f1-4f7c0ac99aff
      (use-feature org-agenda
        (org)
        (setq org-agenda-span 14 ;; Fortnight

              org-agenda-window-setup 'current-window

              org-agenda-files (list
                                fn/org-main-file
                                fn/org-todo-file
                                fn/org-event-file))


        (advice-add 'org-agenda-get-restriction-and-command :around #'fn/org-ignore-delete-other-windows))
    #+END_SRC

*** org-refile
    Some refiling actions perhaps?

    #+BEGIN_SRC emacs-lisp :block-id feb2e234-a068-32db-88fc-46455f786fa4
      (use-feature org-archive
        (org)
        (setq org-log-refile 'time
              org-refile-targets nil))
    #+END_SRC

*** org-archiving
    Archiving is needed to avoid bloating.

    #+BEGIN_SRC emacs-lisp :block-id e28c5744-034d-3b02-dba6-908cb8af9bb9
      (use-feature org-refile
        (org)
        (defconst fn/org-archive-file (expand-file-name "archive.org" fn/org-dir)
          "My archiving file.  Handy in just one neat location.")

        (defconst fn/org-archive-format "* %s"
          "Just archive under the file header.")


        (setq org-archive-location
              (format
               "%s::%s"
               fn/org-archive-file
               fn/org-archive-format))


        (defun fn/org-archive-done-agenda-tasks ()
          "Archive done agenda tasks."
          (message "Archiving done agenda tasks.")
          (org-map-entries
           (lambda ()
             (when (org-entry-is-done-p)
               (org-archive-subtree)))
           t 'agenda))

        ;; Archive done tasks on m
        (add-hook 'after-init-hook #'fn/org-archive-done-agenda-tasks))
    #+END_SRC

*** org-journal
    Having a journal is good

    #+BEGIN_SRC emacs-lisp :block-id 8001477c-95ea-ea34-54a7-094ad6f5ff4c
      (unless noninteractive
        (use-package org-journal
          :ensure t
          :after org
          :bind (:map fn-standard-prefix-map
                      ("j" . org-journal-new-entry)) ;; C-c j conflicts with normal org-mode
          :config
          (setq org-journal-dir
             (expand-file-name "diary/" fn/org-dir))

          (setq org-journal-date-format "%Y-%b-%d %a" ;; YYYY-MMM-DD DAY
             org-journal-time-format "%T ") ;; HH:MM:SS and the space is required

          (setq org-journal-file-format "%Y-%m-%d.journal.org.gpg") ;; Encryption via epa
          (setq org-journal-find-file 'find-file)

          (defun fm/insert-private-file-headers ()
            (interactive)
            (add-file-local-variable-prop-line 'backup-inhibited t)
            (add-file-local-variable-prop-line 'auto-save-default nil))

          (defun fm/insert-org-gpg-headers ()
            (interactive)
            (add-file-local-variable-prop-line
             'epa-file-encrypt-to (list "fnmurillo@yandex.com"))
            (fm/insert-private-file-headers))

          (defun fmj/insert-summary-block ()
            "Insert summary block at point, this is pretty much #+BEGIN_SRC except summary"
            (interactive)
            (let ((summary-block
                 (string-join (list "#+BEGIN_SUMMARY"
                                 "Something happened but I was too lazy to write it down"
                                 "#+END_SUMMARY")
                              "\n")))
              (insert (concat summary-block "\n"))))

          (defun fmj/insert-org-journal-headers ()
            (interactive)
            (fm/insert-org-gpg-headers)

            (end-of-visual-line)
            (newline-and-indent)

            (when (string-match "\\(20[0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]\\)"
                                (buffer-name))
              (let ((year  (string-to-number (match-string 1 (buffer-name))))
                  (month (string-to-number (match-string 2 (buffer-name))))
                  (day (string-to-number (match-string 3 (buffer-name))))
                  (datim nil))
                (setq datim (encode-time 0 0 0 day month year))

                (insert "#+STARTUP: content\n")
                (insert (format-time-string
                         "#+TITLE: Journal Entry - %Y-%b-%d %a\n" datim))

                (fmj/insert-summary-block)


                (insert (format-time-string
                         "* %Y-%b-%d %a" datim)))))

          (auto-insert-mode t)
          (setq auto-insert-query t) ;; Don't ask, just put it in there
          (add-hook 'find-file-hook 'auto-insert)

          (add-to-list 'auto-insert-alist '(".*\.org\.gpg\\'" . fm/insert-org-gpg-headers))
          (add-to-list 'auto-insert-alist '(".*\.private.org\\'" . fm/insert-private-file-headers))
          (add-to-list 'auto-insert-alist '(".*\.journal.org.gpg\\'" . fmj/insert-org-journal-headers))

          (use-feature org-journal-mode--mode-icon
            (all-the-icons)
            (fn/add-major-mode-icon
             'org-journal-mode
             (list 'all-the-icons-faicon "pencil-square-o" :v-adjust 0.0)))))
    #+END_SRC

*** org-reveal
    A nice presentation framework

    #+BEGIN_SRC emacs-lisp :block-id 3f6d71ed-f861-c6a4-d043-820b5f369b1d
      (use-package ox-reveal
        :ensure t
        :after org-plus-contrib
        :config
        (setq org-reveal-root "file:////home/fnmurillo/Fakespace/reveal-js")

        (define-minor-mode fn-reveal-editing
          "Some editing enhancement when editing org-reveal files"
          :lighter " FnRevealer"
          :init-value nil
          :global nil
          :keymap (let* ((map (fn/make-prefixed-keymap (kbd "C-c b")))
                         (tangle-current-file
                          (lambda ()
                            (interactive)
                            (let* ((current-file (buffer-file-name))
                                   (target-file (replace-regexp-in-string ".org" ".js" current-file))
                                   (target-lang "javascript"))
                              (org-babel-tangle-file current-file target-file target-lang))))
                         (export-reveal
                          (lambda ()
                            (interactive)
                            (message "Exporting %s" (buffer-file-name))
                            (org-reveal-export-to-html t))))

                    (define-key map (kbd "C-p") tangle-current-file)
                    (define-key map (kbd "C-e") export-reveal)
                    map)
          (let ((export-reveal
                 (lambda ()
                   (when fnr/enable-auto-export-on-save
                     (message "Auto exporting %s" (buffer-file-name))

                     (org-reveal-export-to-html t)))))
            (add-hook 'after-save-hook export-reveal t t))

          (make-variable-buffer-local
           (defvar fnr/enable-auto-export-on-save t
             "When non-nil. auto exports org-reveal files on save"))))
    #+END_SRC
*** org-clock
    Configuration for org-clock

    #+BEGIN_SRC emacs-lisp :block-id 1baf9871-3051-5af4-88be-83bbb6acd865
      (use-feature org-clock
        (org)
        (setq org-log-done 'time)

        (defun fn/clock-todo-change ()
          "A nice little hook that clocks in when a todo is change to PENDING"
          (let ((new-state org-state))
            (pcase new-state
              ("PENDING" (org-clock-in))
              (_ nil))))

        (add-hook 'org-after-todo-state-change-hook #'fn/clock-todo-change))
    #+END_SRC

*** org-drill
    Flash cards are a must

    #+BEGIN_SRC emacs-lisp :block-id ff080889-3108-6353-b008-70a78290ef1c
      (unless noninteractive
        (use-feature org-drill
          (org)
          (use-package org
            :after org
            :bind (:map fn-standard-prefix-map
                        ("D" . org-drill))
            :demand t
            :config
            (add-to-list 'org-modules 'org-drill)

            (defconst fn/org-review-file (expand-file-name "learning.org" fn/org-dir)
              "Main org drill files")

            (add-to-list 'org-capture-templates
                         (list "r" "Review/Remember" 'entry
                            (list 'file+headline fn/org-review-file "Learning Notes")
                            "* %? :drill:\n  CREATED_ON: %T"))

            (add-to-list 'org-capture-templates
                         (list "m" "Music Piece" 'entry
                            (list 'file+headline fn/org-review-file "Music Pieces")
                            "* %? :drill:music:\n  CREATED_ON: %T"))

            (add-to-list 'org-capture-templates
                         (list "v" "Technical Video" 'entry
                            (list 'file+headline fn/org-review-file "Technical Video")
                            "* %? :drill:video:\n  CREATED_ON: %T"))

            (add-to-list 'org-agenda-files fn/org-review-file)

            (setq org-drill-scope
               (list fn/org-review-file)))))
    #+END_SRC
*** org-mobile
    Mobile org document

    #+BEGIN_SRC emacs-lisp :block-id 0a711e82-e427-fbe9-3af4-e0b075b6236d
      (use-feature org-mobile
        (org)
        (defconst fn/org-mobile-directory (expand-file-name "mobile" fn/org-dir)
          "My org mobile directory")

        (defconst fn/org-mobile-inbox-directory (expand-file-name "mobile-pull" fn/org-dir)
          "My org mobile directory")


        (setq org-mobile-directory  fn/org-mobile-directory
              org-mobile-inbox-for-pull fn/org-mobile-inbox-directory

              org-mobile-files (list
                                fn/org-todo-file
                                fn/org-event-file
                                ))

        (global-set-key (kbd "C-c n o p") #'org-mobile-push)
        (global-set-key (kbd "C-c n o l") #'org-mobile-pull))
    #+END_SRC

** flyspell
   Having a good spell checker is a must. I use =flyspell= although I have read issues about it

   #+BEGIN_SRC emacs-lisp :block-id d49639d7-14d6-68a0-5afa-25bae73f3762
     (unless noninteractive
       (use-package flyspell
         :ensure t
         :if (not (eq system-type 'windows-nt))
         :defer t
         :diminish flyspell-mode
         :init
         (add-hook 'org-mode-hook 'flyspell-mode t)))
   #+END_SRC

** dired
   Directory management for Emacs

   #+BEGIN_SRC emacs-lisp :block-id 8a7ec4af-3627-97ac-62d0-bb3e2f54f512
     (require 'dired-x) ;; Allows multi open marked files

     (setq dired-dwim-target t

        dired-listing-switches "-alh"

        dired-recursive-copies 'always ;; Don't ask because I did it
        dired-recursive-deletes 'always

        dired-isearch-filenames t

        dired-copy-preserve-time t)

     (dired-async-mode t)

     (add-hook 'dired-mode-hook 'dired-hide-details-mode)

     (use-feature wdired-mode--mode-icon
       (all-the-icons)
       (fn/add-major-mode-icon
        'wdired-mode
        (list 'all-the-icons-octicon "diff" :v-adjust 0.0)))
   #+END_SRC

*** image-dired
    Text is not enough, images are important too

    #+BEGIN_SRC emacs-lisp :block-id cf2771df-8638-4516-f99e-ece5acfa3100
      (use-package image-dired
        :ensure t
        :after dired
        :defer t
        :config
        (setq image-dired-dir (expand-file-name "image-dired" fn/cache-dir-name)

              image-dired-gallery-dir image-dired-dir

              image-dired-db-file
              (expand-file-name ".image-dired_db" image-dired-dir)
              image-dired-temp-image-file
              (expand-file-name ".image-dired_temp" image-dired-dir)
              image-dired-temp-image-file
              (expand-file-name ".image-dired_rotate_temp" image-dired-dir)

              image-dired-main-image-directory "~/Pictures"))
    #+END_SRC

*** tmtxt
    Experimental =dired= with =rsync= all thanks to [[https://github.com/tmtxt][tmtxt]]

    #+BEGIN_SRC emacs-lisp :block-id 6a5ed4fb-b253-34b0-5ade-9c7635be9ba6
      (defconst fn/tmtxt-package-dir (expand-file-name "tmtxt/" fn/custom-module-dir)
        "tmtxt package directory")

      (use-package tmtxt-async-tasks
        :load-path fn/tmtxt-package-dir
        :defer 2
        :after dired
        :config
        (setq-default tat/window-close-delay "10"
                      tat/window-height 5))

      (use-package tmtxt-dired-async
        :after tmtxt-async-tasks
        :config
        (setq-default tda/rsync-arguments "-avzh --progress")

        (define-key dired-mode-map (kbd "C-c C-r") 'tda/rsync)
        (define-key dired-mode-map (kbd "C-c C-t") 'tda/rsync-delete)

        (define-key dired-mode-map (kbd "C-c C-a") 'tda/rsync-multiple-mark-file)
        (define-key dired-mode-map (kbd "C-c C-e") 'tda/rsync-multiple-empty-list)
        (define-key dired-mode-map (kbd "C-c C-d") 'tda/rsync-multiple-remove-item)
        (define-key dired-mode-map (kbd "C-c C-v") 'tda/rsync-multiple)
        (define-key dired-mode-map (kbd "C-c C-z") 'tda/zip)
        (define-key dired-mode-map (kbd "C-c C-u") 'tda/unzip)

        (define-key dired-mode-map (kbd "C-c C-s") 'tda/get-files-size)

        (define-key dired-mode-map (kbd "C-c C-q") 'tda/download-to-current-dir)
        (define-key dired-mode-map (kbd "C-c C-l") 'tda/download-clipboard-link-to-current-dir))
    #+END_SRC

** tramp
   Tramp is too good to pass up

   #+BEGIN_SRC emacs-lisp :block-id 842e3219-547e-cef9-5564-15541c881dc4
     (use-package tramp
       :config
       (setq tramp-persistency-file-name (expand-file-name "tramp" fn/cache-dir)

          tramp-default-user (getenv "USER")))
   #+END_SRC

** ledger
   Something to keep track of my finances

   #+BEGIN_SRC emacs-lisp :block-id 4e3b93da-bda6-0881-7e81-3e23e833f1cc
     (defconst fn/ledger-file (expand-file-name "ledger.dat.gpg" "~/Fakespace/nobody-library")
       "My ledger file.")

     (use-package ledger-mode
       :ensure t
       :defer t
       :config
       (setq ledger-clear-whole-transactions t)

       ;; Encrypting my ledger
       ;; Reference: https://groups.google.com/forum/#!topic/ledger-cli/_umUQakuVkM
       (setq ledger-reports
             '(("bal" "gpg --no-tty -d %(ledger-file) | ledger -f - bal")
               ("reg" "gpg --no-tty -d %(ledger-file) | ledger -f - reg")
               ("payee" "gpg --no-tty -d %(ledger-file) ledger -f - reg @%(payee)")
               ("account" "gpg --no-tty -d %(ledger-file) | ledger -f - reg %(account)")))

       (use-feature ledger-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'ledger-mode
          (list 'all-the-icons-faicon "money" :v-adjust -0.1)))

       (use-feature ledger-report-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'ledger-report-mode
          (list 'all-the-icons-faicon "line-chart" :v-adjust -0.1)))

       (defun fn/find-ledger-file ()
         "Find ledger file."
         (interactive)
         (find-file fn/ledger-file)))
   #+END_SRC

** engine
   Instant search with Emacs, sign me up.

   #+BEGIN_SRC emacs-lisp :block-id 5a8c28d6-3439-9256-53e0-b11277d340af
     (use-package engine-mode
       :ensure t
       :defer t
       :config
       (engine-mode t)

       (engine/set-keymap-prefix (kbd "C-c s"))
       (setq engine/browser-function 'browse-url-firefox)

       (defengine amazon
         "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")

       (defengine duckduckgo
         "https://duckduckgo.com/?q=%s"
         :keybinding "d")

       (defengine emacsgo
         "https://duckduckgo.com/?q=emacs+%s"
         :keybinding "e")

       (defengine github
         "https://github.com/search?ref=simplesearch&q=%s"
         :keybinding "g")

       (defengine project-gutenberg
         "http://www.gutenberg.org/ebooks/search/?query=%s")

       (defengine rfcs
         "http://pretty-rfc.herokuapp.com/search?q=%s")

       (defengine stack-overflow
         "https://stackoverflow.com/search?q=%s"
         :keybinding "t")

       (defengine twitter
         "https://twitter.com/search?q=%s")

       (defengine wikipedia
         "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
         :keybinding "w"
         :docstring "Searchin' the wikis.")

       (defengine wiktionary
         "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

       (defengine wolfram-alpha
         "http://www.wolframalpha.com/input/?i=%s")

       (defengine youtube
         "http://www.youtube.com/results?aq=f&oq=&search_query=%s"))
   #+END_SRC
** woman
   Man pages are nice

   #+BEGIN_SRC emacs-lisp :block-id 515a39e1-ca17-43ac-aea5-2de31b5005de
     (use-package woman
       :ensure t
       :defer t
       :bind (:map fn-standard-prefix-map
                   ("C-w" . woman)))
   #+END_SRC
** gnus
   The ultimate mail browser, majority of the configuration is in =~/.gnus=

   #+BEGIN_SRC emacs-lisp :block-id ee1ad1cc-2dcc-df04-b3d3-20a710a335ea
     (use-package gnus
       :bind (:map fn-standard-prefix-map
                   ("g" . gnus)))
   #+END_SRC

** conkeror
   Conkeror magic

   #+BEGIN_SRC emacs-lisp :block-id de8e33f4-c290-b278-13e1-0f4178ff2746
     (use-package conkeror-minor-mode
       :ensure t
       :defer t)
   #+END_SRC

** emacsshot
   Sometimes when you just need proof

   #+BEGIN_SRC emacs-lisp :block-id 00293c55-daab-3649-b480-7b000eb0a216
     (use-package emacsshot
       :ensure t
       :bind (:map fn-standard-prefix-map
                   ("C-c w" . emacsshot-snap-window)
                   ("C-c f" . emacsshot-snap-frame))
       :config
       (defconst fn/emacsshot-dir (expand-file-name "emacsshot" fn/extra-dir)
         "My screenshot directory")

       (unless (f-exists? fn/emacsshot-dir)
         (make-directory fn/emacsshot-dir))

       (setq emacsshot-with-timestamp t
             emacsshot-snap-frame-filename (expand-file-name "my-frame.png" fn/emacsshot-dir)
             emacsshot-snap-window-filename (expand-file-name "my-window.png" fn/emacsshot-dir)))
   #+END_SRC

** camcorder
   Making demonstrations in Emacs is a must. My thanks to [[http://blog.yitang.uk/2015/09/24/how-to-create-a-screencast-gif-in-emacs/][this blog post.]]

   #+BEGIN_SRC emacs-lisp :block-id 1ecfd02f-87eb-6c8a-0e20-68780b2e1e7b
     (use-package camcorder
       :ensure t
       :defer t
       :bind (("<f10>" . camcorder-record))
       :config
       (defconst fn/camcorder-dir (expand-file-name "camcorder" fn/extra-dir)
         "My camcorder directory.")

       (setq camcorder-output-directory fn/camcorder-dir
          camcorder-gif-output-directory fn/camcorder-dir
          camcorder-frame-parameters
          (list (cons 'name "Screencast")
             (cons 'height (max (/ (frame-height) 2) 40 ))
             (cons 'width (max (/ (frame-width) 2) 80 ))
             (cons 'top 20)
             (cons 'left 20)))


       (defvar fn/camcorder-state nil
         "The state of the recording. Possible values are `nil', `recording' and `paused'.")


       (defun fn/camcorder-state-start ()
         "Set the start state of the recording."
         (setq fn/camcorder-state 'recording)

         (select-frame-set-input-focus camcorder-recording-frame))

       (defun fn/camcorder-state-pause ()
         "Set the pause state of the recording."
         (cond
          ((null fn/camcorder-state)
           nil)
          ((eq fn/camcorder-state 'recording)
           (setq fn/camcorder-state 'paused))
          ((eq fn/camcorder-state 'paused)
           (setq fn/camcorder-state 'recording))))

       (defun fn/camcorder-state-stop ()
         "Set the stop state of the recording."
         (setq fn/camcorder-state nil))

       (advice-add 'camcorder-record :after  #'fn/camcorder-state-start)
       (advice-add 'camcorder-pause :before  #'fn/camcorder-state-pause)
       (advice-add 'camcorder-stop :before #'fn/camcorder-state-stop))
   #+END_SRC

** list-processes+
   A better way of viewing processes

   #+BEGIN_SRC emacs-lisp :block-id b627e0fd-bda7-5a5a-cec1-ecba55ba606d
     (use-package list-processes+
       :ensure t
       :defer t
       :bind (:map fn-standard-prefix-map
                   ("M-p" . list-processes+)))
   #+END_SRC

* Code Monkey
  Modes for my programming experiences

** Support
   Generic support for coding

*** Whitespace Cleanup
    Some nice whitespace cleanup.

    #+BEGIN_SRC emacs-lisp :block-id 177ce3cd-1ce9-388e-0edb-22c0a08ec60b
      (use-package ws-butler
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'ws-butler-mode)
        (add-hook 'org-mode-hook 'ws-butler-mode))
    #+END_SRC

*** Indent Everywhere
    Just indent before I save when working with code.

    #+BEGIN_SRC emacs-lisp :block-id fa5c65de-552d-f599-b71c-d25689845d72
      (make-variable-buffer-local
       (defvar fn/indent-buffer-on-save t
         "When non-nil, indent buffer on save"))

      (defun fn/indent-buffer ()
        "The editor itself is the best formatter"
        (interactive)
        (when fn/indent-buffer-on-save
          (message "Indenting buffer in %s." (current-buffer))
          (indent-region (point-min) (point-max))))

      (defun fn/indent-before-save ()
        "Indent buffer after saving to make handling the editor sane.
      This somehow disregards SVN formatting in favor of the editor"
        (add-hook 'before-save-hook #'fn/indent-buffer nil t))

      (defun fn/disable-indent-buffer-before-save ()
        "Disable `fn/indent-before-save' for a specific mode."
        (setq-local fn/indent-buffer-on-save nil))

      (add-hook 'makefile-mode-hook 'fn/disable-indent-buffer-before-save t)

      (add-hook 'prog-mode-hook 'fn/indent-before-save)
    #+END_SRC

*** smartparens
    This is as handy as =paredit=

    #+BEGIN_SRC emacs-lisp :block-id 6dd6ef74-ec81-2ed7-f9d2-a02fc27bb4f0
      (use-package smartparens
        :diminish smartparens-mode
        :ensure t
        :init
        (add-hook 'prog-mode-hook 'smartparens-mode)
        :config
        (require 'smartparens-config)

        (define-key smartparens-mode-map (kbd "C-<left>") 'sp-forward-slurp-sexp)
        (define-key smartparens-mode-map (kbd "C-<up>") 'sp-splice-sexp))
    #+END_SRC

*** paredit-everywhere
    [[paredit]] also works well with other modes as well but not really
    primarily

    #+BEGIN_SRC emacs-lisp :block-id bfff7479-af59-caee-1140-9fe693e6f838
      (use-package paredit-everywhere
        :ensure t
        :defer t
        :init
        (add-hook 'prog-mode-hook 'paredit-mode))
    #+END_SRC

*** flycheck
    Syntax checking is very important

    #+BEGIN_SRC emacs-lisp :block-id 0bd8c66a-906d-497b-c519-52c3cd914bfc
      (unless noninteractive
        (use-package flycheck
          :ensure t
          :defer  t
          :diminish flycheck-mode
          :init
          (add-hook 'prog-mode-hook 'flycheck-mode)
          :config
          (setq flycheck-highlighting-mode 'lines
             flycheck-check-syntax-automatically '(save mode-enabled 'idle-change)
             flycheck-checker-error-threshold nil)))

      (use-package flycheck-pos-tip
        :ensure t
        :after flycheck
        :config
        (flycheck-pos-tip-mode t))

      (use-package flycheck-status-emoji
        :ensure t
        :after flycheck)

      (use-package flycheck-package
        :ensure t
        :after flycheck
        :config
        (flycheck-package-setup))
    #+END_SRC

*** magit
    Enough said, [[https://github.com/magit/magit][magit]] is the best git client you can get anywhere.

    #+BEGIN_SRC emacs-lisp :block-id 25b4c3c1-0062-54ae-4d23-b3070fdcb4a2
      (use-package magit
        :ensure t
        :if (version<= "24.4.4" emacs-version)
        :bind (("C-c g" . magit-status)
               ("M-g b" . magit-blame))
        :init
        (setq magit-push-always-verify t)
        :config
        (defun fq/display-magit-on-same-buffer (buffer)
          (if magit-display-buffer-noselect
              (magit-display-buffer-traditional buffer)
            (display-buffer-same-window buffer nil)))

        (setq magit-display-buffer-function #'fq/display-magit-on-same-buffer)

        (remove-hook 'magit-pre-display-buffer-hook 'magit-save-window-configuration))

      (use-package git-timemachine
        :ensure t
        :defer t
        :bind (("M-g t" . git-timemachine)))

      (use-package git-gutter
        :ensure t
        :diminish git-gutter-mode
        :defer t
        :config
        (global-git-gutter-mode t))
    #+END_SRC

**** magithub
     A tool to help with github.

     #+BEGIN_SRC emacs-lisp :block-id 87ac7ebd-43ae-febe-d9e7-634d5b811f5d
       ;; Dubious extension for the meantime
       (use-package magithub
         :ensure t
         :defer t)
     #+END_SRC

**** magit-svn
     Support for SVN with the awesome =magit= interface

     #+BEGIN_SRC emacs-lisp :block-id 4d87550e-fd6c-1c90-f8a4-115430c57e63
       (use-package magit-svn
         :ensure t
         :after magit)
     #+END_SRC
*** gist
    GitHub integration with gists

    #+BEGIN_SRC emacs-lisp :block-id c32da544-1578-c114-de7c-f36600444768
      (use-package gist
        :ensure t
        :defer t)
    #+END_SRC

*** pastebin
    Paste bin integration

    #+BEGIN_SRC emacs-lisp :block-id 5fdd0f40-7058-106a-2aa2-d2025fea8502
      (defconst fn/emacs-pastebin-package-dir (expand-file-name "emacs-pastebin/" fn/custom-module-dir)
        "My emacs pastebin package directory.")

      (unless noninteractive
        (use-package neopastebin
          :load-path fn/emacs-pastebin-package-dir
          :bind (:map fn-standard-prefix-map
                      ("C-y n" . pastebin-new)
                      ("C-y l" . pastebin-list-buffer-refresh))
          :init
          (setq pastebin-data-dir (expand-file-name "pastebin-data" fn/cache-dir))))
    #+END_SRC

*** ag
    The silver searcher is a fine tool

    #+BEGIN_SRC emacs-lisp :block-id 8038dda0-39ce-19f3-21bd-7ab7acccfb25
      (unless noninteractive
        (use-package ag
          :ensure t
          :demand t
          :config
          (setq ag-highlight-search t

             ag-reuse-window t
             ag-reuse-buffers t)))
    #+END_SRC

    With [[helm]]

    #+BEGIN_SRC emacs-lisp :block-id 7905e7f3-3641-4831-c407-209cf00ee1c4
      (use-feature helm-ag
        (helm ag)
        (use-package helm-ag
          :ensure t))
    #+END_SRC

*** dumb-jump
    Dump jumping with =ag=

    #+BEGIN_SRC emacs-lisp :block-id 7903e306-7bfa-6492-4d48-0ff52268ebe4
      (use-package dumb-jump
        :ensure t
        :bind (:map fn-standard-prefix-map
                    ("C-d g" . dumb-jump-go)
                    ("C-d b" . dumb-jump-back)))
    #+END_SRC

*** ggtags
    Jump and go is really a must needed feature

    #+BEGIN_SRC emacs-lisp :block-id 6fd3ec7a-1687-195e-c6d4-93cb1f00cb8c
      (use-package ggtags
        :ensure t
        :defer t
        :functions 'ggtags-eldoc-function
        :init
        (defun fn/ggtags-c-like-mode ()
          "Turn on GGTAGS if it is a c like mode"
          (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'javascript-mode)
            (ggtags-mode t)))

        (add-hook 'prog-mode-hook #'fn/ggtags-c-like-mode)
        :config
        (use-feature eldoc-ggtags
          (eldoc)
          (setq-local eldoc-documentation-function #'ggtags-eldoc-function))

        (use-package helm-gtags
          :ensure t
          :after ggtags
          :config
          nil))
    #+END_SRC

*** helm-swoop
    Something to speed up searching

    #+BEGIN_SRC emacs-lisp :block-id 881b51d2-4f5b-5e1c-5149-4d44603a0acc
      (require 'dash)

      (use-package helm-swoop
        :ensure t
        :after helm
        :bind (("M-i" . helm-swoop)
               ("C-c M-i" . helm-multi-swoop))
        :config
        (define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
        (define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
        (define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)


        (setq helm-swoop-pre-input-function (-const "")))

      (use-package wgrep-helm
        :ensure t
        :after helm
        :config
        (setq wgrep-auto-save-buffer t))
    #+END_SRC

*** wordgen
    Random word generator for random test data.

    #+BEGIN_SRC emacs-lisp :block-id f0300ef0-69cb-0157-dab6-59253b365cd4
      (use-package wordgen
        :ensure t
        :defer t
        :config
        nil)
    #+END_SRC

*** rest-client
    I need REST.

    #+BEGIN_SRC emacs-lisp :block-id e318e40f-91a1-846d-f12e-677e088bbc60
      (use-package restclient
        :ensure t
        :mode ("\\.http\\'" . restclient-mode)
        :defer t
        :config
        ;; Setting it up as editing mode
        (add-hook 'restclient-mode-hook 'whitespace-mode)

        (defun fn/restclient-indent-function ()
          "Thanks to `https://github.com/pashky/restclient.el/issues/85'"
          (require 'js)
          (setq-local indent-line-function 'js-indent-line))

        (add-hook 'restclient-mode-hook 'fn/restclient-indent-function)


        (use-feature restclient-mode--mode-icon
          (restclient all-the-icons)
          (fn/add-major-mode-icon
           'restclient-mode
           (list 'all-the-icons-faicon "arrow-circle-o-up" :v-adjust -0.1)))

        (use-feature restclient-smartpar
          (restclient smartparens paredit)
          (add-hook 'restclient-mode-hook 'paredit-mode)
          (add-hook 'restclient-mode-hook 'smartparens-mode))


        (use-feature restclient-company
          (restclient company)
          (use-package company-restclient
            :ensure t
            :demand t
            :config
            (add-hook 'restclient-mode-hook 'company-mode)
            (add-to-list 'company-backends 'company-restclient)))

        (use-feature literate-restclient
          (restclient org)
          (use-package ob-restclient
            :ensure t
            :demand t
            :config
            (add-to-list 'org-babel-load-languages '(restclient . t)))))
    #+END_SRC

** Helper
   Specific helper modes

*** npm
    Call npm with Emacs
    #+BEGIN_SRC emacs-lisp :block-id d913e8d0-203e-b6cc-8415-5249a36691ba
      (use-package npm-mode
        :ensure t
        :defer t
        :bind (:map fn-standard-prefix-map
                    ("n" . npm-mode)))
    #+END_SRC

** Elisp
*** Mode
    This editor is the mode

    #+BEGIN_SRC emacs-lisp :block-id d58ae96e-8259-6f89-a9cc-781cd5dc5411
      (require 'dash)

      (defun fn/find-definition-at-point ()
        "This is find-function-at-point and find-variable-at-point meld into one"
        (interactive)
        (-if-let
            (point-pair (cond
                         ((symbolp (variable-at-point))
                          (find-variable-noselect
                           (variable-at-point)
                           nil))
                         ((function-called-at-point) (condition-case ex
                                                         (find-function-noselect (function-called-at-point) t)
                                                       ('error nil)))
                         (t nil)))
            (switch-to-buffer (car point-pair))
          (message "Could not find function or symbol definition or might be builtin")))

      (let ((custom-keymap (fn/make-work-keymap emacs-lisp-mode-map)))
        (define-key custom-keymap (kbd "j") #'fn/find-definition-at-point))
    #+END_SRC

*** Motion
    Makes you a good lisp developer and quite addictive to have

    #+BEGIN_SRC emacs-lisp :block-id 078952f1-01a4-261b-8409-f97b32f4c594
      (use-package paredit
        :ensure t
        :defer t
        :diminish paredit-mode
        :init
        (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook #'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'lisp-mode-hook #'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode))

      (use-feature paredit-eldoc
        (eldoc)
        (eldoc-add-command 'paredit-backward-delete
                           'paredit-close-round))
    #+END_SRC

*** Refactor
    Emacs Lisp refactor mode

    #+BEGIN_SRC emacs-lisp :block-id 4a347303-6e5c-e930-9be0-04e140652c6f
      (use-package emr
        :ensure t
        :defer t
        :init
        (define-key prog-mode-map (kbd "M-RET") 'emr-show-refactor-menu)
        (add-hook 'prog-mode-hook 'emr-initialize))
    #+END_SRC
*** Formatter
    Not really but nice to have for a lisp language

    #+BEGIN_SRC emacs-lisp :block-id 99328d86-830f-d570-c069-4cec1be23aab
      (use-package elisp-format
        :ensure t
        :defer t
        :disabled t
        :config
        (define-key emacs-lisp-mode-map (kbd "C-c C-f") 'elisp-format-region)

        (make-variable-buffer-local
         (defvar fn/elisp-format-on-save t
           "Enable elisp formatting on save"))

        (defun fn/elisp-format-buffer-on-save ()
          "Format elisp on save"
          (when fn/elisp-format-on-save
            (with-current-buffer (current-buffer)
              (message "Elisp formatting buffer %s" (current-buffer))
              (elisp-format-buffer))))

        (add-hook 'before-save-hook #'fn/elisp-format-buffer-on-save))
    #+END_SRC
*** Prettify
    Prettify some symbols to make it visible.

    #+BEGIN_SRC emacs-lisp :block-id cd91807f-6008-2cb5-5716-f6ee48077fc7
      (use-function prettify-elisp
        prettify-symbols-mode
        (add-hook
         'emacs-lisp-mode-hook
         (lambda ()
           (push '("require" . ?∈) prettify-symbols-alist)
           (push '("provide" . ?∋) prettify-symbols-alist)

           (push '("defun" . ?∫) prettify-symbols-alist)
           (push '("defun*" . ?∮) prettify-symbols-alist)
           (push '("lambda" . ?λ) prettify-symbols-alist)
           (push '("interactive" . ?Ι) prettify-symbols-alist)

           (push '("&rest" . ?…) prettify-symbols-alist)
           (push '("&optional" . ?⁇) prettify-symbols-alist)
           (push '("&key" . ?∴) prettify-symbols-alist)

           (push '("defvar" . ?ν) prettify-symbols-alist)
           (push '("define" . ?δ) prettify-symbols-alist)
           (push '("defconst" . ?φ) prettify-symbols-alist)

           (push '("defconst" . ?τ) prettify-symbols-alist)
           (push '("defface" . ?κ) prettify-symbols-alist)

           (push '("let" . ?▷) prettify-symbols-alist)
           (push '("let*" . ?▶) prettify-symbols-alist)

           (push '("lexical-let" . ?▭) prettify-symbols-alist)
           (push '("lexical-let*" . ?▬) prettify-symbols-alist)

           (push '("letrec" . ?●) prettify-symbols-alist)

           (push '("and" . ?∧) prettify-symbols-alist)
           (push '("or" . ?∨) prettify-symbols-alist)
           (push '("not" . ?¬) prettify-symbols-alist)

           (push '("t" . ?⊤) prettify-symbols-alist)
           (push '("nil" . ?⊥) prettify-symbols-alist)


           (push '("funcall" . ?→) prettify-symbols-alist)
           (push '("apply". ?↦) prettify-symbols-alist)


           (push '("setq" . ?≔) prettify-symbols-alist)
           (push '("setq-default" . ?⩴) prettify-symbols-alist)
           (push '("setf". ?≕) prettify-symbols-alist)


           (push '("list" . ?∅) prettify-symbols-alist)
           (push '("cons" . ?⊕) prettify-symbols-alist)


           (prettify-symbols-mode t))))
    #+END_SRC

*** Testing
    Some testing libraries

    #+BEGIN_SRC emacs-lisp :block-id ae82d02d-86fd-b37b-1489-6b873c8ec326
      (use-package buttercup
        :ensure t
        :defer t)
    #+END_SRC

*** Project
    Some packages to help making packages

    #+BEGIN_SRC emacs-lisp :block-id 08cd7439-df60-4b11-e8a1-17917ed8dd26
      (use-package cask-mode
        :ensure t
        :defer t)

      (use-feature cask-mode--mode-icon
        (all-the-icons)
        (fn/add-major-mode-icon
         'cask-mode
         (list 'all-the-icons-faicon "glass" :v-adjust 0.1)))

      (unless noninteractive
        (use-package header2
          :ensure t
          :demand t
          :functions auto-make-header
          :init
          (add-hook 'emacs-lisp-mode-hook 'auto-make-header)))

      (use-package overseer
        :ensure t
        :defer t
        :diminish 'overseer-mode
        :init
        (add-hook 'emacs-lisp-mode-hook #'overseer-mode))
    #+END_SRC

** Web
*** Mode
    The defacto mode for web development

    #+BEGIN_SRC emacs-lisp :block-id bd6a4ce6-0ec8-7977-cec4-2a9e0c66e2e9
      (use-package web-mode
        :ensure t
        :mode (("\\.tt\\'" . web-mode)
               ("\\.erb\\'" . web-mode)
               ("\\.html\\.ep\\'" . web-mode)
               ("\\.blade\\.php\\'" . web-mode)
               ("\\.hbs\\'" . web-mode))
        :init
        (dolist (hook '(emmet-mode))
          (add-hook 'web-mode-hook hook))
        :config
        (setq web-mode-enable-auto-pairing t
              web-mode-enable-auto-closing t
              web-mode-enable-current-element-highlight t
              web-mode-enable-current-column-highlight t))

      (use-package company-web
        :ensure t
        :after web)
    #+END_SRC

*** Editing
    I do a lot of HTML editing, YASnippet can do but emmet is better

    #+BEGIN_SRC emacs-lisp :block-id 25e01dcb-860b-9e0b-4fb9-b4d84c5a149d
      (use-package emmet-mode
        :ensure t
        :defer t
        :init
        (dolist (hook '(sgml-mode-hook css-mode-hook kolon-mode-hook))
          (add-hook hook 'emmet-mode)))
    #+END_SRC

*** CSS
    I use [[http://sass-lang.com/][sass]] for my jekyll blog

    #+BEGIN_SRC emacs-lisp :block-id 3de49f28-8f02-15e9-53f6-b8253b66114b
      (use-package sass-mode
        :ensure t
        :defer t
        :config
        ((add-to-list 'auto-mode-alist '("\\.sass\\'" . sass-mode))))
    #+END_SRC
** JavaScript
*** Mode
    The ultimate JS mode

    #+BEGIN_SRC emacs-lisp :block-id f4f7c05b-8948-6331-8550-71e06225c233
      (use-package js2-mode
        :ensure t
        :interpreter (("node" . js2-mode))
        :mode (("\\.\\(js\\|json\\)$" . js2-mode)
               ("\\.\\(jsx\\)$" . js2-jsx-mode))
        :defer t
        :config
        (add-hook 'js-mode-hook 'js2-minor-mode)

        (setq js2-highlight-level 3
              js2-mode-show-parse-errors nil
              js2-mode-show-strict-warnings nil

              js2-include-node-externs t
              js2-include-browser-externs t)

        (use-feature js2-jsx-mode--mode-icon
          (all-the-icons)
          (fn/add-major-mode-icon
           'js2-jsx-mode
           (list 'all-the-icons-alltheicon "javascript" :v-adjust 0.1))))

      (use-package js-doc
        :ensure t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook
                  (lambda ()
                    (define-key js2-mode-map (kbd "C-c i") #'js-doc-insert-function-doc)
                    (define-key js2-mode-map "@" 'js-doc-insert-tag)))


        (setq js-doc-mail-address user-mail-address
              js-doc-author (format "I am <%s>" js-doc-mail-address)
              js-doc-url "francismurillo.github.io"
              js-doc-license "GPL"))
    #+END_SRC

*** Refactor

    #+BEGIN_SRC emacs-lisp :block-id 66c12076-e02d-31ae-df2b-71906bbcff01
      (use-package js2-refactor
        :diminish js2-refactor-mode
        :ensure t
        :defer t
        :after js2-mode
        :init
        (add-hook 'js2-mode-hook #'js2-refactor-mode)
        :config
        (js2r-add-keybindings-with-prefix "C-c C-m"))
    #+END_SRC

*** Autocomplete
    A must have for Javascript development

    Sadly, =tern= slows me down somehow so I will be temporarily
    disabling it.

    #+BEGIN_SRC emacs-lisp :block-id 160244e2-307f-c1cd-e968-71453bad9095
      (defconst fn/tern-package-dir (expand-file-name "tern/" fn/custom-module-dir)
        "My performance customization on tern")

      (unless noninteractive
        (use-package tern
          :ensure t
          :diminish tern-mode
          :init
          (add-hook 'js2-mode-hook #'tern-mode)
          :config
          (setq tern-idle-time 10.0)

          (use-package company-tern
            :ensure t
            :after company
            :config
            (add-to-list 'company-backends 'company-tern))

          (use-feature tern-prodigy
            (tern)
            (prodigy-define-tag
              :name 'tern))))


      (unless noninteractive
        (use-feature company-flow
          (js2-mode company)
          (use-package company-flow
            :ensure t
            :demand t
            :config
            (add-to-list 'company-backends 'company-flow))))
    #+END_SRC

*** Linter
    My linter if you will for JS.

    #+BEGIN_SRC emacs-lisp :block-id da802e8e-8302-f301-51f5-6042384a98a7
      (unless noninteractive
        (use-feature flycheck-flow
          (flycheck)
          (use-package flycheck-flow
            :demand t
            :config
            (flycheck-add-next-checker 'javascript-eslint (cons t 'javascript-flow) t))))
    #+END_SRC

*** Formatter
    Formatter for js, choose your poison. I tried the three and still am.

    #+BEGIN_SRC emacs-lisp :block-id 11615658-000c-3d87-133c-a9c522788fef
      (use-package web-beautify
        :ensure t
        :after js2-mode)

      (use-package jsfmt
        :ensure t
        :after js2-mode
        :config
        (let ((custom-keymap (fn/make-work-keymap js2-mode-map)))
          (define-key custom-keymap (kbd "b") #'jsfmt)))

      (use-package eslint-fix
        :ensure t
        :after js2-mode
        :config
        (defun fn/eslint-fix-after-save ()
          "Apply eslint fix after save"
          (add-hook 'after-save-hook #'eslint-fix nil t))

        (add-hook 'js2-mode-hook #'fn/eslint-fix-after-save))
    #+END_SRC

*** Snippets
    Snippet support

    #+BEGIN_SRC emacs-lisp :block-id 7142c005-0729-b76e-8998-a7291dc11104
      (use-feature react-snippets
        (js2-mode yasnippet)
        (use-package react-snippets
          :ensure t))
    #+END_SRC

*** REPL
    Got to have those REPLs

    #+BEGIN_SRC emacs-lisp :block-id db197f38-5070-3f18-4777-273017d4f5bd
      (use-package nodejs-repl
        :ensure t
        :bind (("C-c C-n C-c" . nodejs-repl-send-buffer)
               ("C-c C-n C-r" . nodejs-repl-send-region)
               ("C-c C-n C-e" . nodejs-repl-send-last-sexp))
        :after js2-mode)

      (use-package skewer-mode
        :defer t
        :diminish skewer-mode
        :bind (("C-c K" . run-skewer))
        :ensure t
        :init
        (add-hook 'js2-mode-hook 'skewer-mode)
        (add-hook 'css-mode-hook 'skewer-css-mode)
        (add-hook 'html-mode-hook 'skewer-html-mode))
    #+END_SRC

*** Prettify
    My symbols for JS

    #+BEGIN_SRC emacs-lisp :block-id acb3e63d-ea49-d850-22c1-9e094a73b74a
      (use-function prettify-js2
        prettify-symbols-mode
        (use-feature prettify-js2
          (js2-mode)
          (add-hook 'js2-mode-hook
                    (lambda ()
                      (push '("import" . ?∈) prettify-symbols-alist)
                      (push '("export" . ?∋) prettify-symbols-alist)
                      (push '("default" . ?τ) prettify-symbols-alist)
                      (push '("from" . ?∋) prettify-symbols-alist)

                      (push '("function" . ?λ) prettify-symbols-alist)
                      (push '("arguments" . ?ω) prettify-symbols-alist)
                      (push '("var" . ?ν) prettify-symbols-alist)
                      (push '("const" . ?χ) prettify-symbols-alist)

                      (push '("return" . ?ρ) prettify-symbols-alist)
                      (push '("this" . ?ι) prettify-symbols-alist)

                      (push '("for" . ?∫) prettify-symbols-alist)
                      (push '("in" . ?⊂ ) prettify-symbols-alist)

                      (push '("Object" . ?Θ) prettify-symbols-alist)

                      (push '("if" . ?α) prettify-symbols-alist)
                      (push '("else if" . ?β) prettify-symbols-alist)
                      (push '("else" . ?γ) prettify-symbols-alist)

                      (push '("->" . ?→) prettify-symbols-alist)
                      (push '("&&" . ?∧) prettify-symbols-alist)
                      (push '("||" . ?∨) prettify-symbols-alist)

                      (push '("!" . ?¬) prettify-symbols-alist)
                      (push '("!!" . ?⌐) prettify-symbols-alist)

                      (push '("=" . ?⟵) prettify-symbols-alist)
                      (push '(":" . ?⟵) prettify-symbols-alist)

                      (push '("===" . ?≡) prettify-symbols-alist)
                      (push '("!==" . ?≢) prettify-symbols-alist)

                      (push '(">=" . ?≧) prettify-symbols-alist)
                      (push '("<=" . ?≦) prettify-symbols-alist)

                      (push '("true" . ?⊤) prettify-symbols-alist)
                      (push '("false" . ?⊥) prettify-symbols-alist)

                      (push '("null" . ?∅) prettify-symbols-alist)
                      (push '("undefined" . ?↑) prettify-symbols-alist)

                      (push '(", ". ?⟼) prettify-symbols-alist)
                      (push '("{". ?⟹) prettify-symbols-alist)
                      (push '("},". ?⟺) prettify-symbols-alist)
                      (push '("}". ?⟸) prettify-symbols-alist)
                      (push '("};". ?⟽) prettify-symbols-alist)

                      (push '("(". ?⟖) prettify-symbols-alist)
                      (push '(")". ?⟕) prettify-symbols-alist)
                      (push '(");". ?⟕) prettify-symbols-alist)
                      (push '("),". ?⟗) prettify-symbols-alist)
                      (push '(").". ?⟗) prettify-symbols-alist)

                      (push '("[". ?⊏) prettify-symbols-alist)
                      (push '("]". ?⊐) prettify-symbols-alist)
                      (push '("],". ?⊡) prettify-symbols-alist)
                      (push '("].". ?⊡) prettify-symbols-alist)
                      (push '("];". ?⊐) prettify-symbols-alist)

                      (push '(";". ?⟐) prettify-symbols-alist)

                      (prettify-symbols-mode t)))))
    #+END_SRC
*** JSON
    JSON support

    #+BEGIN_SRC emacs-lisp :block-id 9838a8ac-2f50-077f-0f9e-bfc5262e318d
      (use-package json-snatcher
        :ensure t
        :after js2-mode
        :bind (("C-c C-g" . jsons-print-path)))
    #+END_SRC

*** Literate Programming
    Let's support literate programming for JS

    #+BEGIN_SRC emacs-lisp :block-id 90e86021-a01f-7f97-2ca9-a076a0facb83
      (use-feature org-js2-src
        (org js2-mode)
        (add-to-list 'org-babel-load-languages '(js . t)))
    #+END_SRC

** Java
*** Mode
    Already a built in mode

    #+BEGIN_SRC emacs-lisp :block-id 8bb9a156-88c3-3dc2-a0c1-f9a80813a822
      (use-package meghanada
        :ensure t
        :after java
        :init
        (add-hook 'java-mode-hook 'meghanada-mode)
        :config
        (setq meghanada-server-install-dir (expand-file-name "meghanada" fn/cache-dir)))
    #+END_SRC

*** IDE
    How I hate that word specially when talking about Java

    #+BEGIN_SRC emacs-lisp :block-id eae7c8e8-8138-a1f4-5ebf-15bd6953e699
      (use-package eclim
        :ensure t
        :after java
        :config
        (setq eclimd-eclipse-dirs (getenv "ECLIPSE_HOME")
           eclimd-executable (expand-file-name "eclimd" eclimd-eclipse-dirs)

           eclimd-default-workspace "~/espace"
           eclimd-wait-for-process t)

        (use-package company-emacs-eclim
          :ensure t
          :after eclim
          :config
          (company-emacs-eclim-setup)))
    #+END_SRC

*** Android
    Android specific configuration.

    #+BEGIN_SRC emacs-lisp :block-id 5c33e2b3-d9e7-1a3a-51b5-adf9735e4507
      (use-package android-mode
        :ensure t
        :after java)
    #+END_SRC

** Python
*** Mode
    My favorite programming language, unassuming like Marcy from Peanuts

    #+BEGIN_SRC emacs-lisp :block-id 80645685-5d34-4543-7d76-4012fe9fd8bd
      (use-package python
        :ensure t
        :defer t)
    #+END_SRC

*** Formatter
    Pep me bro

    #+BEGIN_SRC emacs-lisp :block-id ec04abb4-3b9f-ff58-ced2-580f751074ca
      (use-package py-autopep8
        :ensure t
        :defer t
        :after python)
    #+END_SRC

*** REPL
    Using =Ipython= for this

    #+BEGIN_SRC emacs-lisp :block-id 7bb24e8e-08b5-3d37-9b73-8bb1c742b638
      (use-package ein
        :ensure t
        :defer t
        :config
        (setq ein:use-auto-complete t
              ein:use-smartrep t))
    #+END_SRC

*** Autocomplete
    The newer Python IDE, [[https://github.com/davidhalter/jedi][Jedi]], much easier to grok.

    This requires [[https://pypi.python.org/pypi/pip/][pip]] and the packages  [[https://pypi.python.org/pypi/virtualenv][virtualenv]].

    #+BEGIN_SRC emacs-lisp :block-id db37815b-78ce-9edb-06f4-c64867ed184b
      (use-package jedi
        :ensure t
        :after elpy
        :config
        (use-package company-jedi
          :ensure t
          :after company
          :config
          (add-to-list 'company-backends 'company-jedi)))
    #+END_SRC

*** IDE
    Making Python an IDE

    #+BEGIN_SRC emacs-lisp :block-id dbef41da-2171-e211-8dc6-3107bbfcb0dd
      (use-package elpy
        :ensure t
        :defer t
        :init
        (add-hook 'python-mode-hook 'elpy-enable)

        (add-hook 'elpy-mode-hook 'flycheck-mode)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
        :config
        (setq elpy-python-command "python"
              elpy-rpc-python-command "python"
              elpy-rpc-backend "jedi")

        (setq elpy-interactive-python-command "ipython")
        (elpy-use-ipython)

        (setq elpy-modules (delq 'elpy-module-flycheck elpy-modules))

        (require 'py-autopep8)
        (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
    #+END_SRC

*** Project
    =virtualenv= is a must

    #+BEGIN_SRC emacs-lisp :block-id 5097aecd-7c47-1ef8-fe02-e42d51efdbce
      (use-package python-environment
        :ensure t
        :init
        (setq python-environment-directory (expand-file-name "python-environments" fn/cache-dir)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :block-id 30bb91ea-4a08-ff9e-4cd9-d685297ea5e7
      (use-package virtualenv
        :ensure t
        :after python)
    #+END_SRC

    Or the most updated

    #+BEGIN_SRC emacs-lisp :block-id a972e38b-bf74-c106-baeb-4fb534a6fa1d
      (use-package virtualenvwrapper
        :ensure t
        :after python)
    #+END_SRC

*** Literate Programming
    Let's add a link to =org-babel=

    #+BEGIN_SRC emacs-lisp :block-id 1dd091f3-1060-774c-3435-7187c7bf15f9
      (use-feature org-python-src
        (org python)
        (add-to-list 'org-babel-load-languages '(python .t)))
    #+END_SRC
** Haskell
*** Mode
    The defacto for Haskell development

    #+BEGIN_SRC emacs-lisp :block-id 7b20b3c8-e4d0-7bcc-2013-9f12a6bb4aba
      (use-package haskell-mode
        :ensure t
        :defer t
        :init
        ;; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
        (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
        (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)
        :config
        ;; (require 'haskell-interactive-mode)
        (require 'haskell-process)
        ;; Reset mapping as it does more damage than good
        (setq haskell-cabal-mode-map (make-keymap)
              interactive-haskell-mode-map (make-keymap))

        (define-key haskell-mode-map (kbd "<f8>") 'haskell-navigate-imports)

        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile)
        (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile)

        ;; Haskell bindings
        (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
        (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
        (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
        (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
        (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Cabal bindings
        ;; (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
        ;; (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)

        ;; Interactive Haskell
        ;; (define-key interactive-haskell-mode-map (kbd "C-c M-.") 'haskell-mode-goto-loc)
        ;; (define-key interactive-haskell-mode-map (kbd "C-c M-t") 'haskell-mode-show-type-at)

        (setq haskell-stylish-on-save t)

        ;; (setq interactive-haskell-mode t)

        (setq haskell-process-suggest-remove-import-lines t
              haskell-process-auto-import-loaded-modules t
              haskell-process-log t
              haskell-process-suggest-hoogle-imports t
              haskell-process-type 'stack-ghci
              haskell-interactive-mode-eval-mode 'haskell-mode))

      (use-feature helm-hoogle
        (helm haskell-mode)
        (use-package helm-hoogle
          :ensure t
          :demand t))
    #+END_SRC

*** Motion
    The paredit for haskell, this weirdly needs [[exec-path-from-shell]] to work

    #+BEGIN_SRC emacs-lisp :block-id 3ebe801f-52f6-35a4-35bd-b41deec624ba
      (use-package shm
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook 'structured-haskell-mode)
        :config
        ;; (define-key shm-map  "\C-j" 'shm/newline-indent)
        (define-key shm-map (kbd "M-a") 'shm/goto-parent)
        (define-key shm-map (kbd "M-e") 'shm/goto-parent-end)
        ;; (define-key shm-map  "\C-+" 'shm/add-operand)
        (define-key shm-map (kbd "M-r") 'shm/raise)
        (define-key shm-map (kbd "M-^") 'shm/delete-indentation)
        (define-key shm-map (kbd "M-k") 'shm/kill)
        (define-key shm-map (kbd "C-y") 'shm/yank)
        (define-key shm-map (kbd "M-k") 'shm/kill-line)
        (define-key shm-map (kbd "C-c C-s") 'shm/case-split))
    #+END_SRC

*** Autocomplete
    Company for Haskell

    #+BEGIN_SRC emacs-lisp :block-id dba28809-a145-d57f-9414-702cd3759be1
      (unless noninteractive
        (use-feature company-haskell
          (haskell-mode company)
          (use-package company-ghc
            :ensure t
            :after company
            :config
            (add-to-list 'company-backends 'company-ghc))

          (use-package company-ghci
            :ensure t
            :after company
            :config
            (add-to-list 'company-backends 'company-ghci))))
    #+END_SRC

*** Formatter
    Formatter for Haskell

    #+BEGIN_SRC emacs-lisp :block-id c3d7d5c4-f3cb-17b5-c372-3003b2947cff
      (use-package hindent
        :ensure t
        :after haskell-mode
        :init
        (add-hook 'haskell-mode-hook #'hindent-mode)
        :config
        (setq hindent-style "johan-tibell")

        (defun fn/hindent-before-save ()
          "Reformat before saving."
          (interactive)
          (add-hook 'before-save-hook 'hindent-reformat-buffer t t)))
    #+END_SRC

*** Linter
    Syntax checker for Haskell

    #+BEGIN_SRC emacs-lisp :block-id 883aefd1-ca75-0635-3c06-d0a08e537f1f
      (use-feature flycheck-haskell
        (flycheck haskell-mode)
        (use-package flycheck-haskell
          :ensure t
          :init
          (add-hook 'haskell-mode-hook 'flycheck-mode)
          :config
          (flycheck-haskell-setup)))
    #+END_SRC

*** Prettify
    My symbols for Haskell

    #+BEGIN_SRC emacs-lisp :block-id 645c5f8f-82a1-dd6d-6318-f3528bbb7cb7
      (use-function prettify-haskell
        prettify-symbols-mode
        (use-feature prettify-haskell
          (prettify-symbols-mode haskell-mode)
          (defun fn/prettiy-haskell ()
            "Some haskell prettifier"
            (push '("->" . ?→) prettify-symbols-alist)
            (push '("let" . ?ν) prettify-symbols-alist)
            (push '("if" . ?α) prettify-symbols-alist)
            (push '("in" . ?ε) prettify-symbols-alist)
            (push '("then" . ?σ) prettify-symbols-alist)
            (push '("else" . ?τ) prettify-symbols-alist)
            (push '("where" . ?δ) prettify-symbols-alist)
            (push '("module" . ?θ) prettify-symbols-alist)
            (push '("data" . ?Τ) prettify-symbols-alist)
            (push '("deriving" . ?Δ) prettify-symbols-alist)
            (prettify-symbols-mode t))

          (add-hook 'haskell-mode-hook #'fn/prettiy-haskell)))
    #+END_SRC

*** Snippets
    Easy snippets for Haskell

    #+BEGIN_SRC emacs-lisp :block-id 5f1b278b-5b7e-5d87-7f25-f5af49d9230d
      (unless noninteractive
        (use-feature haskell-snippets
          (yasnippet haskell-mode)
          (use-package haskell-snippets
            :ensure t
            :demand t)))
    #+END_SRC

*** Build Tools
    Maybe stack or hack?
*** Literate Programming
    Literate programming for ease

    #+BEGIN_SRC emacs-lisp :block-id 15965ab3-0934-edf8-da0d-a33886b982c9
      (defconst fn/ob-haskell-package-dir (expand-file-name "ob-haskell/" fn/custom-module-dir)
        "My ob-haskell package dir.")

      (unless noninteractive
        (use-feature org-haskell
          (haskell-mode org)
          (use-package ob-haskell
            :load-path fn/ob-haskell-package-dir
            :demand t
            :config
            (add-to-list 'org-babel-load-languages '(haskell . t))

            (defconst fn/haskell-file-extension ".hs"
              "The de facto haskell file extension.")

            (defun fn/add-haskell-file-extension (name)
              "Add the extension of .hs to a file or buffer NAME."
              (if (string/ends-with name fn/haskell-file-extension)
                  name (concat name fn/haskell-file-extension)))

            (defvar fn/org-haskell-mode-hook nil
              "Hook when buffer is haskellized.")

            (defun fn/haskellize-buffer-file (&optional buffer)
              "Renames an BUFFER with a .hs extension if it doesn't have one."
              (interactive)
              (with-current-buffer (or buffer (current-buffer))
                (save-buffer)
                (lexical-let ((name (buffer-name))
                    (file-name (buffer-file-name)))
                  (if (not (and file-name (file-exists-p file-name)))
                      (error "Buffer '%s' has no backing file" name)
                    (lexical-let ((haskellized-name (fn/add-haskell-file-extension name))
                        (haskellized-file-name (fn/add-haskell-file-extension file-name)))
                      (cond
                       ((get-buffer haskellized-name)
                        (error "A buffer named '%s' already exists" haskellized-name))
                       ((string-equal name haskellized-name)
                        (message "Buffer %s is already haskellized" haskellized-name))
                       (t
                        (rename-file file-name haskellized-file-name t)
                        (rename-buffer haskellized-name)
                        (set-visited-file-name haskellized-file-name)
                        (set-buffer-modified-p nil)
                        (message "Buffer %s is now haskellized" haskellized-name))))))))

            (defun fn/org-haskell-buffer-p (&optional buffer)
              "Check if BUFFER is an org-haskell buffer."
              (with-current-buffer (or buffer (current-buffer))
                (and (eq major-mode 'haskell-mode)
                   (fboundp 'org-src-edit-buffer-p)
                   (org-src-edit-buffer-p))))

            (defun fn/haskellize-org-haskell-buffer (&rest _)
              "Haskellize org haskell buffer."
              (when (fn/org-haskell-buffer-p)
                (fn/haskellize-buffer-file (current-buffer))
                (run-hooks 'fn/org-haskell-mode-hook)))

            (defun fn/save-org-haskell-buffer (&rest _)
              "Save haskell buffer along with the edit buffer."
              (when (fn/org-haskell-buffer-p)
                (save-buffer)))

            (defun fn/cleanup-org-haskell-buffer (orig-fun &rest args)
              "Cleanup the org-haskell buffer when exiting the edit buffer."
              (lexical-let ((org-haskell-file-name (buffer-file-name))
                  (org-haskell-buffer-p (fn/org-haskell-buffer-p)))
                (prog1
                    (apply orig-fun args)
                  (when (and (file-exists-p org-haskell-file-name) org-haskell-buffer-p)
                    (delete-file org-haskell-file-name)))))

            (defun fn/haskell-process-load-or-reload ()
              "Invoke reload process without switching buffers"
              (save-window-excursion
                (haskell-process-load-or-reload)))

            (defun fn/haskell-reload-on-save ()
              "Reload interactive haskell process on save."
              (add-hook 'after-save-hook 'fn/haskell-process-load-or-reload t t))

            (add-hook 'org-src-mode-hook #'fn/haskellize-org-haskell-buffer t)

            (add-hook 'fn/org-haskell-mode-hook 'fn/haskell-process-load-or-reload)
            (add-hook 'fn/org-haskell-mode-hook 'fn/haskell-reload-on-save)

            (advice-add 'org-edit-src-save :before #'fn/save-org-haskell-buffer)
            (advice-add 'org-edit-src-exit :around #'fn/cleanup-org-haskell-buffer)

            (use-feature literate-haskell-hindent
              (haskell-mode hindent)
              (add-hook 'fn/org-haskell-mode-hook 'fn/hindent-before-save)))))
    #+END_SRC

** Clojure
   Scheme would be nice but there is a modern alternative.

*** Mode
    The major mode

    #+BEGIN_SRC emacs-lisp :block-id 8bfb19ba-f64b-82e3-f65f-a4a152320f8a
      (use-package clojure-mode
        :ensure t
        :mode (("\\.clj\\'" . clojure-mode))
        :config
        (use-feature clojure-mode--mode-icon
          (all-the-icons)
          (fn/add-major-mode-icon
           'clojure-mode
           (list 'all-the-icons-fileicon "scheme" :v-adjust 0.0))))

      (use-package clojure-mode-extra-font-locking
        :ensure t
        :after clojure-mode)
    #+END_SRC

*** REPL
    What is Clojure without a REPL?

    #+BEGIN_SRC emacs-lisp :block-id d3120ff7-28c7-215f-f0bc-d6ac6fa94a1a
      (use-package cider
        :ensure t
        :after clojure-mode)
    #+END_SRC

*** Integration
    Lisp meets Lisp.

    #+BEGIN_SRC emacs-lisp :block-id 0afcc21c-7f56-fca5-0eba-fc5d4272e54f
      (use-package clomacs
        :ensure t
        :after clojure-mode)
    #+END_SRC

** C
   The base of all languages

   #+BEGIN_SRC emacs-lisp :block-id 892cb575-f270-c080-6840-b8d52e52b535

   #+END_SRC

*** IDE
    A lot of irony for an IDE

    #+BEGIN_SRC emacs-lisp :block-id cbcaef17-718e-c364-2cb8-c46ef34bd4b5
      (use-package irony
        :ensure t
        :init

        (add-hook 'c-mode-hook 'irony-mode)
        (add-hook 'c++-mode-hook 'irony-mode)
        :config
        (setq irony-user-dir (expand-file-name "irony" fn/cache-dir)
           irony-server-install-prefix irony-user-dir)

        (add-to-list 'exec-path (expand-file-name "bin" irony-user-dir))

        (defun fn/irony-mode-setup ()
          (define-key irony-mode-map [remap completion-at-point]
            'irony-completion-at-point-async)
          (define-key irony-mode-map [remap complete-symbol]
            'irony-completion-at-point-async))

        (add-hook 'irony-mode-hook 'fn/irony-mode-setup)

        (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

      (use-package company-irony
        :ensure t
        :after irony
        :config
        (add-to-list 'company-backends 'company-irony))
    #+END_SRC

*** Linter
    Flycheck with irony works

    #+BEGIN_SRC emacs-lisp :block-id 36a98771-3bc7-bf93-9605-354cf09b41bf
      (use-feature flycheck-irony
        (flycheck irony)
        (use-package flycheck-irony
          :ensure t
          :after flycheck
          :init
          (add-hook 'c-mode 'flycheck-mode)
          :config
          (flycheck-irony-setup)))
    #+END_SRC

** Guile
   If Elisp is Guile, then I am prepared.

*** Mode
    A mode for Guile

    #+BEGIN_SRC emacs-lisp :block-id 88d8f879-32ea-41bf-75fc-e2771b3976d7
      (use-feature scheme-mode
        (scheme)

        (use-feature par-scheme
          (scheme paredit)
          (add-hook 'scheme-mode #'paredit-mode))

        (use-feature scheme-mode--mode-icon
          (all-the-icons)
          (fn/add-major-mode-icon
           'scheme-mode
           (list 'all-the-icons-fileicon "scheme" :v-adjust 0.0))))
    #+END_SRC

*** REPL
    A must have

    #+BEGIN_SRC emacs-lisp :block-id 2706d094-0482-a050-5de7-a5cc66d6b6bb
      (use-package geiser
        :ensure t
        :after scheme
        :config
        (setq geiser-active-implementations (list 'guile)
              geiser-default-implementation 'guile)

        (use-feature par-geiser
          (paredit)
          (add-hook 'geiser-repl-mode-hook #'paredit-mode)))
    #+END_SRC
*** Autocomplete
    Company to the job.

    #+BEGIN_SRC emacs-lisp :block-id 83cc4af3-3d96-4034-29f7-020a80cfa603
      (use-feature guile-company
        (scheme company)
        "(It')s all goodman")
    #+END_SRC

** Elm
   Functional JavaScript frontend

*** Mode
    Elm major mode

    #+BEGIN_SRC emacs-lisp :block-id 32b54390-5bb4-16e4-208d-f91567657a3b
      (use-package elm-mode
        :ensure t
        :defer t
        :config
        ;; There is a conflict if you're using this with aggressive indent
        (add-hook 'elm-mode-hook
                  (lambda ()
                    (setq-local aggressive-indent-mode nil))))
    #+END_SRC

*** Linter
    Linter for Elm

    #+BEGIN_SRC emacs-lisp :block-id a08741e2-92ba-25ef-5474-4e8a78116de8
      (use-feature flycheck-elm
        (flycheck elm-mode)
        (use-package flycheck-elm
          :ensure t
          :config
          (flycheck-elm-setup)))
    #+END_SRC

*** Formatter
    Formatter for Elm, requires =elm-format=

    #+BEGIN_SRC emacs-lisp :block-id cb77963e-7a17-06c2-c461-1ab9fa6ec359
      (use-package *elm-mode-formatter
        :after elm-mode
        :config
        (setq elm-format-on-save t
              elm-sort-imports-on-save t))

    #+END_SRC
*** Autocomplete
    A needed feature, requires =elm-oracle=

    #+BEGIN_SRC emacs-lisp :block-id d86ddd6e-2eae-1b6f-9157-13eb41f40258
      (use-package *elm-mode-autocomplete
        :after company
        :config
        (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
        (add-to-list 'company-backends 'company-elm))
    #+END_SRC

*** Snippets
    Snippets too

    #+BEGIN_SRC emacs-lisp :block-id 32323472-2919-f3d1-0ba9-627cbcb58a30
      (use-feature elm-yasnippets
        (elm yasnippets)
        (use-package elm-yasnippets
          :ensure t))
    #+END_SRC

** Elixir
   The dynamic Haskell in my opinion... or was it Python

*** Mode
    Main mode for Elixir

    #+BEGIN_SRC emacs-lisp :block-id a0fed229-124a-f2fd-78fb-bcc8e91f05ce
      (use-package elixir-mode
        :ensure t
        :defer t)
    #+END_SRC

*** Linter
    A linter is always needed

    #+BEGIN_SRC emacs-lisp :block-id 06d9fdcc-6c8d-a6b2-83ea-45179f85ca51
      (use-feature flycheck-elixir
        (elixir-mode flycheck)
        (use-package flycheck-elixir
          :ensure t))
    #+END_SRC

    Integration with =mix=

    #+BEGIN_SRC emacs-lisp :block-id d41f5eeb-1f8a-46e1-8581-bb66d2722118
      (use-feature flycheck-mix
        (elixir-mode flycheck)
        (use-package flycheck-mix
          :ensure t))
    #+END_SRC

*** Snippets
    Snippets support via yasnippet

    #+BEGIN_SRC emacs-lisp :block-id c6da5fe6-e35e-6d0a-4cc0-efb35d46925f
      (use-feature elixir-yasnippets
        (elixir-mode yasnippet)
        (use-package elixir-yasnippets
          :ensure t))
    #+END_SRC

*** Build Tools
    Build tool for Elixir

    #+BEGIN_SRC emacs-lisp :block-id ce3e7a1d-a1c7-f983-a3a8-db499704136f
      (use-package alchemist
        :ensure t
        :after elixir-mode
        :defer t)
    #+END_SRC

** Ruby
*** Mode
    I'll be using =enh-ruby-mode=

    #+BEGIN_SRC emacs-lisp :block-id c45379d4-5485-4f3f-bbec-0fe4f417b36b
      (use-package enh-ruby-mode
        :ensure t
        :mode (("\\.\\(rb\\|json\\)$" . enh-ruby-mode)))
    #+END_SRC

*** Completion
    Still using [[company]] with [[robe]]

    #+BEGIN_SRC emacs-lisp :block-id bd7bd68d-d482-cc97-7f3c-291b81169358
      (unless noninteractive
        (use-feature company-robe
          (robe company)
          (add-to-list 'company-backends 'company-robe)))
    #+END_SRC

*** IDE
    Almost

    #+BEGIN_SRC emacs-lisp :block-id 3b8cee73-9554-9e25-183e-db0517d7f342
      (use-package robe
        :ensure t
        :after enh-ruby-mode
        :init
        (add-hook 'enh-ruby-mode-hook 'robe-mode))
    #+END_SRC

*** Project
    Ruby has it's own environment

    #+BEGIN_SRC emacs-lisp :block-id 779d9b22-60a5-9956-ea14-8bba646238f0
      (use-package rvm
        :ensure t
        :after robe)
    #+END_SRC

** dotNet
*** omnisharp
    For C# development

    #+BEGIN_SRC emacs-lisp :block-id 3bc5942f-19ba-a159-7e5c-ab1eb1a24858
      (use-package omnisharp
        :ensure t
        :defer t
        :init
        (add-hook 'csharp-mode-hook 'omnisharp-mode)
        :config
        (setq omnisharp-root-dir
              (expand-file-name "~/Fakespace/omnisharp-server"))
        (setq omnisharp-server-executable-path
              (expand-file-name "OmniSharp/bin/Debug/" omnisharp-root-dir)))
    #+END_SRC

** LaTeX
   LaTeX editing for my files

*** Mode
    Actual mode to do the job

    #+BEGIN_SRC emacs-lisp :block-id 7dcc691e-16df-540c-0843-822d99c01e35
      (use-package auctex
        :ensure t
        :defer t
        :init
        (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
        (add-hook 'latex-mode-hook 'turn-on-reftex)
        (add-hook 'latex-mode-hook 'flyspell-mode)
        (setq reftex-plug-into-AUCTex t)
        :config
        (setq TeX-auto-save t
              TeX-parse-self t)

        (setq-default TeX-master nil))
    #+END_SRC

*** Autocomplete
    Autocomplete obviously

    #+BEGIN_SRC  emacs-lisp :block-id a501dfe3-49d4-6074-bccf-2b2eac38944c
      (use-package company-auctex
        :ensure t
        :after auctex
        :config
        (company-auctex-init))
    #+END_SRC

*** Linter
    Something similar but for spelling

    #+BEGIN_SRC emacs-lisp :block-id d38ac398-91d1-affa-263e-e204695a8689
      (use-feature flyspell-auctex
        (flyspell auctex)
        (add-hook 'latex-mode-hook #'flyspell-mode))
    #+END_SRC

*** REPL
    Something like that but rather a preview for every edit

    #+BEGIN_SRC emacs-lisp :block-id 079d8d3b-fb51-b7ea-9c03-690217637c5b
      (use-package latex-preview-pane
        :ensure t
        :after auctex
        :config
        (define-key latex-mode-map (kbd "C-c C-p") 'latex-preview-pane-mode))
    #+END_SRC

* Random Was Alone
  Anything that just does something useful

** w3m
   Web browsing is a must

   #+BEGIN_SRC emacs-lisp :block-id 4ef8aaa9-5b2f-30e3-c126-323935e0f9f6
     (use-package w3m
       :ensure t
       :config
       nil)
   #+END_SRC

** twittering
   Integrating with emacs is very fun via [[https://github.com/hayamiz/twittering-mode][twittering]]

   #+BEGIN_SRC emacs-lisp :block-id 9da6d0ba-1c96-a8e5-b8c9-1b5fabac58ee
     (use-package twittering-mode
       :ensure t
       :defer t
       :init
       (setq twittering-auth-method 'oauth)
       (setq twittering-use-master-password t)
       :config
       (twittering-icon-mode t)
       (setq twittering-convert-fix-size 24))
   #+END_SRC
** erc
   Connecting with the brothers

   #+BEGIN_SRC emacs-lisp :block-id 7cf5dadb-eb6b-a004-1566-eb12464e2e44
     (use-package erc
       :bind (:map fn-standard-prefix-map
                   ("e q" . erc-quit-server))
       :init
       (defun fn/erc ()
         "My default erc connection."
         (interactive)
         (erc :server "irc.freenode.net" :port 6667 :nick "fnmurillo" :password nil))
       (define-key fn-standard-prefix-map (kbd "e e") #'fn/erc)
       :config
       (setq erc-try-new-nick-p t
          erc-password nil

          erc-autojoin-channels-alist
          (list
           (list "freenode.net"
              "#emacs"
              "#conkeror"
              "#flowtype"
              "#rethinkdb"))
          erc-rename-buffers t
          erc-interpret-mirc-color t

          erc-quit-reason (lambda (&rest args) "I took with me... their lightning and their prayers"))

       (use-feature erc-message-alert
         (alert)
         (require 's)

         (defconst fn/erc-notify-severity 'erc
           "My erc notify severity.")

         (add-to-list 'alert-log-severity-functions
                      (cons fn/erc-notify-severity #'alert--log-trace))
         (add-to-list 'alert-severity-colors
                      (cons fn/erc-notify-severity "#3d57b1"))

         (defun fn/erc-notice-p (message)
           "Check if MESSAGE is a notice."
           (s-starts-with-p erc-notice-prefix message))

         (defun fn/erc-get-sender-name (message)
           "Get the sender from the MESSAGE."
           (let ((result (car (s-split-up-to " " message 1))))
             (if (string= result message)
                 nil
               (substring-no-properties result 1 -1))))

         (defun fn/erc-get-message (message)
           "Get the message from the MESSAGE."
           (let ((result (cadr (s-split-up-to " " message 1))))
             (if (null result)
                 nil
               result)))

         (defun fn/erc-message-alert (message)
           "Just a small unobtrusive notifcation"
           (ignore-errors ;; NOTE: I shall return
             (let ((raw-message (string-trim-right (substring-no-properties message))))
               (when (and (erc-network-name)
                        (erc-default-target)
                        (not (erc-is-message-ctcp-p raw-message))
                        (not (fn/erc-notice-p raw-message)))
                 (let ((server (erc-network-name))
                     (channel (substring-no-properties (erc-default-target) 1))
                     (chatter (fn/erc-get-sender-name raw-message))
                     (base-message (fn/erc-get-message raw-message)))
                   (alert (fn/chat-log server channel chatter base-message)
                          :category 'erc
                          :style 'fringe
                          :severity fn/erc-notify-severity))))))

         (add-hook 'erc-insert-pre-hook #'fn/erc-message-alert))

       (use-feature erc-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'erc-mode
          (list 'all-the-icons-faicon "exchange" :v-adjust 0.0))))
   #+END_SRC

** jabber

   Listen to chat notifications

   #+BEGIN_SRC emacs-lisp :block-id 9893f144-27ee-c367-13cb-188e6cef258e
     (use-package jabber
       :ensure t
       :bind (:map fn-standard-prefix-map
                   ("J J" . jabber-connect-all)
                   ("J c" . jabber-chat-with)
                   ("J q" . jabber-disconnect))
       :config
       ;; account set at personal.el

       ;; core
       (setq jabber-auto-reconnect t
          jabber-version-show nil

          jabber-history-enabled t
          jabber-use-global-history nil
          jabber-history-dir (expand-file-name "jabber-history/" fn/cache-dir)

          jabber-backlog-number 40
          jabber-backlog-days 30)

       (defconst fn/jabber-roster-buffer-name "*-jabber-*"
         "My custom name for the jabber buffer")

       ;; chat
       (setq jabber-chat-buffer-format "*-jabber-%n-*")

       ;; history
       (setq jabber-history-enabled t
             jabber-history-dir (expand-file-name "jabber-history" fn/cache-dir))

       ;; mode
       (setq jabber-mode-line-mode t)

       ;; chat states
       (setq jabber-chatstates-confirm nil
          jabber-presence-hooks nil)

       ;; avatar
       (setq jabber-avatar-cache-directory (expand-file-name "jabber-avatar-cache" fn/cache-dir)
             jabber-vcard-avatars-publish nil
             jabber-vcard-avatars-retrieve nil)

       ;; libnotify
       (setq jabber-libnotify-method 'shell
          jabber-libnotify-urgency "high")

       ;; presence
       (setq jabber-alert-presence-message-function nil)


       ;; chat
       (setq jabber-chat-foreign-prompt-format "[%t] %n>"
          jabber-chat-local-prompt-format  "[%t] %n>"
          jabber-groupchat-prompt-format  "[%t] %n>"
          jabber-muc-private-foreign-prompt-format "[%t] %g/%n>")


       ;; alerts
       (setq jabber-alert-message-hooks nil)

       (use-feature jabber-alert-custom
         (alert)
         (defconst fn/jabber-notify-severity 'jabber
           "My jabber notify severity.")

         (add-to-list 'alert-log-severity-functions
                      (cons fn/jabber-notify-severity #'alert--log-trace))
         (add-to-list 'alert-severity-colors
                      (cons fn/jabber-notify-severity "#abb2e1"))

         (defconst fn/jabber-google
           (format "%s%s%s%s%s%s"
                   (propertize "g" 'face '(:foreground "#4285f4"))
                   (propertize "o" 'face '(:foreground "#ea4335"))
                   (propertize "o" 'face '(:foreground "#fbbc05"))
                   (propertize "g" 'face '(:foreground "#4285f4"))
                   (propertize "l" 'face '(:foreground "#34a853"))
                   (propertize "e" 'face '(:foreground "#ea4335")))
           "A nice candy colored google text")

         (defun fn/jabber-message-notify (from buffer text title)
           "Just a small unobtrusive notifcation"
           (let ((chatter (cdr (assoc from jabber-activity-name-alist))))
             (alert (fn/chat-log fn/jabber-google user-mail-address chatter text)
                    :category 'jabber
                    :style 'fringe
                    :severity fn/jabber-notify-severity)))

         (add-hook 'jabber-alert-message-hooks #'fn/jabber-message-notify))

       (use-feature jabber-roster-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'jabber-roster-mode
          (list 'all-the-icons-octicon "radio-tower" :v-adjust -0.1)))

       (use-feature jabber-chat-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'jabber-chat-mode
          (list 'all-the-icons-faicon "comments" :v-adjust -0.1)))


       ;; roster
       (setq jabber-roster-show-title nil
             jabber-roster-line-format "%c %-25n %u %-8s  %S"
             jabber-roster-buffer fn/jabber-roster-buffer-name)

       (defun fn/display-jabber-roster-buffer ()
         "Show jabber roster buffer"
         (interactive)
         (display-buffer-same-window (get-buffer fn/jabber-roster-buffer-name) nil)))
   #+END_SRC

** slack
   =Slack= is awesome.

   #+BEGIN_SRC emacs-lisp :block-id 2f91f506-c8a6-85b4-769d-3fb460019887
     (use-package slack
       :ensure t
       :bind (:map fn-standard-prefix-map
                   ("s s" . slack-start)
                   ("s q" . slack-ws-close))
       :config
       (setq slack-enable-emoji nil
             slack-buffer-emojify nil
             slack-typing-visibility 'buffer
             slack-prefer-current-team t)

       (use-feature slack-custom-alert
         (alert)
         (defconst fn/slack-notify-severity 'slack
           "My slack notify severity.")

         (add-to-list 'alert-log-severity-functions
                      (cons fn/slack-notify-severity #'alert--log-trace))
         (add-to-list 'alert-severity-colors
                      (cons fn/slack-notify-severity "#3a417a"))

         (defun fn/slack-message-custom-notifier (message room team)
           "My custom notication for slack given MESSAGE, ROOM and TEAM.
     What I do is use the fringe to notify me instead of `libnotify'."
           (let* ((team-name (oref team name))
               (room-name (slack-room-name room))
               (text (slack-message-to-alert message team))
               (user-name (slack-message-sender-name message team))
               (out (fn/chat-log team-name room-name user-name text)))
             (alert out
                    :category 'phackers
                    :style 'fringe
                    :severity fn/slack-notify-severity)))

         (setq slack-message-custom-notifier #'fn/slack-message-custom-notifier))

       (use-feature slack-mode--mode-icon
         (all-the-icons)
         (fn/add-major-mode-icon
          'slack-mode
          (list 'all-the-icons-faicon "commenting-o" :v-adjust 0.0)))

       (use-feature phackers-candy
         (text-candy)
         (text-candy-add-candy-word
          (propertize ;; phackers
           "phackers"
           'face
           '(:foreground "#ffffff" :background "#28bfd0"
                         :box (:line-width 2 :color "#e3ffff") :weight bold :height 0.9)))))
   #+END_SRC

** sauron
   The eye of all notifier

   #+BEGIN_SRC emacs-lisp :block-id 17b26472-bee7-1712-9c92-ce929629a3e0
     (use-package sauron
       :ensure t
       :defer t
       :config
       (setq sauron-modules (list 'sauron-erc
                            'sauron-jabber
                            'sauron-dbus))

       (setq sauron-separate-frame nil
          sauron-sticky-frame nil
          sauron-hide-mode-line nil))
   #+END_SRC

** sx
   Stack Exchange api

   #+BEGIN_SRC emacs-lisp :block-id aaf558e6-6cab-fbee-9135-c26b1f2cb157
     (use-package sx
       :bind (:map fn-standard-prefix-map
                   ("S q" . sx-tab-all-questions)
                   ("S i" . sx-inbox)
                   ("S o" . sx-open-link)
                   ("S u" . sx-tab-unanswered-my-tags)
                   ("S a" . sx-ask)
                   ("S s" . sx-search))
       :config
       (setq sx-cache-directory (expand-file-name ".sx" fn/cache-dir)))
   #+END_SRC
** bbdb
   People organization

   #+BEGIN_SRC emacs-lisp :block-id 88354fe4-6152-2230-89e0-ab6199decc18
     (use-package bbdb
       :ensure t
       :defer t
       :config
       (bbdb-initialize)
       (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))
   #+END_SRC

** emms
   This controls the music player.

   #+BEGIN_SRC emacs-lisp :block-id 0ebc0aed-f749-2d71-297a-692d5ab3b0a6
     (use-package emms
       :ensure t
       :defer t
       :init
       (setq emms-directory (expand-file-name "emms" fn/cache-dir))
       :config
       (emms-standard)
       (emms-default-players)

       (setq emms-source-file-default-directory "~/Musicbox/")

       (setq emms-info-asynchronously nil
             emms-playlist-buffer-name "*Music*")

       (setq emms-playlist-default-major-mode 'emms-playlist-mode)

       ;; emms-mark
       (require 'emms-mark)

       ;; emms-history
       (require 'emms-history)
       (emms-history-load)

       ;; emms-mode-line
       (require 'emms-mode-line)
       (emms-mode-line 1)

       (require 'emms-playing-time)
       (emms-playing-time 1)

       ;; emms-browser
       (require 'emms-browser)

       ;; emms-volume
       (emms-volume-minor-mode t)

       (setq emms-volume-mode-timeout 1)

       (define-key emms-volume-minor-mode-map (kbd "C-c -") 'emms-volume-minus)
       (define-key emms-volume-minor-mode-map (kbd "C-c +") 'emms-volume-plus))
   #+END_SRC

** figlet
   Annoying people with text

   #+BEGIN_SRC emacs-lisp :block-id 56abcdf0-af38-e683-134a-50861bf4674f
     (use-package figlet
       :ensure t
       :defer t
       :config
       (setq figlet-default-font "slant"))
   #+END_SRC

* Scripts
** Clean Home
   Make sure my Emacs home is clean

   #+BEGIN_SRC emacs-lisp :block-id 8f1e63f0-f81c-3a52-5f37-b194db21d050
     (require 'f)

     (defconst fn/user-emacs-home-files
       (list
        ".cache"
        "config.el"
        "config.org"
        "extra"
        ".git"
        ".gitignore"
        "init.el"
        "init-standard.el"
        "lib"
        "personal.el"
        ".projectile"
        ".project-locals.el"
        "README.org"
        ".safe-config.el"
        ".safe-config.org")
       "Known Emacs home files")


     (defun fn/clean-user-emacs-home ()
       "Make sure Emacs only has the following files as specified by `fn/user-emacs-home-files'"
       (interactive)
       (message "Cleaning emacs home.")
       (mapc
        (lambda (home-file)
          (unless (member home-file fn/user-emacs-home-files )
            (message "Deleting trash file %s" home-file)
            (f-delete (expand-file-name home-file user-emacs-directory) t)))
        (mapcar ;; You can use `directory-files' but you have to filter `.' and `..'
         'f-filename
         (append
          (f-files user-emacs-directory)
          (f-directories user-emacs-directory))))
       (message "All clean."))

     (add-hook 'after-init-hook 'fn/clean-user-emacs-home)
   #+END_SRC

** Initial View
   My intial view when Emacs boots up

   #+BEGIN_SRC emacs-lisp :block-id 3a40c500-5ad9-4d98-85de-75bc79d992f9
     (defconst fn/preferred-text-width 60
       "Just enough characters to read my windwos")

     (defun fn/setup-initial-view ()
       "Setup your personal view"
       (interactive)
       (message "Setting up initial view")
       (let ((text-width (/ (window-text-width) 2.0)))
         (fn/find-main-org-file)

         ;; If there is enough width, show the org-todo view
         (when (>= text-width fn/preferred-text-width)
           (split-window-horizontally)
           (other-window 1)
           (org-todo-list)
           (other-window 1)))

       (select-frame-set-input-focus (selected-frame)))

     (add-hook
      'after-init-hook #'fn/setup-initial-view
      t ;; Must be after full screen action
      )
   #+END_SRC

** Custom Emacs
   Bootstrap different configurations of Emacs for reviewing expert
   configurations and trying different modes

*** Configurable
    Let's bootstrap from different configurations dynamically

    #+BEGIN_SRC emacs-lisp  :block-id c0819554-346d-461b-dbc6-7c0ec4f398d0
      (defun fn/bootstrap-from-dir ()
        (interactive)
        (setq new-home (read-directory-name "What Emacs config would you like to boot?" "~"))
        (fn/bootstrap-new-emacs new-home))


      (defvar fn/previous-bootstrap-dir nil)

      (defun fn/store-bootstrap-dir (new-home)
        "Store previously bootstrap directory"
        (setq fn/previous-bootstrap-dir new-home))

      (advice-add 'fn/bootstrap-new-emacs :after 'fn/store-bootstrap-dir)


      (defun fn/bootstrap-previous ()
        "Bootstrap the previously chosen one, `fn/previous-bootstrap-dir'"
        (interactive)
        (fn/bootstrap-new-emacs fn/previous-bootstrap-dir))
    #+END_SRC

*** Itself

    Load another copy of this configuration for vanity sake I suppose?

    #+BEGIN_SRC emacs-lisp :block-id 41b5319b-c982-bcd7-516b-39d81c4bc266
      (defun fn/bootstrap-itself ()
        (interactive)
        (fn/bootstrap-new-emacs nil))
    #+END_SRC

*** Experimental
    Just a random build for myself

    #+BEGIN_SRC emacs-lisp :block-id cf5c64b3-cfeb-67d2-1877-e4392dd0f8b1
      (setq fn/experimental-home "~/.fmacs.d/")

      (defun fn/bootstrap-experimental ()
        (interactive)
        (fn/bootstrap-new-emacs fn/experimental-home))
    #+END_SRC

*** Spacemacs
    The love child of Emacs and Vim, what does it hold?

    #+BEGIN_SRC emacs-lisp :block-id 063f9764-edfd-d3ff-af43-1dabb6e0aacc
      (setq fn/spacemacs-home "~/Fakespace/.spacemacs.d/")

      (defun fn/bootstrap-spacemacs ()
        (interactive)
        (fn/bootstrap-new-emacs fn/spacemacs-home))
    #+END_SRC

** Quick Config Tangler
   I don't need to tangle the whole file. Maybe just one block if I can.

   #+BEGIN_SRC emacs-lisp :block-id 72a91420-792d-82c0-b2a7-4f95c7442384
     (require 'f)

     (random t)

     (defun fn/random-uuid ()
       ;; Thanks to http://ergoemacs.org/emacs/elisp_generate_uuid.html
       "Generate a random UUID.
     Example of a UUID: 1df63142-a513-c850-31a3-535fc3520c3d

     WARNING: this is a simple implementation. The chance of generating the same UUID is much higher than a robust algorithm."
       (interactive)
       (format "%04x%04x-%04x-%04x-%04x-%06x%06x"
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 4))
               (random (expt 16 6))
               (random (expt 16 6))))


     (defconst fn/tangled-config-file (f-swap-ext fn/config-file "el")
       "The tangled config file.")


     (defun fn/get-code-block-id ()
       "Get code block id at point."
       (interactive)
       (cdr (assoc fn/code-block-id-symbol (nth 2 (org-babel-get-src-block-info)))))

     (defun fn/get-code-block-previous-id ()
       "Get previous code block id at point."
       (interactive)
       (condition-case ex
           (save-excursion
             (org-babel-goto-src-block-head)
             (org-babel-previous-src-block)
             (fn/get-code-block-id))
         ('error nil)))

     (defun fn/get-code-block-next-id ()
       "Get next code block id at point."
       (interactive)
       (condition-case ex
           (save-excursion
             (org-babel-goto-src-block-head)
             (org-babel-next-src-block)
             (fn/get-code-block-id))
         ('error nil)))

     (defun fn/get-code-block-code ()
       "Get src code at point."
       (interactive)
       (nth 1 (org-babel-get-src-block-info)))

     (defun fn/generate-code-block-id ()
       "Generate code block id for block."
       (interactive)
       (if (fn/get-code-block-id)
           nil
         (save-excursion
           (org-babel-goto-src-block-head)
           (end-of-line)
           (insert " ")
           (let ((id (symbol-name fn/code-block-id-symbol)))
             (insert
              (format "%s %s"
                      id
                      (fn/random-uuid)))
             id))))

     (defun fn/generate-code-block-ids (&optional buffer)
       "Generate block ids for current BUFFER."
       (interactive)
       (save-excursion
         (beginning-of-line)
         (condition-case ex
             (while t
               (org-babel-next-src-block)
               (fn/generate-code-block-id))
           ('error nil))))

     (defun fn/find-code-block (&optional block-id)
       "Find code block with equivalent BLOCK-ID."
       (interactive)
       (let ((id (or block-id
                  (fn/get-code-block-id))))
         (unless id
           (error "No code block id."))

         (let ((block-start (format fn/code-block-start-format id)))
           (condition-case ex
               (with-current-buffer (find-file fn/tangled-config-file)
                 (goto-char (point-min))
                 (search-forward block-start)
                 (beginning-of-line)
                 (switch-to-buffer (current-buffer)))
             ('error (message "Cannot find block id: %s" (error-message-string ex)))))))

     (defun fn/update-code-block (&optional block-id)
       "Update or add code block with equivalent BLOCK-ID."
       (interactive)
       (let ((id (or block-id
                  (fn/get-code-block-id)))
           (code (fn/get-code-block-code)))
         (let ((block-start (format fn/code-block-start-format id))
             (block-end (format fn/code-block-end-format id))
             (tangle-buffer (find-file-noselect fn/tangled-config-file)))
           (cond
            ((condition-case ex
                 (with-current-buffer tangle-buffer
                   (beginning-of-buffer)
                   (search-forward block-start)
                   (beginning-of-line)
                   (forward-line)

                   (command-execute #'set-mark-command)
                   (search-forward block-end)
                   (beginning-of-line)
                   (kill-region (region-beginning) (region-end))
                   (open-line 1)
                   (command-execute #'set-mark-command)

                   (insert code)
                   (insert "\n")
                   (save-buffer)
                   t)
               ('error nil))
             'update)
            ((condition-case ex
                 (let* ((previous-id (fn/get-code-block-previous-id))
                     (previous-block-end (format fn/code-block-end-format previous-id)))
                   (with-current-buffer tangle-buffer
                     (beginning-of-buffer)
                     (search-forward previous-block-end)
                     (beginning-of-line)
                     (next-line)
                     (insert "\n")
                     (insert block-start)
                     (insert "\n")
                     (insert code)
                     (insert "\n")
                     (insert block-end)
                     (insert "\n")
                     (insert "\n")
                     (save-buffer)
                     t))
               ('error nil))
             'add)
            ((condition-case ex
                 (let* ((next-id (fn/get-code-block-next-id))
                        (next-block-start (format fn/code-block-start-format next-id)))
                   (with-current-buffer tangle-buffer
                     (beginning-of-buffer)
                     (search-forward next-block-start)
                     (beginning-of-line)
                     (previous-line)
                     (insert "\n")
                     (insert block-start)
                     (insert "\n")
                     (insert code)
                     (insert "\n")
                     (insert block-end)
                     (insert "\n")
                     (insert "\n")
                     (save-buffer)
                     t))
               ('error nil))
             'add)
            (t
             (error "Trouble of updating code block"))))))

     (defun fn/check-duplicate-code-block-id ()
       "Check current buffer for duplicate ids."
       (interactive)
       (let ((id-table (make-hash-table))
           (same-ids (list))
           (current-id))
         (save-excursion
           (beginning-of-buffer)
           (condition-case ex
               (while t
                 (org-babel-next-src-block)
                 (setq current-id (fn/get-code-block-id))
                 (if (gethash current-id id-table nil)
                     (push current-id same-ids)
                   (puthash current-id t id-table)))
             ('error nil)))
         same-ids))

     (defcustom fn/org-edit-src-exit-hook nil
       "Hook when running edit exit."
       :type 'hook
       :group 'fn)

     (defun fn/org-edit-src-exit-hook-run (&rest args)
       "Run `fn/org-edit-src-exit-hook'."
       (run-hooks 'fn/org-edit-src-exit-hook))

     (advice-add 'org-edit-src-exit :after #'fn/org-edit-src-exit-hook-run)
   #+END_SRC

** Session Configurations
   When working with sessions, it would be nice to have some default
   configuration when opened.

   #+BEGIN_SRC emacs-lisp :block-id b8e02d73-638d-d7b5-2520-32fe159fdffb
     (use-feature workgroup-configuration
       (workgroups2)
       (require 'dash)


       ;; Variables
       (defvar fmwc/workgroup-configs (list)
         "An data type of workgroup initialization configuration.")

       (defvar fmwc/workgroup-config-icons (list)
         "An list of workgroup config icons, taken from `all-the-icons' mode line.")

       (defvar fmwc/current-workgroup-config nil
         "Current workgroup config used.")

       (defvar fmwc/workgroup-configs-loaded (list)
         "Workgroups configs loaded.")

       ;; Main macro config
       (defmacro fmwc/define-workgroup-configs (config-name init-body setup-body cleanup-body)
         (let* ((base-format "fmwc/%s-config-%s-hook")
             (init-function-name (downcase (format base-format config-name "init")))
             (setup-function-name (downcase (format base-format config-name "setup")))
             (cleanup-function-name (downcase (format base-format config-name "cleanup")))
             (init-function (intern init-function-name))
             (setup-function (intern setup-function-name))
             (cleanup-function (intern cleanup-function-name)))
           (fset init-function
                 `(lambda ()
                    ,(format "Workspace init config for %s" config-name)
                    (interactive)
                    (list ,init-body)))
           (fset setup-function
                 `(lambda ()
                    ,(format "Workspace setup config for %s" config-name)
                    (interactive)
                    (list ,setup-body)))
           (fset cleanup-function
                 `(lambda ()
                    ,(format "Workspace cleanup config for %s" config-name)
                    (interactive)
                    (list ,cleanup-body)))
           (if (>= (length fmwc/workgroup-configs) 10)
               (error "You already have 10 workgroup configurations already")
             `(add-to-list
               'fmwc/workgroup-configs
               (list
                ,config-name
                (quote ,init-function)
                (quote ,setup-function)
                (quote ,cleanup-function))
               t))))

       (defun fmwc/add-workgroup-config-icon (icon-family icon-function icon-name &rest args)
         "Just like with `all-the-icons' mode line, this is for workgroup config with
     ICON-FAMILY, ICON-FUNCTION, ICON-NAME and ARGS."
         (let* ((config-name (fmwc/current-workgroup-name)))
           (add-to-list
            'fmwc/workgroup-config-icons
            (append
             (list
              config-name
              icon-family
              icon-function
              icon-name)
             args))))

       (defun fmwc/workgroup-config-icon-for-workgroup ()
         "Return icon for workgroup as defined for `fmwc/workgroup-config-icons' list"
         (-if-let* ((current-workgroup-name (fmwc/current-workgroup-name))
                    (result (assoc current-workgroup-name fmwc/workgroup-config-icons)))
             (let* ((icon-result (cdr result))
                    (icon-font-function (car icon-result))
                    (icon-function (cadr icon-result))
                    (icon-args (cddr icon-result)))
               (propertize
                (format " %s " (apply icon-function icon-args))
                'help-echo (format "Workgroup: `%s`" current-workgroup-name)
                'face
                (list
                 :family (funcall icon-font-function))))
           nil))


       ;; Configurations
       (fmwc/define-workgroup-configs
        "Mine"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "random"
           :v-adjust -0.1))
        nil
        nil)

       (fmwc/define-workgroup-configs
        "Personal"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "book"
           :v-adjust -0.1)

          (when (fboundp 'fn/erc)
            (fn/erc))

          (when (fboundp 'jabber-connect-all)
            (jabber-connect-all))

          (when (fboundp 'slack-start)
            (slack-start)))
        (progn
          (delete-other-windows)
          (when (fboundp 'fn/prodigy-with-default-filters)
            (fn/prodigy-with-default-filters
             (fn/prodigy-add-default-tag-filter 'gnus))))
        nil)

       (fmwc/define-workgroup-configs
        "Working"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "code"
           :v-adjust -0.1))
        (progn
          (when (fboundp 'fn/prodigy-with-default-filters)
            (fn/prodigy-with-default-filters
             (fn/prodigy-add-default-tag-filter 'komunidad))))
        nil)

       (fmwc/define-workgroup-configs
        "Desktop"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "desktop"
           :v-adjust -0.1))
        nil
        nil)

       (fmwc/define-workgroup-configs
        "Blogger"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "comment"
           :v-adjust -0.1))
        (progn
          (when (fboundp 'fn/prodigy-with-default-filters)
            (fn/prodigy-with-default-filters
             (fn/prodigy-add-default-tag-filter 'fn-log))))
        nil)

       (fmwc/define-workgroup-configs
        "Writer"
        (progn
          (fmwc/add-workgroup-config-icon
           'all-the-icons-faicon-family
           'all-the-icons-faicon
           "pencil"
           :v-adjust -0.1))
        (progn
          (when (fboundp 'fn/prodigy-with-default-filters)
            (fn/prodigy-with-default-filters
             (fn/prodigy-add-default-tag-filter 'frontend-functions))))
        nil)


       ;; Api
       (defun fmwc/workgroup-config-name (workgroup)
         "Get the name of a WORKGROUP."
         (nth 0 workgroup))

       (defun fmwc/workgroup-config-init-function (workgroup)
         "Get the init function of a WORKGROUP."
         (nth 1 workgroup))


       (defun fmwc/workgroup-config-setup-function (workgroup)
         "Get the setup function of a WORKGROUP."
         (nth 2 workgroup))

       (defun fmwc/workgroup-config-cleanup-function (workgroup)
         "Get the cleanup function of a WORKGROUP."
         (nth 3 workgroup))


       ;; Workgroup specific
       (defun fmwc/workgroup-name (workgroup)
         "Get the name of a WORKGROUP."
         (wg-workgroup-name workgroup))

       (defun fmwc/create-default-workgroup (name)
         (wg-make-and-add-workgroup name t))

       (defun fmwc/current-workgroup-name ()
         "Get the current workgroup name."
         (when workgroups-mode
           (fmwc/workgroup-name (wg-current-workgroup))))

       (defun fmwc/workgroups ()
         "Get the workgroups."
         (when workgroups-mode
           (wg-workgroup-list-or-error)))


       ;; Custom
       (defun fmwc/get-workgroup-config-by-name (workgroup-name)
         "Get the corresponding workgroup from the config by the WORKGROUP-NAME."
         (-first
          (lambda (workgroup-config)
            (let ((config-name (fmwc/workgroup-config-name workgroup-config)))
              (string-equal config-name workgroup-name)))
          fmwc/workgroup-configs))

       (defun fmwc/get-current-workgroup-config ()
         "Get the current workgroup config."
         (fmwc/get-workgroup-config-by-name (fmwc/current-workgroup-name)))

       (defun fmwc/workgroup-config-setup ()
         "Initialize the workgroup per configuration."
         (condition-case ex
             (-if-let* ((config (fmwc/get-current-workgroup-config))
                        (config-name (fmwc/workgroup-config-name config))
                        (init-function (fmwc/workgroup-config-init-function config)))
                 (unless (-contains-p fmwc/workgroup-configs-loaded config-name)
                   (message "Running init for %s" config-name)
                   (prog2
                       (setq fmwc/current-workgroup-config config)
                       (funcall init-function)
                     (setq fmwc/current-workgroup-config nil))
                   (add-to-list 'fmwc/workgroup-configs-loaded config-name))
               nil)
           ('error (message "Workgroup config init error: " (error-message-string ex))))
         (condition-case ex
             (-if-let* ((config (fmwc/get-current-workgroup-config))
                        (setup-function (fmwc/workgroup-config-setup-function config)))
                 (progn
                   (message "Running setup for %s" (fmwc/workgroup-config-name config))
                   (prog2
                       (setq fmwc/current-workgroup-config config)
                       (funcall setup-function)
                     (setq fmwc/current-workgroup-config nil)))
               nil)
           ('error (message "Workgroup config setup error: " (error-message-string ex)))))

       (defun fmwc/workgroup-config-cleanup ()
         "Cleanup for workgroup configuration."
         (condition-case ex
             (-if-let* ((config (fmwc/get-current-workgroup-config))
                        (cleanup-function (fmwc/workgroup-config-cleanup-function config)))
                 (progn
                   (message "Running cleanup for %s" (fmwc/workgroup-config-name config))
                   (prog2
                       (setq fmwc/current-workgroup-config config)
                       (funcall cleanup-function)
                     (setq fmwc/current-workgroup-config nil)))
               nil)
           ('error (message "Workgroup config cleanup error: " (error-message-string ex)))))


       (defun fmwc/workgroup-config-configure ()
         "Tries to mirror the workspace configuration."
         (interactive)
         (if workgroups-mode
             (prog1
                 (-map-indexed
                  (lambda (index config)
                    (lexical-let* ((config-name (fmwc/workgroup-config-name config))
                                   (workgroups (fmwc/workgroups))
                                   (workgroup-index
                                    (-find-index
                                     (lambda (workgroup)
                                       (string-equal (fmwc/workgroup-name workgroup) config-name))
                                     workgroups)))
                      (cond
                       ((null workgroup-index)
                        (message "Creating workspace %s" config-name)
                        (wg-swap-workgroups-in-workgroup-list
                         (fmwc/create-default-workgroup config-name)
                         (nth index workgroups)))
                       ((= workgroup-index index)
                        "NOOP: All is good here.")
                       (t
                        (wg-swap-workgroups-in-workgroup-list
                         (nth index workgroups)
                         (nth workgroup-index workgroups))))))
                  fmwc/workgroup-configs)
               (message "Done auto configuring workgroups."))
           (message "Workgroup mode is not active.")))

       (use-feature workspace-prodigy
         (prodigy)
         (add-hook 'wg-before-switch-to-workgroup-hook #'fn/prodigy-clear-default-filter)
         (add-hook 'wg-before-switch-to-workgroup-hook #'fn/prodigy-set-default-filter-hook))


       (setq wg-open-this-wg (fmwc/workgroup-config-name (car fmwc/workgroup-configs)))

       (add-hook 'wg-after-switch-to-workgroup-hook #'fmwc/workgroup-config-setup)
       (add-hook 'wg-before-switch-to-workgroup-hook #'fmwc/workgroup-config-cleanup))
   #+END_SRC

** Window Layouts
   Split the windows into a nice four panel division. This works even
   well with [[golden-ratio]].

   #+BEGIN_SRC emacs-lisp :block-id 269509fe-2f84-78ef-d8e0-b34bf7d9e605
     (require 'dash)

     (defconst fmw/empty-buffer "*unchained buffer*"
       "A buffer to represent an empty one")

     (defun fmw/remap-window-buffers (buffer-remapper)
       "Reassigns the windows with new buffers taking a remapper function over the old ones"
       (lexical-let* ((current-buffers (mapcar 'window-buffer (window-list)))
                      (empty-buffer (if (get-buffer fmw/empty-buffer)
                                        (get-buffer fmw/empty-buffer)
                                      (generate-new-buffer fmw/empty-buffer)))
                      (new-buffers (funcall buffer-remapper current-buffers)))
         (mapc (lambda (pair)
                 (pcase-let ((`(,current-buffer . ,current-window) pair))
                   (when current-window
                     (set-window-buffer current-window
                                        (if current-buffer current-buffer
                                          empty-buffer))))
                 )
               (-zip-fill nil new-buffers (window-list)))))

     (defun fmw/restore-buffers (window-movement)
       "Restore buffers after doing a window layout"
       (lexical-let ((mover window-movement))
         (fmw/remap-window-buffers (lambda (old-buffers)
                                     (funcall window-movement)
                                     old-buffers))))

     (defun fmw/rotate-window-buffers (arg)
       "Rotate the buffers from window to the next like a clock"
       (interactive "P")
       (lexical-let ((rotation (if arg arg 1)))
         (fmw/remap-window-buffers (lambda (old-buffers)
                                     (-rotate rotation old-buffers)))))

     (defun fmw/four-part-horizontal-window-layout ()
       "Split the frame into four windows horizontally. I use this when I'm working in a project where the
        - upper left serves the main file
        - upper right serves as a secondary file
        - lower left serves as auxilliary or task buffer
        - lower right serves a project buffer"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-vertically)
                              (split-window-horizontally)
                              (other-window 2)
                              (split-window-horizontally)
                              (other-window 2))))

     (defun fmw/four-part-vertical-window-layout ()
       "Unlike with the =fn/four-way-horizontal-layout=, I use this more oftenly on dired to make file moving easier
        (and probably more)"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-vertically)
                              (split-window-horizontally)
                              (other-window 2)
                              (split-window-horizontally)
                              (other-window 2))))

     (defun fmw/three-part-left-window-layout ()
       "Like =fn/four-way-horizontal-layout= but fits a smaller screen namely my Raspberry Pi."
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode t)
                              (delete-other-windows)
                              (split-window-horizontally)
                              (other-window 1)
                              (split-window-vertically)
                              (other-window 2))))

     (defun fmw/three-part-vertical-window-layout ()
       "An layout seen at a meetup, seems interesting to work with.
        However, this is disables golden-ration-mode to maintain the delicate origami folds"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode nil)
                              (delete-other-windows)
                              (lexical-let* ((total-width (frame-width))
                                             (one-third-fold  (/ total-width 3)))
                                ;; Split the right window by a third, negative arguments huh.
                                (split-window-horizontally (- one-third-fold))
                                (split-window-horizontally (- one-third-fold))))))

     (defun fmw/four-part-equal-vertical-window-layout ()
       "This is for my music conversion but not that mind blowing to do"
       (interactive)
       (fmw/restore-buffers (lambda ()
                              (setq golden-ratio-mode nil)
                              (delete-other-windows)

                              (split-window-horizontally)
                              (split-window-horizontally)
                              (other-window 2)

                              (split-window-horizontally)
                              (other-window 2))))
   #+END_SRC

** Utility Commands
   Some commands to get me here and there

   #+BEGIN_SRC emacs-lisp :block-id 699368f6-d870-cfdc-c7a7-56142502caa6
     (defun fn/insert-date ()
       "Insert time at point, useful when you want to put a date.
        TODO: Would be useful if you can change formats too"
       (interactive)
       (let ((time-format "%Y-%m-%d"))
         (insert (format-time-string time-format))))

     (defun fn/save-and-kill-buffer ()
       "Save and kill the buffer in one command"
       (interactive)
       (call-interactively 'save-buffer)
       (call-interactively 'kill-this-buffer))


     (defun fn/dired-parent ()
       "Quick command to go to parent dired of buffer immediately"
       (interactive)
       (dired ".."))
   #+END_SRC

** Coins.Ph API
   Some things to help me trade bitcoins, so this section might not be
   useful to anyone else.

   #+BEGIN_SRC emacs-lisp :block-id a9f60f7c-71c6-c1ce-34ec-0dbc33178462
     (require 's)

     (defconst fmc/coin-cli-file (expand-file-name "coiner-cli.py" "~/Fakespace/coins-watcher")
       "The cli file to interact with")

     (defconst fmc/coin-cli-executor "python"
       "CLI command to run the script")

     (defun fmc/parse-json (json-text)
       "My shiv of parsing json into alist, sadly json.el doesn't work in parsing weirdly"

       (lexical-let* ((json-regex "\'\\(\\w+\\)\':\s+\\([a-Z0-9.]+\\)[,\}]")
                      (json-matches (s-match-strings-all json-regex json-text))
                      (json-key-values (mapcar #'cdr json-matches)))
         (mapcar (lambda (pair)
                   (lexical-let* ((key (car pair))
                                  (value (cadr pair))
                                  (symbolic-key key)
                                  (symolic-value (string-to-number value)))
                     (cons symbolic-key symolic-value)))
                 json-key-values)))

     (defun fmc/call-cli (command &optional amount)
       "Main function to execute fmc commands"
       (lexical-let* ((coin-cli-buffer (find-file-noselect fmc/coin-cli-file)))
         (with-current-buffer coin-cli-buffer
           (lexical-let* ((command-args (list fmc/coin-cli-executor fmc/coin-cli-file))
                          (action-arg (list command))
                          (amount-args (list "-a" amount))
                          (base-args (append command-args action-arg))
                          (args (if amount (append base-args amount-args)
                                  base-args))
                          (cli-output (apply 'fn/run-command args)))
             (fmc/parse-json (format "\"%s\"" cli-output))))))

     (defun fmc/get-quote ()
       "Get quote from the bitcoin site"
       (interactive)
       (fmc/call-cli "quote"))

     (defun fmc/buy-coin ()
       "Buy coins"
       (interactive)
       (lexical-let* ((amount (read-number "Enter amount: "))
                      (current-quote (fmc/call-cli "quote"))
                      (current-buy (cdr (assoc "buy" current-quote)))
                      (current-value (/ amount current-buy))
                      (confirm-action (yes-or-no-p (format "Are you sure you to buy %f at %f" amount current-buy))))
         (when confirm-action
           (fmc/call-cli "buy" amount)
           (message "Successfully bought %f at %f amounting to %f" amount current-buy current-value))))

     (defun fmc/sell-coin ()
       "Sell coins"
       (interactive)
       (lexical-let* ((amount (read-number "Enter amount: "))
                      (current-quote (fmc/call-cli "quote"))
                      (current-sell (cdr (assoc "sell" current-quote)))
                      (current-value (* amount current-sell))
                      (confirm-action (yes-or-no-p (format "Are you sure you to sell %f at %f amounting to %f" amount current-sell current-value))))
         (when confirm-action
           (fmc/call-cli "sell" amount)
           (message "Successfully sold %f at %f" amount current-value))))
   #+END_SRC
** Sensitive Mode
   When editiing gpg or sensitve files, I would like to avoid backing it
   up so here is a [[http://anirudhsasikumar.net/blog/2005.01.21.html][minor mode]] to do so.

   #+BEGIN_SRC emacs-lisp :block-id 2d63832e-d21c-e020-d3a4-f00e6d3be7bf
     (define-minor-mode fq/sensitive-mode
       "For sensitive files like password lists.
     It disables backup creation and auto saving.

     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode."
       ;; The initial value.
       nil
       ;; The indicator for the mode line.
       " Sensitive"
       ;; The minor mode bindings.
       nil
       (if (symbol-value fq/sensitive-mode)
           (progn
             ;; disable backups
             (set (make-local-variable 'backup-inhibited) t)
             ;; disable auto-save
             (if auto-save-default
                 (auto-save-mode -1)))
                                             ;resort to default value of backup-inhibited
         (kill-local-variable 'backup-inhibited)
                                             ;resort to default auto save setting
         (if auto-save-default
             (auto-save-mode 1))))

     (add-to-list 'auto-mode-alist '("\\.gpg\\'" . fq/sensitive-mode))
   #+END_SRC
** Variable Namer
   Some quick means to insert variables

   #+BEGIN_SRC emacs-lisp :block-id b94325a4-18e7-f361-2ea0-154f2cbc5d0c
     (defun fmv/map-head-tail (header tailer xs)
       "Map the head and tail separately"
       (pcase xs
         (`nil nil)
         (`(,head . ,tail) (append
                            (list (funcall header head))
                            (mapcar tailer tail)))))

     (defun fmv/insert-camel-case (name)
       "At point, insert a given name as camelCase"
       (interactive "sCamel Case a variable name(varName):")
       (lexical-let* ((separator "")
                      (var-tokens (split-string name " " t))
                      (var-pieces (fmn/map-head-tail #'downcase
                                                     #'upcase-initials
                                                     var-tokens)))
         (insert (string-join var-pieces separator))))

     (defun fmv/insert-hyphenated (name)
       "At point, insert a given name as hyphen-ated"
       (interactive "sHyphenate variable name(var-name):")
       (lexical-let* ((separator "-")
                      (var-tokens (split-string name " " t))
                      (var-pieces (mapcar #'downcase var-tokens)))
         (insert (string-join var-pieces separator))))
   #+END_SRC

** Dired Shortcuts
   Some shortcuts with the common folder

   #+BEGIN_SRC emacs-lisp :block-id 41197e3d-c256-224b-3d97-7eb3f1b039d5
     (defun fn/dired-download-dir ()
       "Just a quick shortcut to my directory folder"
       (interactive)
       (dired "~/Downloads"))

     (defun fn/dired-mountain-dir ()
       "Just a quick shortcut to my mountain folder"
       (interactive)
       (dired "~/Mountain"))

     (defun fn/dired-fakespace-dir ()
       "Just a quick shortcut to my fakespace folder"
       (interactive)
       (dired "~/Fakespace"))

     (defun fn/dired-home-dir ()
       "Quickly visit home directory"
       (interactive)
       (dired "~"))

     (defun fn/dired-lib-dir ()
       "Quickly visit library directory"
       (interactive)
       (dired fn/lib-dir))

     (defun fn/dired-module-dir ()
       "Quickly visit modules library"
       (interactive)
       (dired "~/Modules"))
   #+END_SRC

** Summarize Text
   Inspired from text summarizing my email, here is my generic version
   of it.

   #+BEGIN_SRC emacs-lisp :block-id cdabbfd8-dba9-0286-24da-f54860aef912
     (defun fn/text-summarizing (&optional text)
       "Summarize text for easier comprehension"
       (lexical-let ((raw-text (or text
                                   (buffer-substring-no-properties (point-min) (point-max))))
                     (summary-file (make-temp-file ".summary")))
         (with-temp-file summary-file
           (insert raw-text))
         (deferred:nextc
           (deferred:process-shell
             "sumy" "lex-rank"
             "--length" "5"
             "--file" summary-file)
           (lambda (summary-output)
             (prog1
                 (s-split "\n" (s-trim-right summary-output))
               (delete-file summary-file))))))

     (defun fn/text-summarize (&optional text)
       "This just returns the result of fn/text-summarizing immediately"
       (interactive)
       (lexical-let ((raw-text (or text
                                   (buffer-substring-no-properties (point-min) (point-max))))
                     (summary-file (make-temp-file ".summary")))
         (with-temp-file summary-file
           (insert raw-text))
         (prog1
             (s-split "\n"
                      (fn/run-command "sumy" "lex-rank"
                                      "--length" "5"
                                      "--file" summary-file))
           (delete-file summary-file))))

   #+END_SRC
** Performance Indicator
   Check if Emacs is running fast.

   #+BEGIN_SRC emacs-lisp :block-id 1c95aa79-5f9f-abcf-7d28-a9110a32d753
     (require 'deferred)

     (use-feature frame-delay
       nil
       (defvar fn/-previous-time (current-time)
         "Previous time recording.  Not to be used directly.")

       (defvar fn/current-frame-delay 0.0
         "Fps recording.")

       (defun fn/record-frame-delay ()
         "Record frame delay."
         (prog1
             (let* ((now (current-time))
                    (time-diff
                     (float-time (time-subtract now fn/-previous-time))))
               (setq fn/current-frame-delay time-diff)
               (force-mode-line-update))
           (fn/-mark-time)))

       (defun fn/-mark-time ()
         "Mark the previous time for use"
         (setq fn/-previous-time (current-time)))

       (run-with-idle-timer 0 t #'fn/record-frame-delay)

       (add-hook 'pre-command-hook #'fn/-mark-time))

     (unless (eq system-type 'windows-nt) ;; Windows requires powershell just to poll it. WTF!?
       (use-feature cpu-usage
         (deferred)
         (defvar fn/current-cpu-usage 0.0
           "Cpu recording.")

         (defconst fn/cpu-usage-command "grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}'")

         (defun fn/record-cpu-usage ()
           "Record cpu usage."
           (deferred:error
             (deferred:nextc
               (deferred:process-shell
                 fn/cpu-usage-command)
               (lambda (value)
                 (setq fn/current-cpu-usage (string-to-number value))))
             (lambda ()
               (cancel-timer fn/cpu-timer)
               (unintern 'fn/current-cpu-usage)
               (message "Error with CPU monitor, shutting it down"))))

         (defvar fn/cpu-timer (run-with-idle-timer 1 t #'fn/record-cpu-usage)
           "A cpu timer if you ever want to quit it."))

       (use-feature memory-usage
         (deferred)
         (defvar fn/current-memory-usage 0.0
           "Memory recording.")

         (defconst fn/memory-usage-command
           "free | grep Mem | awk '{print $3/$2 * 100.0}'")

         (defun fn/record-memory-usage ()
           "Record memory usage."
           (deferred:error
             (deferred:nextc
               (deferred:process-shell
                 fn/memory-usage-command)
               (lambda (value)
                 (setq fn/current-memory-usage (string-to-number value))))
             (lambda ()
               (cancel-timer fn/memory-timer)
               (unintern 'fn/current-memory-usage)
               (message "Error with RAM monitor, shutting it down"))))

         (defvar fn/memory-timer (run-with-idle-timer 1 t #'fn/record-memory-usage)
           "A memory timer.")))
   #+END_SRC

** starup and shutdown hook
   Small script to update my org files

   #+BEGIN_SRC emacs-lisp :block-id b1fd9c85-3b45-96b6-3659-ce907e106fba
     (defun fn/startup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library && git pull origin master"))

     (defun fn/cleanup ()
       (interactive)
       (shell-command "cd ~/Fakespace/nobody-library\
      && git add diary/*\
      && git commit -a -m \"Home Update\"\
      && git push origin master"))

     (define-key fn-custom-prefix-map (kbd "C-c m s") 'fn/startup)
     (define-key fn-custom-prefix-map (kbd "C-c m c") 'fn/cleanup)
   #+END_SRC
** Create media diary
   A personal script to bundle my journal, recordings and images into one org file. Not to be consumed by anyone else

   #+BEGIN_SRC emacs-lisp :block-id 74c6588f-2f87-0d6a-b2b0-a1d2edf3eb15
     (require 's)


     (defun fmd/get-document-property (key &optional selected-buffer)
       "Get the property of the document which starts with #+PROPERTY"
       (with-current-buffer (if selected-buffer selected-buffer (buffer-name))
         (lexical-let* ((property-regex (format "\#\\+%s:\s+\\(.*\\)" key))
                        (property-match (s-match property-regex (buffer-substring-no-properties (point-min) (point-max))))
                        (property (if property-match (cadr property-match)
                                    nil)))
           property)))

     (defun fmd/get-document-block-property (key &optional selected-buffer)
       "Like with fmd/get-document-property but finds a block summary #+BEGIN_key #+END_key"
       (with-current-buffer (if selected-buffer selected-buffer (buffer-name))
         (lexical-let* ((property-regex (format "#\\+BEGIN_%s\n\\([\0-\377[:nonascii:]]*\\)\n#\\+END_%s" key key))
                        (property-match (s-match property-regex (buffer-substring-no-properties (point-min) (point-max))))
                        (property (if property-match (s-trim (cadr property-match))
                                    nil)))
           property)))


     (defun fmd/get-title (&optional selected-buffer)
       "Get the #+TITLE value of the current buffer"
       (fmd/get-document-property "TITLE" selected-buffer))

     (defun fmd/get-summary (&optional selected-buffer)
       "Get the #+BEGIN_SUMMARY section of the buffer"
       (fmd/get-document-block-property "SUMMARY" selected-buffer))


     (defconst fmd/md-root "/mnt/veracrypt1/media-diary/compile/"
       "The media diary directory")

     (defconst fmd/md-compile-date-filter (expand-file-name ".date" fmd/md-root)
       "The media diary directory")


     (defconst fmd/md-summary-file-name "media-diary.org"
       "The media diary directory")

     (defconst fmd/md-summary-file (expand-file-name  "media-diary.org" fmd/md-root)
       "The media diary directory")

     (defconst fmd/md-title "Media Diary"
       "Main header of the file")

     (defconst fmd/md-note-title "Notes"
       "Note header of the file")

     (defconst fmd/md-journal-title "Journal"
       "Journal header of the file")

     (defconst fmd/md-media-title "Media"
       "Journal header of the file")


     (defconst fmd/md-datetime-format "%b. %d, %Y"
       "Time format for the compilation")

     (defconst fmd/md-audio-datetime-format "%b. %d, %Y %T : Recording"
       "Audio time format for the compilation")

     (defconst fmd/md-photo-datetime-format "%b. %d, %Y %T : Photograph"
       "Photo format for the compilation")

     (defconst fmd/md-summary-default-text "Something profound happened but I forgot like Dory"
       "The default text to be displayed")

     (defconst fmd/md-journal-summary-default-text "Looks like I forgot to write something this day"
       "The default text to be displayed")


     (defconst fmd/md-journal-dir-name "journal"
       "The journal directory source")

     (defconst fmd/md-audio-dir-name "audio"
       "The audio directory source")

     (defconst fmd/md-photo-dir-name "photo"
       "The photo directory source")


     (defconst fmd/md-photo-extension "jpg"
       "The photo file extension")

     (defconst fmd/md-audio-extension "wav"
       "The audio file extension")


     (defconst fmd/md-journal-dir (expand-file-name fmd/md-journal-dir-name fmd/md-root)
       "The journal directory")

     (defconst fmd/md-audio-dir (expand-file-name fmd/md-audio-dir-name fmd/md-root)
       "The audio directory")

     (defconst fmd/md-photo-dir (expand-file-name fmd/md-photo-dir-name fmd/md-root)
       "The audio directory")

     (defun fmd/parse-file-parts (file)
       "Parse the file name compatible for the media diary file"
       (lexical-let* ((file-regex  "\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\)?_?\\([0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}+\\)?\\( - \\)?\\(.+\\)?\\.\\(.+\\)")
                      (filename (file-name-nondirectory file))
                      (file-matches (s-match-strings-all file-regex filename))
                      (file-match (car file-matches)))
         (message filename)
         (lexical-let* ((file-date (nth 1 file-match))
                        (file-time (nth 2 file-match))
                        (file-title (nth 4 file-match))
                        (file-extension (nth 5 file-match)))
           (lexical-let* ((parts (list))
                          (time-part (if file-time (s-replace "-" ":" file-time)
                                       "00:00:00"
                                       ))
                          (date-raw (concat file-date " " time-part))
                          (datetime-part (apply 'encode-time (parse-time-string date-raw))))
             (setq parts (plist-put parts 'datetime datetime-part))
             (setq parts (plist-put parts 'title file-title))
             (setq parts (plist-put parts 'extension file-extension))
             parts))))


     (defun fmd/insert-org-header (header)
       "Insert header"
       (org-insert-heading t nil t)
       (insert header))

     (defun fmd/insert-org-subheader (subheader)
       "Insert subheader"
       (end-of-buffer)
       (org-insert-heading t nil t)
       (insert subheader)
       (org-demote))

     (defun fmd/insert-org-link (link title)
       "Insert link"
       (end-of-buffer)
       (org-insert-heading t)
       (org-insert-link nil link title))

     (defun fmd/insert-document-option (key value)
       "Insert document file option"
       (insert (format "#+%s: %s\n" key value)))

     (defun fmd/insert-file-headers (start-date)
       "Insert default file headers"
       (interactive)
       (fm/insert-org-gpg-headers)

       (end-of-visual-line)
       (newline)

       (fmd/insert-document-option "TITLE" (format "Media Diary of %s"
                                                   (format-time-string "%b. %Y" start-date)))
       (fmd/insert-document-option "DATE" (format-time-string "%Y-%m" start-date))
       (fmd/insert-document-option "STARTUP" "content")
       (fmd/insert-document-option "OPTIONS" "toc:nil"))


     (defun fmd/filter-files (directory prefix extension)
       "Get the files based on prefix and extension"
       (directory-files directory nil
                        (format-message "%s-.*\\.%s$" prefix extension)))

     (defun fmd/once (f)
       "Invoke a function only once, useful inside a loop"
       (lexical-let ((g f)
                     (is-invoked nil))
         (lambda (&rest args)
           (if is-invoked nil
             (progn
               (setq is-invoked t)
               (apply g args))))))


     (defun fmd/compile-media-diary ()
       "Compile the media diary, the diary must be compiled first with the shell script"
       (interactive)
       (lexical-let* ((md-prefix (s-trim (shell-command-to-string
                                          (format "cat %s" fmd/md-compile-date-filter))))
                      (md-start-date
                       (lexical-let ((start-date-text (format "%s-01 00:00:00" md-prefix)))
                         (apply 'encode-time (parse-time-string start-date-text)))))
         (lexical-let* ((render-header
                         (lambda ()
                           (fmd/insert-file-headers md-start-date)
                           (fmd/insert-org-header fmd/md-title)))
                        (render-note-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-note-title)
                           (newline-and-indent)
                           (insert fmd/md-summary-default-text)))
                        (render-journal-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-journal-title)
                           (lexical-let* ((journal-files (fmd/filter-files fmd/md-journal-dir md-prefix "org"))
                                          (demote-first (fmd/once (lambda () (org-demote)))))
                             (mapc (lambda (journal-file-name)
                                     (lexical-let* ((journal-file (expand-file-name journal-file-name fmd/md-journal-dir))
                                                    (journal-piece (fmd/parse-file-parts journal-file-name))
                                                    (journal-time (plist-get journal-piece 'datetime))
                                                    (journal-base-title (format-time-string fmd/md-datetime-format journal-time))
                                                    (journal-title
                                                     (lexical-let ((journal-buffer (find-file-noselect journal-file)))
                                                       (prog1
                                                           (fmd/get-title journal-buffer)
                                                         (kill-buffer journal-buffer))))
                                                    (journal-summary
                                                     (lexical-let ((journal-buffer (find-file-noselect journal-file)))
                                                       (prog1
                                                           (fmd/get-summary journal-buffer)
                                                         (kill-buffer journal-buffer))))
                                                    (journal-full-title
                                                     (format "%s - %s" journal-base-title journal-title)))
                                       (fmd/insert-org-link (concat "file:" fmd/md-journal-dir-name "/" journal-file-name)
                                                            journal-full-title)
                                       (funcall demote-first)

                                       (newline-and-indent)
                                       (insert (or journal-summary fmd/md-journal-summary-default-text))

                                       (org-set-property "CREATED_ON"
                                                         (format-time-string "%F %T" journal-time))))
                                   journal-files))))
                        (render-media-section
                         (lambda ()
                           (fmd/insert-org-subheader fmd/md-media-title)

                           (lexical-let* ((photo-files (fmd/filter-files fmd/md-photo-dir md-prefix fmd/md-photo-extension))
                                          (audio-files (fmd/filter-files fmd/md-audio-dir md-prefix fmd/md-audio-extension))
                                          (media-files
                                           (sort (append photo-files audio-files)
                                                 (lambda (left right)
                                                   (lexical-let* ((result
                                                                   (compare-strings
                                                                    (file-name-sans-extension left) nil nil
                                                                    (file-name-sans-extension right) nil nil
                                                                    nil)))
                                                     (if (booleanp result) t
                                                       (if (> result 0) nil t))))))
                                          (demote-first (fmd/once (lambda () (org-demote)))))

                             (intern-soft "photo")
                             (intern-soft "audio")

                             (mapc (lambda (media-file)
                                     (lexical-let* ((media-piece (fmd/parse-file-parts media-file) )
                                                    (media-time (plist-get media-piece 'datetime))
                                                    (media-title (plist-get media-piece 'title))
                                                    (media-extension (plist-get media-piece 'extension))
                                                    (media-type (if (string-equal media-extension fmd/md-audio-extension)
                                                                    'audio 'photo))
                                                    (media-time-format (if (eq media-type 'audio)
                                                                           fmd/md-audio-datetime-format
                                                                         fmd/md-photo-datetime-format))
                                                    (media-dir-name (if (eq media-type 'audio)
                                                                        fmd/md-audio-dir-name fmd/md-photo-dir-name))
                                                    (media-base-title (format-time-string media-time-format media-time))
                                                    (media-full-title (if media-title (format "%s - %s" media-base-title media-title)
                                                                        media-base-title)))
                                       (fmd/insert-org-link (concat "file:" media-dir-name "/" media-file)
                                                            media-full-title)
                                       (funcall demote-first)
                                       (org-set-property "CREATED_ON"
                                                         (format-time-string "%F %T" media-time))))
                                   media-files)))))

           (find-file fmd/md-summary-file)

           (funcall render-header)
           (funcall render-note-section)
           (funcall render-journal-section)
           (funcall render-media-section)

           (beginning-of-buffer)
           (org-set-startup-visibility)
           (save-buffer)

           (fmd/build-media-diary-html))))

     (defun fmd/build-media-diary-html ()
       "Build the current diary as an html org project"
       (interactive)
       (org-publish
        (list "fmd-html"
              :base-directory fmd/md-root
              :base-extension "org"
              :publishing-directory fmd/md-root
              :recursive t
              :publishing-function 'org-html-publish-to-html
              :html-extension "html"
              :headline-levels 4
              :section-numbers nil
              :with-toc nil)
        t))
   #+END_SRC

** Open standard buffers
   Nice to see the standard buffers

   #+BEGIN_SRC emacs-lisp :block-id eb9c2508-1f1d-46af-a5cf-783926916691
     (defun fn/open-message-buffer ()
       (interactive)
       (switch-to-buffer "*Messages*"))
   #+END_SRC

** Open config file
   This is just a convenience to open this config file

   #+BEGIN_SRC emacs-lisp :block-id 6d82f337-90f7-8583-6845-c305c7285f95
     (defun fn/find-config-file ()
       (interactive)
       (find-file (expand-file-name "config.org" user-emacs-directory)))
   #+END_SRC

** Insert relative path
   Makes it easier to insert relative paths

   #+BEGIN_SRC emacs-lisp :block-id a3d6cc8d-a9ee-e266-bd29-54a77a6cc68f
     (require 'f)


     (defconst fn/relative-same-node "."
       "Represents the same node on a path.")

     (defconst fn/relative-parent-node ".."
       "Represents the parent node on a path.")

     (defun fn/relative-parent-node-thunk (&rest args)
       "Always returns `fn/relative-parent-node'."
       fn/relative-parent-node)

     (defun fn/relative-path (source-path target-path)
       "An attempt to compute the relative path from SOURCE-PATH to TARGET-PATH."
       (letrec ((recurser
            (lambda (upward-nodes downward-nodes parent-node)
              (cond
               ((and (null upward-nodes) (null downward-nodes))
                (string-join
                 (list fn/relative-same-node parent-node)
                 (f-path-separator)))
               ((null (car upward-nodes))
                (string-join
                 (append (list fn/relative-same-node)
                         downward-nodes)
                 (f-path-separator)))
               ((null (car downward-nodes))
                (string-join
                 (append (mapcar #'fn/relative-parent-node-thunk upward-nodes)
                         (list parent-node))
                 (f-path-separator)))
               ((string-equal (car upward-nodes)
                              (car downward-nodes))
                (funcall recurser
                   (cdr upward-nodes)
                   (cdr downward-nodes)
                   (car upward-nodes)))
               (t
                (lexical-let* ((up-nodes (or (mapcar #'fn/relative-parent-node-thunk (cdr upward-nodes))
                                 (list fn/relative-same-node)))
                    (down-nodes downward-nodes))
                  (string-join
                   (append up-nodes down-nodes)
                   (f-path-separator))))))))
         (funcall recurser (f-split source-path) (f-split target-path) fn/relative-same-node)))

     (defun fn/insert-relative-file-path (arg)
       "Insert the relative file path of a source file to a target file.
     If prefix ARG is present, select the source file."
       (interactive "P")
       (let* ((source-path
            (cond
             (arg
              (car (find-file-read-args "Find source file: " t) ))
             ((buffer-file-name)
              (buffer-file-name))
             (t (error "Source file does not have a file name."))))
           (target-path (car (find-file-read-args "Find target file: " t))))
         (insert (fn/relative-path source-path target-path))))
   #+END_SRC

* Key Bindings
  Here is where all the key binding I mapped to

  #+BEGIN_SRC emacs-lisp :block-id af4279a7-a5d4-a700-1248-a5e0ae50e962
    (defun fn/trigger-key (key)
      "Returns a function that triggers the function bound by the key"
      (lexical-let* ((key-trigger key)
                     (trigger (lambda ()
                                (interactive)
                                (let ((key-command (key-binding key-trigger)))
                                  (cond
                                   (key-command
                                    (message "Triggering %s" key-command)
                                    (command-execute key-command))
                                   (t
                                    (message "No key bound to %s" key-trigger)))))))
        trigger))


    ;; Motion
    (define-key fn-custom-prefix-map (kbd "b RET") (fn/trigger-key (kbd "C-RET")))
    (define-key fn-custom-prefix-map (kbd "b b RET ") (fn/trigger-key (kbd "M-RET")))


    ;; Keys
    (global-set-key (kbd "M-n") (fn/trigger-key (kbd "DEL")))



    ;; Search
    (define-key fn-standard-prefix-map (kbd "C-s") 'fn/isearch-forward-normally)
    (define-key fn-standard-prefix-map (kbd "C-r") 'fn/isearch-backward-normally)


    ;; Buffers
    (define-key fn-standard-prefix-map (kbd "k") 'kill-this-buffer)
    (define-key fn-standard-prefix-map (kbd "C-k") 'fn/save-and-kill-buffer)

    ;; Windows
    (define-key fn-custom-prefix-map (kbd "w h") 'fmw/four-part-horizontal-window-layout)
    (define-key fn-custom-prefix-map (kbd "w v") 'fmw/four-part-vertical-window-layout)
    (define-key fn-custom-prefix-map (kbd "w t") 'fmw/three-part-left-window-layout)
    (define-key fn-custom-prefix-map (kbd "w 3") 'fmw/three-part-vertical-window-layout)
    (define-key fn-custom-prefix-map (kbd "w 4") 'fmw/four-part-equal-vertical-window-layout)
    (define-key fn-custom-prefix-map (kbd "w r") 'fmw/rotate-window-buffers)

    (define-key fn-custom-prefix-map (kbd "w s") 'fn/swap-with-numbered-window)

    ;; System Buffers
    (define-key fn-custom-prefix-map (kbd "b m") 'fn/open-message-buffer)

    ;; Shell
    (define-key fn-standard-prefix-map (kbd "x s") 'shell)


    ;; Customize
    (define-key fn-standard-prefix-map (kbd "C g") 'customize-group)



    ;; Files
    (define-key fn-custom-prefix-map (kbd "b c") 'fn/find-config-file)
    (define-key fn-custom-prefix-map (kbd "b o") 'fn/find-main-org-file)
    (define-key fn-custom-prefix-map (kbd "b l") 'fn/find-ledger-file)


    ;; Special Buffers
    (define-key fn-custom-prefix-map (kbd "b j") 'fn/display-jabber-roster-buffer)


    ;; Dired
    (define-key fn-custom-prefix-map (kbd "d h") #'fn/dired-emacs-dir)
    (define-key fn-custom-prefix-map (kbd "d d") #'fn/dired-download-dir)
    (define-key fn-custom-prefix-map (kbd "d M") #'fn/dired-mountain-dir)
    (define-key fn-custom-prefix-map (kbd "d f") #'fn/dired-fakespace-dir)
    (define-key fn-custom-prefix-map (kbd "d ~") #'fn/dired-home-dir)
    (define-key fn-custom-prefix-map (kbd "d l") #'fn/dired-lib-dir)
    (define-key fn-custom-prefix-map (kbd "d m") #'fn/dired-module-dir)

    (define-key fn-custom-prefix-map (kbd "^") #'fn/dired-parent)


    ;; Special
    (define-key fn-standard-prefix-map (kbd "l l") #'fn/chat-log-open) ;; From binding above
    (define-key fn-standard-prefix-map (kbd "l L") #'fn/chat-log-clear)
    (define-key fn-standard-prefix-map (kbd "l a") #'fn/alert-log-open)

    (define-key fn-custom-prefix-map (kbd "i p") #'fn/insert-relative-file-path)

    ;; Namer
    (define-key fn-custom-prefix-map (kbd "v c") #'fmv/insert-camel-case)
    (define-key fn-custom-prefix-map (kbd "v h") #'fmv/insert-hyphenated)


    ;; Functions
    (define-key fn-custom-prefix-map (kbd  "r s") 'fn/startup)
    (define-key fn-custom-prefix-map (kbd  "r c") 'fn/cleanup)

    ;; Custom Emacs
    (define-key fn-custom-prefix-map (kbd  "e e") 'fn/bootstrap-experimental)
    (define-key fn-custom-prefix-map (kbd  "e C-p") 'fn/bootstrap-previous)
    (define-key fn-custom-prefix-map (kbd  "e s") 'fn/bootstrap-spacemacs)
    (define-key fn-custom-prefix-map (kbd  "e f") 'fn/bootstrap-from-dir)

  #+END_SRC
